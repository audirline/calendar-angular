{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AACA;;AACAA;AACAC;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACAA;AACA,SAFA,MAGA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;UACAC;AACA;AAAA;;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACAC;AACAC;AAAuCC,uCAAvC;AAAuCC;AAAvC;AACA,aAJA,MAKA;AACA;AACA;;AACA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA,aAPA,CAQA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA,+EAAsEC,+BAAtE;;AACA,4BAAwBC,4BAAxB,EAAsDA,GAAtD,EAAsD;AACtD;;AACAC;AACA;;AACA;AACA;AACA;;AACAL;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACAD;AACAE;;AACA;AACAA;AACA;;AACA;;AACAK;AACAN;AAAqDC,4CAArD;AAAqDC;AAArD;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACAI;AACA;;AACAN;AACA;AACA;;;;iBACA;AACA;AACA,+FADA,CAEA;AACA;AACA;AACA;;;AACA;AACAO;AACA;;AACAD;AACAA,4DAVA,CAWA;AACA;AACA;AACA;;AACAA,4DAfA,CAgBA;AACA;;AACAA;;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACAA;AACAA;AACA;AACA;AACA;;;;iBACA;AACA;AACA,wFACAE,MADA,CACA;AAAA;AAAA,aADA;AAEAC;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA,6DADA,CAEA;AACA;;AACAC;AACAD;AACAE;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACAA;AACAC;AACAH;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,kEAAyDI,OAAzD,EAAiEC,IAAjE;AACA,+DAXA,CAYA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;;;;;AAEAhB;AAAyD,yCAAgCiB,uDAAgBC,qDAAhB,CAAhC;AAAwD,OAAjH;;AACAlB,6BAAsBiB,iEAAqB;AAAGE;AAA4C,oCAAyBF,uDAAYC,qDAAZ,CAAzB;AAAqD,SAApG;AAAoGE,6BAApG;AAAoGC;AAApG,OAArB,CAAtB;;AACArB;AAAA,gBACA;AAAMsB,yBAAN;AAAMC;AAAgCD,kBAAML,iDAAtC;AAA4CO,mBAASN,qDAAT;AAA5C;AAAN,SADA;AAAA;;AAGA;AAAe,2DAAmDD,gEAAwBjB,cAAxB,EAAwB;AAC1FsB,gBAAcL,qDAD4E;AAE1FO;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC,2BAAV;AAAUC;AAChCD,oBAAsBL,iDADU;AAEhCO,qBAAuBN,qDAAvB;AAFgC;AAAV;AAGF,SAN8C,EAM9C,IAN8C,CAAnD;AAMe,OAN9B;AAOA;;;AACA;AACA,uDAA4CO,UAA5C,cAA0DV,OAA1D,IAAkEA,OAAlE;AACA;AACA;;;AACA;AACA;AACAJ,iCAAwBe,0BAAxB,cAAqDC,QAArD;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA,sCAAoCC,yCAApC;AACA,wCAAsCC,oDAAtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA,YAdA,CAeA;;;AACA;AACA;AACA;AACA;AACA;;AACA,4BAA0BD,yCAA1B;AACA;;AACA,4BAA0BA,yCAA1B,GAvBA,CAwBA;AACA;AACA;;AACA,gCAA8BZ,oDAA9B,EAAuC;AACvCc;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACa,aARb;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AAAA;;AACA,yFACA;AAAA;AAAA,cADA,EACA;AACA;AACA;;AACA,sDALA,CAMA;AACA;AACA;;;AACA,qEAAiE,qDAAG;AAAA;AAAA,aAAH,CAAjE,EAAmH,8DAAYC,gBAAZ,CAAnH,EAAmJ,wDAAM;AAAA;AAAA,aAAN,CAAnJ,EAAkM,qDAAG;AAAA;AAAA,aAAH,CAAlM,EAAqMC,SAArM,CAAqM;AACrM,kDADqM,CAErM;AACA;;;AACA,8BAA4B3B,oBAA5B,EAAkDA,GAAlD,EAAkD;AAClD;AACA;;AACA,sDACA4B,+DADA,EACA;AACA;;AACA;AACA;AACA;;AACA;AACS,aAdT;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;;;iBACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;AACA;AACS,aAFT;;AAGA;AACA,mBAAiBC,sDAAjB;AACA;AACA;;AACA,mBAAiBA,6DAAjB;AACA;AACA;AACA;AACA,iBAHA,MAIA;AACA;AACA;;AACA,mBAAiBA,2DAAjB;AACA;AACA;AACA;AACA,iBAHA,MAIA;AACA;AACA;;AACA,mBAAiBA,8DAAjB;AACA;AACA;AACA;AACA,iBAHA,MAIA;AACA;AACA;;AACA,mBAAiBA,6DAAjB;AACA;AACA;AACA;AACA,iBAHA,MAIA;AACA;AACA;;AACA,mBAAiBA,uDAAjB;AACA;AACA;AACA;AACA,iBAHA,MAIA;AACA;AACA;;AACA,mBAAiBA,sDAAjB;AACA;AACA;AACA;AACA,iBAHA,MAIA;AACA;AACA;;AACA;AACA,yCAAyC,uEAAcC,KAAd,EAAc,UAAd,CAAzC,EAAuD;AACvD;AACA;AACA;AACA;AACA,mBAFA,MAGA,eAAyCD,oDAAzC,IAA0CE,WAAeF,oDAAzD,IAA0DE,WAAiBF,uDAAjB,IAAqBE,WAAeF,uDAA9F,EAAkG;AAClG;AACA;AACA,iBAVA,CAWA;AACA;;;AACA;AAjEA;;AAmEA;AACAC;AACA;AACA;;;;eACA;AACA;AACA;AACA;;;;eACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA,iFACA,8BADA;AAEA;;;iBACA;AACA;;AACA;AACA,8CAHA,CAIA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA,4BAAwB9B,iBAAxB,EAA2CA,GAA3C,EAA2C;AAC3C;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;AACA;AACAgC;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA,0CAAsCrB,oDAAtC,GAA+C,qBAA/C,GAA+C,WAA/C;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAsB;;;;;;;;;;;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;;;QATAX;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAY;;;;;AACA;AAAA;;AAAA;;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AACA;;;;;iBACA;AACA;AACA;AACA;;;iBACA;AACA;;AACA;AACA;AACA;AACA;;;;QAlBAZ;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;UACAa,qBACA;AAAA;;AACA;AACA;AACA;AACA;AACA,SAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA,eAJA,CAKA;;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,aA1BA,CA2BA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,eALA,CAMA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAPA,CAQA;AACA;;;AACA;AACA;AACA,eAZA,CAaA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA,oFACA,oGADA;AAEA;;;;;;AAEAA;AAAuE,gDAAuCzB,uDAAgB0B,2DAAhB,CAAvC;AAAsE,OAA7I;;AACAD,oCAA6BzB,iEAAqB;AAAGE;AAAmD,2CAAgCF,uDAAY0B,2DAAZ,CAAhC;AAA4D,SAAlH;AAAkHvB,oCAAlH;AAAkHC;AAAlH,OAArB,CAA7B;;AACAqB;AAAA,gBACA;AAAMpB,gBAAMqB;AAAZ,SADA;AAAA;;AAGA;AAAe,2DAAmD1B,gEAAwByB,qBAAxB,EAAwB;AAC1FpB,gBAAcL,qDAD4E;AAE1FO;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC,kBAAMqB;AAAhB;AAAqC,SAHO,EAGP,IAHO,CAAnD;AAGsD,OAHrE;AAIA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA,SAFA,CAGA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA,iEACA,+EADA;AAEA;AACA;;;AACA;AACA;AACA,uCACAC,qBADA,IAEAA,qBAFA,IAGAA,uBAHA;AAIA;AACA;;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AACA,wDAJA,CAKA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA,SAHA,CAIA;;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA,uCACAC,wBADA,IAEAD,qBAFA,IAGAA,uBAHA;AAIA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;;AACA,+CACAE,yBADA,IAEAnC,uCAFA,IAGAoC,yBAHA;AAIA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA,oCALA,CAMA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA;;;;;eACA;AAAoB;AAAA;eACpB;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACAC;;AACA;AACAA;AACA;AACA;;AACA;AACAC;;AACA;AACAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACS,aATT;;AAUA;AACA;;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AAAA;AAAA;AACS,aAFT;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AAAA;AAAA;AACS,aAFT;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AAAA;AAAA;AACS,aAFT;AAGA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA,qFAA0EC,KAA1E,oCAC8BA,KAD9B,gCAE0BA,KAF1B;;AAGA,4BAAwB7C,kBAAxB,EAA4CA,GAA5C,EAA4C;AAC5C;AACA,8DAAqD6C,KAArD,IAA2D;AAC3DC,oFAA6ED,KAA7E,wCAC0CA,KAD1C,yEAEAE,UAFA;AAGA,eAJA,MAKA,uDAAiEF,KAAjE,IAAuE;AACvEC,2FAAoFD,KAApF,wCAC0CA,KAD1C,yEAEAE,UAFA;AAGA;AACA;;AACA;AACA;AACA;;AACA,oCACAA,2BADA,GACA,2CADA;AAEA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AAEA;AACA;AACA;AACAD,kLAEAE,iBAFA;AAGA,eANA,CAOA;AACA;;;AACA,qEACA,6CADA,EACA;AACAF;AACA;;AACA;AACA;;AACAG;AACA;AACA;;AACAD;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACAA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA,aAHA,CAIA;AACA;;;AACA;;AACA,4BAAwBhD,mBAAxB,EAA6CA,GAA7C,EAA6C;AAC7C,yFACA,0CADA,GAEA,IAFA;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA,aAHA,CAIA;;;AACA;;AACA,8CAA0CA,MAA1C,EAAkDA,GAAlD,EAAkD;AAClD,yFACA,yCADA,GAEA,IAFA;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACAkD;AACAA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACAC;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACAC;AACA,aAFA,MAGA;AACA,yCAAuC,uDAAI,CAAJ,CAAvC,EAA2CzB,SAA3C,CAA2CyB,EAA3C;AACA;AACA;;;;;AAEA;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AAAA;AACA;AACA;;;;;;AAEAA;AAA+D,4CAAmC1C,uDAAeyB,qBAAf,CAAnC,EAA0EzB,uDAAgBA,iDAAhB,CAA1E,EAA0GA,uDAAgBC,qDAAhB,CAA1G;AAAkI,OAAjM;;AACAyC,gCAAyB1C,iEAAqB;AAAGE;AAA+C,uCAA4BF,uDAAWyB,qBAAX,CAA5B,EAA+DzB,uDAAYA,iDAAZ,CAA/D,EAAuFA,uDAAYC,qDAAZ,CAAvF;AAAmH,SAArK;AAAqKE,gCAArK;AAAqKC;AAArK,OAArB,CAAzB;;AACAsC;AAAA,gBACA;AAAMrC;AAAN,SADA,EAEA;AAAMA,gBAAML;AAAZ,SAFA,EAGA;AAAMK,yBAAN;AAAMC;AAAgCD,kBAAML,iDAAtC;AAA4CO,mBAASN,qDAAT;AAA5C;AAAN,SAHA;AAAA;;AAKA;AAAe,2DAAmDD,gEAAwB0C,iBAAxB,EAAwB;AAC1FrC,gBAAcL,qDAD4E;AAE1FO;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC;AAAV,aAAsC;AAAIA,kBAAML;AAAV,WAAtC,EAA+D;AAAIK,2BAAJ;AAAIC;AACzFD,oBAAsBL,iDADmE;AAEzFO,qBAAuBN,qDAAvB;AAFyF;AAAJ,WAA/D;AAGF,SAN8C,EAM9C,IAN8C,CAAnD;AAMe,OAN9B;AAOA;;;UACA0C;AACA;AACA;AACA;AACA;AACA;AACAC,iBALA,EAKA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;;;eACA;AAAoB;AAAA;eACpB;AAAyB,qCAAyB,+EAAqBC,KAArB,CAAzB;AAA8C;AACvE;AACA;AACA;AACA;;;;eACA;AAAwB;AAAA;eACxB;AAA6B,gCAAoB,+EAAqBA,KAArB,CAApB;AAAyC;;;iBACtE;AACA,qCADA,CAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;;;iBACA;AACA;;AACA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;AACA;;;iBACA;AACA;;AACA,2FACA,4BADA,EACA;AACA;AACA;AACA;;;iBACA;AACA,6CAAyC,2FAAzC;AACA;AACA;;;;;;AAEAF;AAAuD,wCAA+B3C,gEAAyBA,qDAAzB,CAA/B,EAA4EA,gEAAwB0C,iBAAxB,CAA5E,EAAwH1C,gEAAyBC,qDAAzB,CAAxH;AAAyJ,OAAhN;;AACA0C,wCAAkC3C,gEAAwB;AAAGK,2BAAH;AAAGyC,6CAAH;AAAGC;AAAqEC,8CAArE;AAAqEC;AAArE,SAAH;AAAuKC,kCAAvK;AAAuKC,mBAAyCnD,kEAAzC;AAAvK,OAAxB,CAAlC;;AACA2C;AAAA,gBACA;AAAMtC,gBAAML;AAAZ,SADA,EAEA;AAAMK;AAAN,SAFA,EAGA;AAAMA,yBAAN;AAAMC;AAAgCD,kBAAML,iDAAtC;AAA4CO,mBAASN,qDAAT;AAA5C;AAAN,SAHA;AAAA;;AAKA0C;AACAK;AAAgB3C,gBAAML,gDAAtB;AAA2BO;AAA3B,UADA;AAEA0C;AAAoB5C,gBAAML,gDAA1B;AAA+BO;AAA/B;AAFA;;AAIA;AAAe,2DAAmDP,gEAAwB2C,aAAxB,EAAwB;AAC1FtC,gBAAcL,oDAD4E;AAE1FO;AACA6C,sCADA;AAEAF;AAFA;AAF0F,UAAxB,EAM7D;AAAiB;AAAU7C,kBAAML;AAAhB,aAAmC;AAAIK;AAAJ,WAAnC,EAA+D;AAAIA,2BAAJ;AAAIC;AACzFD,oBAAsBL,iDADmE;AAEzFO,qBAAuBN,qDAAvB;AAFyF;AAAJ,WAA/D;AAGF,SAT8C,EAS9C;AAAI+C;AACxB3C,kBAAkBL,gDADM;AAExBO;AAFwB,YAAJ;AAGX0C;AACT5C,kBAAkBL,gDADT;AAETO;AAFS;AAHW,SAT8C,CAAnD;AAeC,OAfhB;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;UACA8C;;;;;AACA;AAAA;;AAAA;;AACA;AACA;AACA;;AACA;;AAJA;AAKA;AACA;;;;;eACA;AAAoB;AAAA;eACpB;AACA;;AACA;AACA;AACA,aAFA,MAGA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;;;;QAhCAtB;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,2CAAsC/B,yDAAtC,CAAoD,2BAApD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACAsD;AACA;;AACA,2CACAA,sBADA,GACAC,+BADA;AAEA;AACA;;;AACA;AACA;;AACA;AACAD;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA,iCACA5D,yBADA,GAEAA,sCAFA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACA8D;AACA;AAAA;;AACA;AACA;AACA;AACA;;;;;iBACA;AAAA;;AA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A;AACA;;;AACA;AACAmE,qBAAiBjD,sDAAjB,EAAsBA,0DAAtB,EAA+BA,2DAA/B,EAAyCA,uDAAzC,EAA+CA,wDAA/C;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA,yCAAqC,wFAA+B;AACpEkD,qBADoE;AAEpEC;AAFoE,OAA/B,CAArC;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;UACAC;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA,+BAA6BC,kDAA7B,CAA4C,IAA5C;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,uBADA,CAEA;AACA;;;AACA;AAAA;AAAA;AACA;AACA;;AACA;;AACA,wCAAqC,wEAAepD,KAAf,CAArC;AACA,WATA;AAUA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aANA,CAOA;AACA;;;AACA;;AACA,wCAAqC,wEAAeA,KAAf,CAArC;AACA,WAXA;AAYA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,aANA,CAOA;AACA;;;AACA;;AACA;;AACA,wCAAqC,wEAAeA,KAAf,CAArC;AACA,WAZA;;AAaA,0DAAsDqD,wCAAtD,GAAsDC,OAAtD,EA7DA,CA8DA;;AACA,sDAAoD,uDAAI,CAAJ,CAApD;AACA,4DAA0D,wEAA1D,EAhEA,CAiEA;AACA;;AACA;AACA;AACA,WArEA,CAsEA;;;AACAC;AACAC;AACAA;AACAA;AACS,WAJT;AAKA;AACA;;;;;eACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;AACAA;AACAA;AACAA;AACA;;;;;;AAEAL;AAAyE,iDAAwCtE,uDAAgB0B,2DAAhB,CAAxC,EAA0E1B,uDAAgBA,iDAAhB,CAA1E,EAA0GA,uDAAgBC,qDAAhB,CAA1G,EAAqID,uDAAe4E,gCAAf,EAAe,CAAf,CAArI;AAAoJ,OAA7N;;AACAN,qCAA8BtE,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uEAAatG,OAAb,CAA9B;;AACA;;AACA;AACAuG;;AACA;;AACA;;AACA;AACA;AACA;;;iBACA;AAAA;;AACA,gCAA8B,uEAAavG,OAAb,CAA9B;;AACA,mEAFA,CAGA;AACA;AACA;;;AACA;AACA,0DACAwG,OADA,CACA;AAAA;AAAA;AAAA;;AAAA;AAAA,eADA;AAEA,aAHA,MAIA;AACA,sCADA,CAEA;;;AACA;AACAN;AACA;AACA;AACA;;;iBACA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;;;iBACA;AACA;AACAlG;AACA,aAFA,MAGA;AACAA;AACA;AACA;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA,eAFA,MAGA;AACA;AACA;AACA,aAVA,CAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA,eACA,gJADA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AAAA;;AACA;AACA;AACA,4FAFA,CAGA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AACAsF;AACA;AACA;AAAA;AAAA;AACA;AACS,aAbT;AAcA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,mCAAiC,wEAAe7D,KAAf,CAAjC;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA,oGACAzB,qCADA,EACA;AACA;AACA;;AACA;;AACA;AACA;;;iBACA;AACA;AAAA;AAAA;AACA;;;iBACA;AAAA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACAsG;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AACAC;AACAD;AAAA;AAAA;AACA,eAHA,MAIA;AACAD;AACAE;AACAD;AAAA;AAAA;AACA;;AACA;AACAE;AACAC,mFADA;AAEAH,sCAFA;AAGAI;AAHA;AAKA;AACS,aAxBT;AAyBA;;;iBACA,mBACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;;iBACA;AAAA;;AACA;AACAP;AACA;AACA;;AACA;AAAgD;AAChD;AAAA;AAAA;;AACAC;AACAC;AAAA;AAAA;AAAA;AAAA;AACA,eAJA,MAKA;AAA6C;AAC7C;;AACAA;AAAA;AAAA;AACA,eAHA,MAIA;AAAmB;AACnBD;AACAC;AAAA;AAAA;AACA;;AACA;AACAE;AACAC,mFADA;AAEAH,sCAFA;AAGAI;AAHA;AAKA;AACS,aAvBT;AAwBA;;;iBACA;AAAA,uDACA,eADA;AAAA;;AAAA;AACA;AAAA;AACAL;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACAO;AACA;AACA;;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACAL;AACAF;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA,aAFA,MAGA;AACA,yDADA,CAEA;AACA;AACA;AACA;;AACA;AACAA;AACA,eAFA,MAGA;AACAE;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACAA;AACA;;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;UACAM;AACA;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA,6BAA2BhI,yCAA3B;;AACA;AACA;AACAiI;AAAA;AAAA;AACA,aAFA,MAGA;AACA;AACA,aANA,CAOA;;;AACA;AACA;AACA;AACA;;;;;eACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AAAA;AAAAC;AAAA;;AACA;;AACAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AAAA;AAAAA;AAAA;;AACA;;AACAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;AACAC,4BADA;AAEAC,2CAFA;AAGAC;AAHA;AAKA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;;;;;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AAAA,wDACA,eADA;AAAA;;AAAA;AACA;AAAA;AACAC;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;;AACA;AACA;AACA;AACa,eAFb;AAGA,aAJA;AAKA;;;iBACA;AACA;AACA;;;;;;AAEAD;AAAiF;AAAA,OAAjF;;AACAA,yCAAkCE,iEAAqB;AAAGlJ;AAAwD;AAAyC,SAApG;AAAoGC,yCAApG;AAAoGC;AAApG,OAArB,CAAlC;;AACA;AAAe,2DAAmDgJ,gEAAwBF,0BAAxB,EAAwB;AAC1F7I,gBAAc+I,qDAD4E;AAE1F7I;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAY,SAHgC,EAGhC,IAHgC,CAAnD;AAG6B,OAH5C;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA,yCAAoCgJ,yDAApC,CAAkD,eAAlD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAAyB;;AACzB,2BAAsB;;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAiB;;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAkB;;AAClB,8BAAyB;;AACzB,4BAAuB;;AACvB;AACA;AACA;AACA;AACA,4BAAuB;;AACvB,yBAAoB;;AACpB;AACA,uBAAkB;;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAAC;AAAA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA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;;AACA;AACA,kEALA,CAMA;AACA;;AACAC,gCAA8B,4EAAmB,kCAAnB,CAA9B;AACAA,+BAA6B,4EAAmB,iCAAnB,CAA7B;AACAA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC;AACAA;AACAC,8DAVA,CAWA;AACA;AACA;AACA;AACA;;AACA;AACAD;AACA;;AACArE;;AACA;AACAqE;AACAE;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;;;UACAC;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AACA,WALA;AAMA;AACA;;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA,iBAFA,MAGA;AACA;AACA;AACa,eARb;AASA,aAXA,MAYA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;UACAC;;;;;;;;AACA;AACA;AACA;;;;iBACA;AACA;;;;iBACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACK,SANL;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACK,SANL;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;AACA,qDADA,CAEA;;;AACA;AACA;;AACA,8CAA4C,wCAA5C;AAAA,sBAA4BC,KAA5B,yBAA4BA,KAA5B;AAAA,sBAA4BC,MAA5B,yBAA4BA,MAA5B,CAFA,CAGA;AACA;;;AACA;AAA2CD,gCAA3C;AAA2CC,kCAA3C;AAA2CC,kCAA3C;AAA2CC,gCAA3C;AAA2CZ,0BAA3C;AAA2CC;AAA3C;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AACA;AACa,eAdb;AAeA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAY,yBACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AAAA;;AACA;AACA;;AAEAA;AAAyE,iDAAwC9B,uDAAgB+B,oEAAhB,CAAxC,EAAkF/B,uDAAgB+B,iEAAhB,CAAlF,EAAyH/B,uDAAgBA,iDAAhB,CAAzH,EAAyJA,uDAAgBgC,qDAAhB,CAAzJ;AAAiL,OAA1P;;AACAF,qCAA8B9B,iEAAqB;AAAGlJ;AAAoD,4CAAiCkJ,uDAAY+B,oEAAZ,CAAjC,EAAmE/B,uDAAY+B,iEAAZ,CAAnE,EAAkG/B,uDAAYA,iDAAZ,CAAlG,EAA0HA,uDAAYgC,qDAAZ,CAA1H;AAAwJ,SAA/M;AAA+MjL,qCAA/M;AAA+MC;AAA/M,OAArB,CAA9B;;AACA8K;AAAA,gBACA;AAAM7K,gBAAM8K;AAAZ,SADA,EAEA;AAAM9K,gBAAM8K;AAAZ,SAFA,EAGA;AAAM9K,gBAAM+I;AAAZ,SAHA,EAIA;AAAM/I,yBAAN;AAAMC;AAAgCD,kBAAM+I,iDAAtC;AAA4C7I,mBAAS6K,qDAAT;AAA5C;AAAN,SAJA;AAAA;;AAMA;AAAe,2DAAmDhC,gEAAwB8B,sBAAxB,EAAwB;AAC1F7K,gBAAc+I,qDAD4E;AAE1F7I;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC,kBAAM8K;AAAhB,aAAyC;AAAI9K,kBAAM8K;AAAV,WAAzC,EAAyE;AAAI9K,kBAAM+I;AAAV,WAAzE,EAAkG;AAAI/I,2BAAJ;AAAIC;AAC5HD,oBAAsB+I,iDADsG;AAE5H7I,qBAAuB6K,qDAAvB;AAF4H;AAAJ,WAAlG;AAGF,SAN8C,EAM9C,IAN8C,CAAnD;AAMe,OAN9B;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;UACAC,iBACA;AAAA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;UACAC,0BACA;AACA;AACAC,aAFA;AAGA;AACAC,aAJA;AAKA;AACAC,gBANA,EAMA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAC;;;AAEA;;;UACAC,kCACA;AACA;AACAC,oBAFA;AAGA;AACAC,8BAJA,EAIA;AAAA;;AACA;AACA;AACA;;AAEAF;AAAA,gBACA;AAAMtL;AAAN,SADA,EAEA;AAAMA,oCAAN;AAAMC;AAA0CD,kBAAM+I;AAAhD;AAAN,SAFA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA,2DAAkD0C,QAAlD,gBAA+DjJ,KAA/D;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA,2DAAkDiJ,QAA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C7I,mBAAS6K,qDAAT;AAA5C;AAAN,SADA,EAEA;AAAM/K,gBAAMgM;AAAZ,SAFA;AAAA;;AAIA;AAAe,2DAAmDjD,gEAAwBkD,iBAAxB,EAAwB;AAC1FjM,gBAAc+I,qDAD4E;AAE1F7I;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC,2BAAV;AAAUC;AAChCD,oBAAsB+I,iDADU;AAEhC7I,qBAAuB6K,qDAAvB;AAFgC;AAAV,aAGN;AAAI/K,kBAAMgM;AAAV,WAHM;AAGyB,SANmB,EAMnB,IANmB,CAAnD;AAM0C,OANzD;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACAK;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAkCC,yCAAlC;AACA,kCAAgCA,yCAAhC;AACA,kCAAgCA,yCAAhC;AACA,kCAAgCC,oDAAhC;;AACA;AAAA;AAAA;AACA;;;AACA,oCAAkCD,yCAAlC;AACA;;AACA,2CAAyCA,yCAAzC;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;;;;eACA;AACA;AACA;AACA;;;;eACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;eACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA,iEADA,CAEA;;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;;AACA;;AACA;AACA;AACA,aAdA,CAeA;AACA;AACA;;;AACA,kCACAvG,IADA,CACkB,sDAAI,CAAJ,CADlB,EAEApF,SAFA,CAEA;AACA;AACA;AACA;AACA;AACS,aAPT,EAlBA,CA0BA;;;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA,aAjCA,CAkCA;;;AACA,qCAnCA,CAoCA;;;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA,kCAJA,CAKA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,+DAfA,CAgBA;;;AACA,qCAjBA,CAkBA;;;AACA,kDAnBA,CAoBA;AACA;;;AACA;;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;AACA;;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA6L;AACA;AACA;AACA;AACA;;;;iBACA;AACA,2DAAqD,YAArD,GAAqDC,UAArD;;AACA;AACA;AACA;;;;iBACA;AACA,2DAAqD,YAArD,GAAqD;AAAmBC;AAAnB,aAArD;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;;AACA;AACAF;AACAA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACAG,0BAAsB,4EAAmB,kBAAnB,CAAtB;AACAA,2BAAuB,4EAAmB,mBAAnB,CAAvB;AACAA,6BAAyB,4EAAmB,qBAAnB,CAAzB;AACAA,8BAA0B,4EAAmB,sBAAnB,CAA1B;AACAA,6BAAyB,4EAAmB,qBAAnB,CAAzB;AACAA,8BAA0B,4EAAmB,sBAAnB,CAA1B;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;;AACA;;AACA;AACA;AACA,aANA,CAOA;AACA;;;AACA,qFATA,CAUA;AACA;;;AACA,wFAZA,CAaA;;;AACA;AACA;AACAC;AACA;AACA;AACA;AACiB,iBAJjB;AAKa,eANb;AAOA,aARA,MASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACAC;AACAA;;AACA;AACAA;AACA;AACA,eARA,CASA;AACA;AACA;;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACAlI;AACA,aAnBA;;AAoBAkI;;AACA;AACAA;AACS,aAFT,EA3BA,CA8BA;AACA;;;AACAA,0DAhCA,CAiCA;AACA;AACA;;AACAC;AAAA;AAAA;AACA;AACA;;;;iBACA;AACA;AACQ,gFAAWC,UAAX,EAAWlH,OAAX,CAAW;AACnB;AACA;AACA;AACAmH;AACA;AACS,aAND;AAOR;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DACAjH,IADA,CACsB,2DAAU,6CAAK,oBAAL,EAAK,oBAAL,CAAV,CADtB,EAEApF,SAFA,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACAyI;AACA;AACa,eAfb;AAgBS,aApBT;AAqBA;AACA;;;;iBACA;AACA;;AACA;AACA6D;;AACA;AACAA;AACA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAAsCzC,oBAAtC;AAAsCC;AAAtC;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA,sCAAoC4B,yCAApC;AACA;;AACA,qCAAmCC,oDAAnC;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;;;;eACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA,wEACA,6CADA,GACA;AACA;AACA;;AACA;;AACAT;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACS,aANT;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA,aAJA,CAKA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AACA;;AACA;;AACA,2CAdA,CAeA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA,kDAvBA,CAwBA;;AACA,kCAzBA,CA0BA;;AACA,yBA3BA,CA4BA;AACA;;AA7BA,wDA8BA,wBA9BA;AAAA;;AAAA;AA8BA;AAAA;;AACA;AACA,wEAFA,CAGA;AACA;AACA;;;AACA,wFANA,CAOA;;;AACA,mGARA,CASA;;;AACA;AACA;;AACA;;AACA;AACA,iBAdA,CAeA;AACA;;;AACA;AACA;AACA;AACAqB;AACAC,iCADA;AAEAC,uCAFA;AAGAC,4CAHA;AAIAC;AAJA;AAMA;AACA,iBA3BA,CA4BA;AACA;AACA;;;AACA;AACAC;AAA6BC,0CAA7B;AAA6BC,8CAA7B;AAA6BC,4CAA7B;AAA6BP,iCAA7B;AAA6BE;AAA7B;AACA;AACA,eAhEA,CAiEA;AACA;;AAlEA;AAAA;AAAA;AAAA;AAAA;;AAmEA;AACA;AACA;;AAFA,0DAGAH,YAHA;AAAA;;AAAA;AAGA;AAAA;AACA;;AACA;AACAS;AACAC;AACA;AACA;AATA;AAAA;AAAA;AAAA;AAAA;;AAUA;;AACA;;AACA;AACA,aAhFA,CAiFA;AACA;;;AACA;AACA;AACA;;AACA;;AACA;AACA,aAxFA,CAyFA;AACA;;;AACA;AACA;;;iBACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA,aAHA,CAIA;AACA;;;AACA;AACAC;AACA9D,uBADA;AAEAC,wBAFA;AAGAW,yBAHA;AAIAD,0BAJA;AAKAD,0BALA;AAMAD,yBANA;AAOAsD,8BAPA;AAQAC;AARA;AAUA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA,iDADA,CAEA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACAC;AACA,aAJA,MAKA;AACA;AACA;AACAA;AACA;;AACA;;AACA;AACAC;AACA,aAFA,MAGA;AACAA;AACA;;AACA;AAAiBD,kBAAjB;AAAiBC;AAAjB;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACAC;AACA,aAFA,MAGA;AACAA;AACA,aAFA,MAGA;AACAA;AACA;;AACA;;AACA;AACAC;AACA,aAFA,MAGA;AACAA;AACA,aAnBA,CAoBA;;;AACA;AACAH,8CADA;AAEAC;AAFA;AAIA;AACA;;;;iBACA;AACA;AACA;AACA;AACA,gBAAcD,CAAd,GAAqBI,KAArB,CAAcJ,CAAd;AAAA,gBAAcC,CAAd,GAAqBG,KAArB,CAAcH,CAAd;;AACA;;AACA,yDANA,CAOA;;;AACA;AACAD;AACA;;AACA;AACAC;AACA,aAbA,CAcA;;;AACA;AACA;AACA;AACA,sEAlBA,CAmBA;;AACA;;AACA;;AACA;AACA;AACAI,sCADA;AAEAC,wFAFA;AAGAC,wEAHA;AAIAC;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA,gEACAC,iDADA;AAEA,oEACAC,8CADA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACAV,uDADA;AAEAC;AAFA;AAIA,aATA,CAUA;AACA;;;AACA;AACA,8CAbA,CAcA;AACA;;AACA;AACA;AACA;AACA,0FAnBA,CAoBA;;AACA;AACA,0BAtBA,CAuBA;AACA;AACA;;AACA;AACAU;AACA,aAFA,MAGA;AACAA;AACA;;AACA;AACAC;AACA,aAFA,MAGA;AACAA;AACA;;AACA;AAAqCZ,sBAArC;AAAqCC;AAArC;AACA;AACAD,gCADA;AAEAC;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACA;;AACA;AACA;AACA,aANA,CAOA;;;AACA,0CARA,CASA;AACA;AACA;;AACA;AACA;;AACA;;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;AACA;;AACA;AACAY;AACA,aAFA,MAGA;AACAA;AACA,aAFA,MAGA;AACAA;AACA;;AACA,4BAAwB9P,mBAAxB,EAA6CA,GAA7C,EAA6C;AAC7C+P,4DAAmDD,OAAnD,cAA8DE,OAA9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACA;;AACA;AACA;AACAhF;AACAU;AACA,aAJA,MAKA;AACA;AACA;AACA;AACAC;AACAD;AACA,aANA,MAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA;AACAV;;AACA;AACAA;AACA;AACA,aA5BA,CA6BA;;;AACA,0FACAoD,oCADA,CA9BA,CAgCA;;AACA,uFACAA,sCADA;AAEA;;AACA;AACAxC;AACAH;AACA,aAHA,MAIA;AACAR;AACAQ;AACA,aAHA,MAIA;AACA;AACA;AACA;AACA;AACA;;AACA;AACAA;AACAR;;AACA;AACAA;AACA;AACA;;AACA;AAAiBD,sBAAjB;AAAiBC,wBAAjB;AAAiBU,4BAAjB;AAAiBC,0BAAjB;AAAiBH,0BAAjB;AAAiBC;AAAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA,mFADA,CAEA;AACA;;;AACA;AACA6C;AACAA;AACA;;AACA;;AACA;AACA0B;AACAA;AACAA;AACA,aAJA,MAKA;AACA;;AACA;;AACAA,8BAA4B,4EAAmB1B,sBAAnB,CAA5B;AACA0B,2BAAyB,4EAAmB1B,mBAAnB,CAAzB;AACA0B,8BAA4B,4EAAmB1B,sBAAnB,CAA5B;AACA0B,6BAA2B,4EAAmB1B,qBAAnB,CAA3B;AACA0B,4BAA0B,4EAAmB1B,oBAAnB,CAA1B;AACA0B,6BAA2B,4EAAmB1B,qBAAnB,CAA3B,CARA,CASA;;AACA;AACA0B;AACA,eAFA,MAGA;AACAA;AACA;;AACA;AACAA;AACA,eAFA,MAGA;AACAA;AACA;;AACA;AACAA,mCAAmC,4EAAmBC,SAAnB,CAAnC;AACA;;AACA;AACAD,kCAAkC,4EAAmBE,QAAnB,CAAlC;AACA;AACA;;AACA;AACArB;AACA;AACA;;;;iBACA;AACAA;AACA9D,sBADA;AAEAC,uBAFA;AAGAW,wBAHA;AAIAD,yBAJA;AAKAD,wBALA;AAMAD,uBANA;AAOAsD,4BAPA;AAQAC;AARA;AAUA;AACA;;;;iBACA;AACAF;AACA9D,qBADA;AAEAC,sBAFA;AAGAU,wBAHA;AAIAC,uBAJA;AAKAwC,0BALA;AAMAgC;AANA;AAQA;AACA;;;;iBACA;AACA;;AACA;;AACA;;AACA;;AACA;AACA;;AACAtB;AACAA;AACA,aAJA,MAKA;AACAmB;AACA,aAZA,CAaA;AACA;AACA;AACA;AACA;;;AACA;;AACA;;AACA;;AACA;AACAI,sDAA6CnE,OAA7C;AACA;;AACA;AACAmE,sDAA6ClE,OAA7C;AACA;;AACA8D,sDA3BA,CA4BA;AACA;AACA;AACA;AACA;;AACA;AACA;AACAA,mCAAmC,4EAAmBxL,gBAAnB,CAAnC;AACA,eAFA,MAGA;AACAwL;AACA;AACA;;AACA;AACA;AACAA,kCAAkC,4EAAmBxL,eAAnB,CAAlC;AACA,eAFA,MAGA;AACAwL;AACA;AACA;;AACAnB;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AAAuB9D,qBAAvB;AAAuBW;AAAvB;;AACA;;AACA;AACA+C;AACA;;AACA,iHARA,CASA;AACA;AACA;AACA;;;AACAA,oDAbA,CAcA;AACA;;AACA;AACA;AACA;AACA;AACAuB,wCAA+BK,4DAA/B;AACA,aALA,MAMA;AACAL,2BAAyB,4EAAmBvB,cAAnB,CAAzB;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AAAuBzD,sBAAvB;AAAuBW;AAAvB;;AACA;;AACA;AACA8C;AACA,aAPA,CAQA;AACA;AACA;AACA;;;AACA;;AACA;AACA6B;AACA,aAFA,MAGA;AACAA;AACA,aAlBA,CAmBA;AACA;;;AACA;AACA;AACAN,uCAA8BO,0DAA9B;AACA,aAHA,MAIA;AACAP,4BAA0B,4EAAmBvB,cAAnB,CAA1B;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA,mEAHA,CAIA;AACA;AACA;;;AACA;AACA;AACS,aAFT;;AAGA;AACA+B,+FADA;AAEAC,oGAFA;AAGAC,iGAHA;AAIAC;AAJA;AAMA;AACA;;;;iBACA;AAAA;AAAAC;AAAA;;AACA;AACA;AACS,aAFT,EAESC,MAFT;AAGA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA9F,4DADA;AAEAC,8DAFA;AAGAW,uEAHA;AAIAD,wEAJA;AAKAF,qDALA;AAMAC;AANA;AAQA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA,eAHA,CAIA;AACA;;;AACA;AACAqF;;AACAC;;AACAD;;AACAC;AACa,eALb;AAMA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACY,kFAAWjD,UAAX,EAAWlH,OAAX,CAAW;AACvB;AACA;;AACA;AACA;AACa,eALD;AAMZ;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;AACa,eAFb;;AAGA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA,kCAA8BkD,qDAA9B,EAAwC;AACxC;AACA,aAJA,CAKA;;;AACA;AACA;AACA;;AACA;AACA,4CAVA,CAWA;;AACA;AACAiB,2BADA;AAEAW,uCAFA;AAGAV,4BAHA;AAIAW,qCAJA;AAKAF,4BALA;AAMAD;AANA;AAQA;;;;;AAEA;;;AACA;AACA;AACA;AACAwF;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACAjG,yCADA;AAEAY,6CAFA;AAGAD,+CAHA;AAIAV,2CAJA;AAKAQ,6CALA;AAMAC;AANA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAwF;AACA;AAAA;;AACA;AACA,wCAFA,CAGA;AACA;AACA;AACA;;AACA,4IACAC,sBADA,CACA,KADA,EAEAC,QAFA,CAEA,KAFA,EAGAC,kBAHA,CAGA,CAHA;AAIA;AACA;AACA;AACA;;;;;eACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACA;AACAvE;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA,aAFA,MAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;UACAwE;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACAxE;AAAoCrB;AAApC;AACA;;AACA;AACAqB;AAAoCpB;AAApC;AACA;;AACAoB;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AAA0CrB;AAA1C;AACA,aAFA,MAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AAA0CC;AAA1C;AACA,aAFA,MAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;;AACA,gBAAgBD,KAAhB,GAAqDhH,MAArD,CAAgBgH,KAAhB;AAAA,gBAAgBC,MAAhB,GAAqDjH,MAArD,CAAgBiH,MAAhB;AAAA,gBAAgByE,QAAhB,GAAqD1L,MAArD,CAAgB0L,QAAhB;AAAA,gBAAgBD,SAAhB,GAAqDzL,MAArD,CAAgByL,SAAhB;AACA,wFACA,wDADA;AAEA,wFACA,2DADA;AAEAD;AACAA;AACAA;AACAA;AACAA;;AACA;AACAsB;AACA,aAFA,MAGA;AACAA;AACA,aAFA,MAGA;AACA;AACA;AACA;AACA;AACA;AACAA;AACA,eAFA,MAGA;AACAA;AACA;AACA,aAXA,MAYA;AACAA;AACA;;AACAA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACAC;AACAD,uFACAtB,mFADA;AAEA;AACA;AACA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;UACAwB;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;;;;;AAEAA;AAA2E,kDAAyC1H,uDAAgB+B,iEAAhB,CAAzC,EAAgF/B,uDAAgBgC,qDAAhB,CAAhF,EAA2GhC,uDAAgBiD,2DAAhB,CAA3G,EAA6IjD,uDAAekD,iBAAf,CAA7I;AAA4J,OAAvO;;AACAwE,sCAA+B1H,iEAAqB;AAAGlJ;AAAqD,6CAAkCkJ,uDAAY+B,iEAAZ,CAAlC,EAAiE/B,uDAAYgC,qDAAZ,CAAjE,EAA6FhC,uDAAYiD,2DAAZ,CAA7F,EAAuHjD,uDAAWkD,iBAAX,CAAvH;AAAwJ,SA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AAuCA,uDAAvC;AACA,qCAAmCyI,gEAAnC,CAAiDS,WAAjD,EAAiDhK,gBAAjD;AACA;AACA;AACA;AACA;;;;;eACA;AAAoB;AAAA;eACpB;AACA;;AACA;AACA;AACA;AACA;AACA;;;;eACA;AAAoB;AAAA;eACpB;AACA;;AACA;AACA;AACA;AACA;AACA;;;;eACA;AAAwB;AAAA;eACxB;AAA6B,gCAAoB,8EAAqBzF,KAArB,CAApB;AAAyC;AACtE;;;;eACA;AAAyB;AAAA;eACzB;AAA8B,iCAAqB,8EAAqBA,KAArB,CAArB;AAA0C;AACxE;;;;eACA;AAA+B;AAAA;eAC/B;AACA,uCAAmC,8EAAqBA,KAArB,CAAnC;AACA;AACA;;;;eACA;AAA0B;AAAA;eAC1B;AAA+B,kCAAsB,8EAAqBA,KAArB,CAAtB;AAA2C;AAC1E;;;;eACA;AAAiB;AAAA;eACjB;AAAsB,yBAAa,8EAAqBA,KAArB,CAAb;AAAkC;AACxD;;;;eACA;AACA;AACA;AACA;;;;eACA;AACA;AACA;;;iBACA;AACA;;AACA;;AACA;;AACA;;AACA;AACA;AACA;AACA;;;iBACA;AACA;AACA;;AACA;AACAiI,iCADA;AAEAkE,uCAFA;AAGAjE,mCAHA;AAIAgE;AAJA;;AAMA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA5C;AACA;;AACA,oCAAkCoG,0DAAlC,IAAwC,qBAAxC,IAAwC,CAA2B,wEAAcpR,KAAd,CAAnE,EAAiF;AACjFA;;AACA;AACA;AACS,aANT;;AAOA;AACA;AACS,aAFT;AAGA;AACA;;;;iBACA;AACA,oDACA,uDADA;;AAEA;AACA4L,kCADA;AAEAyF,gDAFA;AAGAlF,iDAHA;AAIAmF;AAJA;;AAMA;AACAf;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AAAA;AACAK,gD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,CAAnC;;AACAgU;AAAA,gBACA;AAAM/T,yBAAN;AAAMC;AAAgCD,kBAAM+I,iDAAtC;AAA4C7I,mBAAS6K,qDAAT;AAA5C;AAAN,SADA,EAEA;AAAM/K,gBAAMgM;AAAZ,SAFA;AAAA;;AAIA;AAAe,2DAAmDjD,gEAAwBgL,2BAAxB,EAAwB;AAC1F/T,gBAAc+I,qDAD4E;AAE1F7I;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC,2BAAV;AAAUC;AAChCD,oBAAsB+I,iDADU;AAEhC7I,qBAAuB6K,qDAAvB;AAFgC;AAAV,aAGN;AAAI/K,kBAAMgM;AAAV,WAHM;AAGyB,SANmB,EAMnB,IANmB,CAAnD;AAM0C,OANzD;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjpGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA,sGACA,wCADA;AAEA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACAiI;;;;;;;;AACA;AACA;AACA;AACA;AACAC;AACA;;AACA;AACAC;AACA;AACA;;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA1M;AACA,aAHA,MAIA;AACA2M;AACA;AACA;AACA;;;;eACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;;;;AAEA;AACA;AACA;;;UACAC;;;;;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;;;QAPAJ;AASA;AACA;AACA;;;UACAK;;;;;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AAJA;AAKA;;;;eACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AACA;AACA;;;iBACA;AACA;AACA;AACA;;;;QAtBAL;AAwBA;AACA;AACA;AACA;AACA;;;UACAM;;;;;AACA;AAAA;;AAAA;;AACA;AACA,+CAA0C5U,qDAA1C,GAAoDN,qBAApD,GAAoDA,OAApD;AAFA;AAGA;;;QAJA4U;AAMA;AACA;AACA;AACA;;;UACAO;AACA;AAAA;;AACA;AACA,mCAFA,CAGA;;AACA;AACA;AACA;;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACAC;AACA;;AACA;AACAN;AACA;;AACA;AACAO;AACA;AACA;;AACA;AACA;AACA;AACA,aAHA,MAIA;AACA;AACA,uDAFA,CAGA;AACA,aAJA,MAKA;AACA;AACA;AACA;;AACA;AACAC;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;;iBACA;AACA;AACA;;AACA;AACA;AACA;;;;;AAEA;AACA;AACA;AACA;;;UACAC;;;;;;;;;;;;QAAAJ;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACAK;;;;;AACA;AACA;AACAC,qBAFA,EAEAjE,yBAFA,EAEAkE,OAFA,EAEAC,gBAFA;AAGA;AACA;AACA;AACA;AACAzS,iBAPA,EAOA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA,aATA,CAUA;AACA;;;AACA;;AACAlD;;AACA;;AACA;;AACA;AACA;AACA;AACA4V;AACA;AACa,aALb;AAMA,WAtBA;;AAuBA;AAnCA;AAoCA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AAAA;;AACA;AACA;AACA,6BAHA,CAIA;AACA;AACA;AACA;;AACA;AACAC;AACA;AAAA;AAAA;AACA,aAHA,MAIA;AACAA;;AACA;;AACA;AACA;;AACAA;AACa,eAHb;AAIA,aAnBA,CAoBA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA,+FAFA,CAGA;AACA;AACA;AACA;;AACAC;AAAA;AAAA,eAPA,CAQA;AACA;AACA;;AACAA;AACA;AACA;;AACA;AACAC;AACA;AACS,aALT;AAMA,0CAlBA,CAmBA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;;;QAnHAZ;AAqHA;AACA;AACA;AACA;;;UACAa;;;;;;;;;;;;QAAAR;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;UACAS;;;;;AACA;AAAA;;AAAA,qCACArD,WADA,EACAhK,gBADA;AAEA;;;QAHAqM;;AAKAgB;AAAiD,qCAA4B3V,gEAAyBA,sDAAzB,CAA5B,EAA0EA,gEAAyBA,2DAAzB,CAA1E;AAA0H,OAA3K;;AACA2V,qCAA+B3V,gEAAwB;AAAGK,wBAAH;AAAGyC,0CAAH;AAAGI,+BAAH;AAAGC,mBAAyFnD,wEAAzF;AAAH,OAAxB,CAA/B;;AACA2V;AAAA,gBACA;AAAMtV,gBAAML;AAAZ,SADA,EAEA;AAAMK,gBAAML;AAAZ,SAFA;AAAA;;AAIA;AAAe,2DAAmDA,gEAAwB2V,UAAxB,EAAwB;AAC1FtV,gBAAcL,oDAD4E;AAE1FO;AACA6C,mCADA;AAEAF;AAFA;AAF0F,UAAxB,EAM7D;AAAiB;AAAU7C,kBAAML;AAAhB,aAAoC;AAAIK,kBAAML;AAAV,WAApC;AAA2E,SAN/B,EAM+B,IAN/B,CAAnD;AAM4F,OAN3G;AAOA;AACA;AACA;AACA;;;UACA4V;;;;;;;;;;;;QAAAD;;AAEAC;AAA2D;AAA0C;AAAqD,kGAAwF5V,oEAA4B4V,wBAA5B,CAAxF,GAAoHC,6BAApH;AAAoH,SAAzK;AAAwO,OAA7U;;AACAD,mDAA6C5V,gEAAwB;AAAGK,sCAAH;AAAGyC,+DAAH;AAAGI,+BAAH;AAAGC,mBAA4HnD,iEAAyB;AAC7N2H,6BAD6N;AAE7NC;AAF6N,UAAzB,CAA5H,EAGvD5H,wEAHuD;AAAH,OAAxB,CAA7C;;AAIA;AAAe,2DAAmDA,gEAAwB4V,wBAAxB,EAAwB;AAC1FvV,gBAAcL,oDAD4E;AAE1FO;AACA6C,8CADA;AAEAF,iCAFA;AAGA2E;AACAF,iCADA;AAEAC;AAFA;AAHA;AAF0F,UAAxB,EAU7D,IAV6D,EAU7D,IAV6D,CAAnD;AAUO,OAVtB;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAkO;;;;;AACA;AACA;AACA;AACA;AACA;AACAlT,iBALA,EAKA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA,iCAA4B5C,uDAA5B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA,aATA,CAUA;AACA;;;AACA;;AACA+V;AACArW;;AACA;;AACA;;AACA;AACA;AACA4V;AACA;AACa,aAJb;AAKA,WAtBA;;AAuBA;AArCA;AAsCA;AACA;;;;;eACA;AACA;AACA;eACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;;eACA;AACA;AACA;;;iBACA;AACA;AACA;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACAS,yCADA,CAEA;AACA;;AACA,qEACAA,uBADA,GAEA,sBAFA;AAGA;AACA;AACA,gJATA,CAUA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACAA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA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C;AACA;;AACA,oEAAkE,uEAAlE;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iBACA;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;;AACA;AAA2BC,wCAA3B;AAA2BC;AAA3B;;AACA;;AACA;;AACA,oEARA,CASA;;;AACA,2FAVA,CAWA;;AACA;AACA;AACA;AACA,2GAHA,CAIA;AACA;;AACA;AACAC;AACAC;AACAC;AACA;;AACAA;AACA;;AACA;;AACA;AACA;AACAA;AACAA;AACA,aAJA,MAKA;AACA;;AACA;AACA;;AACA;AACAA;AACAA;AACA;AACA;AACA;;AACA;;AACA;;AACA;AACA;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;;eACA;AAAqB;AAAA;eACrB;AAA0B,6BAAiB,6EAAoB9T,KAApB,CAAjB;AAAqC;AAC/D;AACA;AACA;AACA;;;;eACA;AAAwB;AAAA;eACxB;AAA6B,gCAAoB,6EAAoBA,KAApB,CAApB;AAAwC;AACrE;AACA;AACA;;;;eACA;AAAwB;AAAA;eACxB;AAA6B,gCAAoB,6EAAoBA,KAApB,CAApB;AAAwC;;;iBACrE;AACA;AACA;;;;;;AAEA8T;AAAiF;AAAA,OAAjF;;AACAA,qDAA+C3W,gEAAwB;AAAGK,wCAAH;AAAGyC,oEAAH;AAAGC;AAAyG6T,8BAAzG;AAAyGC,oCAAzG;AAAyGC;AAAzG,SA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0D;AAAIrB,2BAAJ;AAAIC;AACpFD,oBAAsBL;AAD8D,eAEvE;AACbK,oBAAsBL,iDADT;AAEbO,qBAAuB6W,sDAAvB;AAFa,aAFuE;AAAJ,WAA1D;AAKF,SAR8C,EAQ9C,IAR8C,CAAnD;AAQe,OAR9B;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;UACAC;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA,gCAA8BhB,yCAA9B;AACA,sCAAoC1J,4CAApC,CAA8C;AAAA;AAAA,qBAAmD,iDAAS,gCAAT,EAAS,QAAT,EAASvG,IAAT,CAAwD,4DAAS,kBAAT,CAAxD,EACjGpF,SADiG,CACjG0I,QADiG,CAAnD;AAAA;AAAA,WAA9C;AAEA;;;;iBACA;AACA;AACA;;;iBACA;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA,4DAFA,CAGA;;AACA;AACAjF;AACA;;AACA;AACAA;AACA,aATA,CAUA;;;AACA;AACAA,4BACA3F,kDADA;AAEA,aAdA,CAeA;;;AACA,yBAAqB,kFAAoB;AAAA;AAAzC,cAAyC;AACzC;AACA2F,gCACA3F,8CADA;AAEA;;AACA,kBAAgB,kFAAoB;AAAA;AAApC,gBAAoC;AACpC2F;AACA,eAFA,MAGA,IAAqB,kFAAoB;AAAA;AAAzC,gBAAyC;AACzCA;AACA;AACA,aAXA,MAYA;AACA;AACAA,+BACA3F,+CADA;AAEA;AACA;;AACA;AACA;;;iBACA;AACA;;AACA,gBAAY,gFAAZ,EAAkC;AAClCA;AACA,aAFA,MAGA;AACA;AACAA;AACA;;AACA;AACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA,aATA,CAUA;;;AACA;;AACA;AACAwY;AACA,aAFA,MAGA;AACAA;AACA;;AACA,yBAAqB,kF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AAS,IAAT,CAHZ,EAIA;AACA;AACA;AACY,2EAAS,CAAT,EAAS2R,gBAAT,CAPZ,EAQA/W,SARA,CAQA;AAAA;AAAA,iBARA;;AASA;AACS,eAbT;AAAA;AAcA;;;iBACA;AACA;;AACA,0CAFA,CAGA;;;AACA;;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA,aAHA,CAIA;AACA;AACA;;;AACA;AACA;;AACA,6CAAwC,4DAAS,wBAAT,CAAxC,EAAiDA,SAAjD,CAAiD;AACjD;;AACA;AACA;;AACA;AACA;;AACA;AACa,eAPb;AAQS,aAVT;AAWA;AACA;;;;iBACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA,YACA;AACA;AACA;AACA;;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACAgX;AAA0B1B,0BAA1B;AAA0BC;AAA1B;AACA;;AACA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAAoC0B,IAApC,cAA4CC,8BAA5C;AACA;;AACA;AACAzI,+CAAsCwI,IAAtC,aADA,CAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA,iBAJA,MAKA;AACA;AACA;AACa,eATb;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;AACA;AAA0BE;AAA1B;;AACA;AACA1T;AACA,aAFA,MAGA;AACAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA,6HACA6S,IADA,uGAEA,mDAFA;AAGA;AACA;;;;iBACA;AACA;AACA;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yD;AACzD;AACA0D;AAAA;AAAA;;AACA;AACS,WAJT;;AAKA;AACA;AACA;;;;;eACA;AACA;AACA;eACA;AACA;;AACA,gBAAY,yEAAY7B,KAAZ,CAAZ,EAAwB;AACxB;AACA,aAFA,MAGA;AACA;AACA,+CAA6C+W,sEAA7C,CAA6D,qDAAY/W,KAAZ,IAAYA,KAAZ,GAAYgX,uBAAzE;AACA;AACA;AACA;AACA;AACA;AACA;;;;eACA;AACA;AACA;eACA;AAAA;;AACA;AACA,8CACA;AAAA;AAAA,aADA,GAEAC,SAFA;AAGA;AACA;;;;eACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;eACA;AACA;AACA;eACA;AACA,+CAA2C,6EAAoBC,IAApB,CAA3C;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA,qGACA,6CADA,GACA;AACA;AACA,aAPA,CAQA;;;AACA,6EATA,CAUA;;AACA,mDAXA,CAYA;AACA;;AACA;AACA,yBAfA,CAgBA;;AACA,4BAAwB1a,YAAxB,EAAsCA,GAAtC,EAAsC;AACtC;;AACA;AACA2a;AACA;AACA;AACA,aAvBA,CAwBA;;;AACA,yCAAmC3a,QAAnC,EAA2CA,KAA3C,EAA2C;AAC3C;;AACA;AACA4a;AACA;AACA;AACA;;AACA,2CACAC,oFADA,GACA,CADA;AAEA;;;iBACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA,eAFA,MAGA;AACA;AACA;;AACA;AACA;AACA;;;iBACA;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACa,eAFb;AAGA;;AACA;AACA;AACA;;;;iBACA;AACA;AACAC;AACA;;AACA;AACA,iDAA6C,2CAA7C;AACA;AACA;;;;iBACA;AACA;AACA;;AACA;AACA;;AACA/R;AACAA;;AACA;;AACAA;AACA;AACA;AACA;;;;iBACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA,eAD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","names":["ids","el","AriaDescriber","setMessageId","messageRegistry","messageElement","referenceCount","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","i","describedElements","messagesContainer","preExistingContainer","filter","element","addAriaReferencedId","registeredMessage","removeAriaReferencedId","message","trim","_angular_core__WEBPACK_IMPORTED_MODULE_0__","_angular_common__WEBPACK_IMPORTED_MODULE_1__","factory","token","providedIn","type","decorators","args","role","CDK_DESCRIBEDBY_ID_PREFIX","nextId","ListKeyManager","rxjs__WEBPACK_IMPORTED_MODULE_2__","rxjs__WEBPACK_IMPORTED_MODULE_3__","_items","debounceInterval","subscribe","item","_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__","event","keyCode","index","ActiveDescendantKeyManager","FocusKeyManager","IsFocusableConfig","InteractivityChecker","_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__","nodeName","inputType","isAnchorWithHref","hasValidTabIndex","FocusTrap","startAnchor","endAnchor","bound","console","markers","redirectToElement","focusableChild","anchor","isEnabled","fn","FocusTrapFactory","CdkTrapFocus","_document","value","selectors","inputs","enabled","autoCapture","exportAs","features","selector","ConfigurableFocusTrap","curr","polyfillClosest","EventListenerFocusTrapInertStrategy","focusTrap","setTimeout","FocusTrapManager","stack","ConfigurableFocusTrapFactory","config","defer","configObject","FOCUS_TRAP_INERT_STRATEGY","touch","ignoreKeys","passive","capture","InputModalityDetector","rxjs__WEBPACK_IMPORTED_MODULE_12__","INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS","options","ngZone","document","INPUT_MODALITY_DETECTOR_OPTIONS","LiveAnnouncer","duration","politeness","clearTimeout","defaultOptions","resolve","previousElements","liveEl","LIVE_ANNOUNCER_ELEMENT_TOKEN","LIVE_ANNOUNCER_DEFAULT_OPTIONS","CdkAriaLive","observe","_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_15__","FocusMonitor","handler","nativeElement","cachedInfo","checkChildren","subject","rootNode","elementInfo","forEach","window","pipe","results","FOCUS_MONITOR_DEFAULT_OPTIONS","CdkMonitorFocus","outputs","cdkFocusChange","HighContrastModeDetector","testElement","documentWindow","bodyClasses","A11yModule","highContrastModeDetector","imports","declarations","exports","Directionality","DIR_DOCUMENT","Dir","hostVars","hostBindings","ctx","dir","change","provide","useExisting","providers","host","BidiModule","DataSource","ArrayDataSource","_DisposeViewRepeaterStrategy","changes","view","operation","viewContainerRef","itemViewChanged","context","record","_RecycleViewRepeaterStrategy","cachedView","SelectionModel","initiallySelectedValues","values","source","added","removed","UniqueSelectionDispatcher","listener","_angular_core__WEBPACK_IMPORTED_MODULE_3__","modifiers","MutationObserverFactory","ContentObserver","elementOrRef","subscription","observer","characterData","childList","subtree","stream","count","CdkObserveContent","disabled","debounce","ObserversModule","BlockScrollStrategy","top","left","root","htmlStyle","html","bodyStyle","CloseScrollStrategy","NoopScrollStrategy","RepositionScrollStrategy","width","height","bottom","right","ScrollStrategyOptions","_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__","_angular_common__WEBPACK_IMPORTED_MODULE_4__","OverlayConfig","ConnectionPositionPair","offsetX","offsetY","panelClass","ScrollingVisibility","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","property","BaseOverlayDispatcher","OverlayKeyboardDispatcher","overlays","OverlayOutsideClickDispatcher","overlayRef","body","_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__","OverlayContainer","container","containerClass","oppositePlatformContainers","OverlayRef","rxjs__WEBPACK_IMPORTED_MODULE_5__","rxjs__WEBPACK_IMPORTED_MODULE_6__","strategy","sizeConfig","direction","style","requestAnimationFrame","backdropToDetach","timeoutId","cssClasses","isAdd","scrollStrategy","FlexibleConnectedPositionStrategy","flexibleFits","position","origin","overlayRect","boundingBoxRect","fallback","overlayFit","overlayPoint","originPoint","bestScore","bestFit","extendStyles","alignItems","justifyContent","x","y","overlayStartX","overlayStartY","point","visibleArea","isCompletelyWithinViewport","fitsInViewportVertically","fitsInViewportHorizontally","minHeight","minWidth","pushX","pushY","xOrigin","elements","yOrigin","styles","maxHeight","maxWidth","transform","transformString","documentHeight","horizontalStyleProperty","documentWidth","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","overflows","length","validateHorizontalPosition","validateVerticalPosition","destination","ConnectedPositionStrategy","withFlexibleDimensions","withPush","withViewportMargin","GlobalPositionStrategy","parentStyles","parent","OverlayPositionBuilder","Overlay","scrollStrategies","_overlayContainer","_componentFactoryResolver","_positionBuilder","_keyboardDispatcher","_injector","_ngZone","_directionality","_location","_outsideClickDispatcher","overlayConfig","pane","nextUniqueId","_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__","_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__","originX","originY","overlayX","overlayY","CdkOverlayOrigin","elementRef","CdkConnectedOverlay","templateRef","_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_12__","positionStrategy","hasBackdrop","setOrigin","withPositions","positions","withGrowAfterOpen","withLockedPosition","withTransformOriginOn","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","viewportMargin","open","disableClose","lockPosition","flexibleDimensions","growAfterOpen","push","backdropClass","transformOriginSelector","backdropClick","positionChange","attach","detach","overlayKeydown","overlayOutsideClick","deps","useFactory","OverlayModule","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","FullscreenOverlayContainer","platform","Portal","throwNullPortalOutletError","throwPortalAlreadyAttachedError","throwNoPortalAttachedError","ComponentPortal","TemplatePortal","DomPortal","BasePortalOutlet","throwNullPortalError","throwPortalOutletAlreadyDisposedError","throwUnknownPortalTypeError","BasePortalHost","DomPortalOutlet","outletElement","_appRef","_defaultInjector","anchorNode","componentRef","viewRef","viewContainer","DomPortalHost","CdkPortal","TemplatePortalDirective","t","CdkPortalOutlet","portal","attached","PortalHostDirective","PortalModule","PortalInjector","FixedSizeVirtualScrollStrategy","rxjs__WEBPACK_IMPORTED_MODULE_1__","start","end","firstVisibleIndex","scrollOffset","newRange","CdkFixedSizeVirtualScroll","itemSize","minBufferPx","maxBufferPx","ScrollDispatcher","scrollableReference","auditTimeInMs","scrollingContainers","elementOrElementRef","_angular_common__WEBPACK_IMPORTED_MODULE_10__","CdkScrollable","from","_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__","ViewportRuler","documentElement","throttleTime","rxjs__WEBPACK_IMPORTED_MODULE_13__","rxjs__WEBPACK_IMPORTED_MODULE_14__","CdkVirtualScrollViewport","rxjs__WEBPACK_IMPORTED_MODULE_15__","SCROLL_SCHEDULER","range","axis","Number","behavior","viewportEl","runAfterChangeDetection","VIRTUAL_SCROLL_STRATEGY","viewQuery","_c0","_t","hostAttrs","orientation","appendOnly","scrolledIndexChange","ngContentSelectors","decls","vars","consts","template","encapsulation","changeDetection","_contentWrapper","CdkVirtualForOf","_viewContainerRef","_template","_differs","_viewRepeater","_viewport","_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__","Array","undefined","size","firstNode","lastNode","getOffset","oldDs","$implicit","cdkVirtualForOf","first","last","odd","even","cdkVirtualForTrackBy","cdkVirtualForTemplate","cdkVirtualForTemplateCacheSize","useClass","CdkScrollableModule","ScrollingModule","_r10","ContextMenuContentComponent_li_6_a_3_ng_template_2_Template","ctx_r5","menuItem_r2","_c2","_r16","ContextMenuContentComponent_li_6_span_5_ng_template_2_Template","ctx_r6","ContextMenuContentComponent_li_6_a_3_Template","ContextMenuContentComponent_li_6_span_5_Template","ctx_r1","ContextMenuItemDirective","divider","visible","subMenu","execute","ContextMenuContentComponent","menuItem","queryList","_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_2__","withWrap","$event","exceptRootMenu","anchorElement","contextMenu","parentContextMenu","target","CONTEXT_MENU_OPTIONS","_c1","menuItems","isLeaf","menuClass","overlay","openSubMenu","closeLeafMenu","closeAllMenus","ContextMenuContentComponent_li_6_Template","directives","_angular_common__WEBPACK_IMPORTED_MODULE_3__","menuElement","menuItemElements","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","ContextMenuService","rxjs__WEBPACK_IMPORTED_MODULE_4__","getBoundingClientRect","eventType","withFallbackPosition","_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__","contextMenuContent","subscriptions","executeEvent","closeAllEvent","newLeaf","subMenuOverlay","_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__","ContextMenuComponent","menuEvent","contentQueries","dirIndex","autoFocus","useBootstrap4","close","ContextMenuAttachDirective","contextMenuSubject","onContextMenu","ContextMenuModule","ngModule","useValue","entryComponents","durationSubscriber","hasValue","lastValue","subscriber","isComplete","_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__","durationSelector","endDuration","cleanupDuration","auditTime","scheduler","async","audit","timer","bufferSize","windowTime","refCount","connector","_ReplaySubject__WEBPACK_IMPORTED_MODULE_1__","resetOnError","resetOnComplete","resetOnRefCountZero","inclusive","AnimationFrameAction","_super","_this","delay","_animationFrameProvider__WEBPACK_IMPORTED_MODULE_1__","id","_AsyncAction__WEBPACK_IMPORTED_MODULE_2__","AnimationFrameScheduler","action","_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__","AsapAction","_immediateProvider__WEBPACK_IMPORTED_MODULE_1__","AsapScheduler","_AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_0__","_AnimationFrameAction__WEBPACK_IMPORTED_MODULE_1__","schedule","request","cancel","callback","_Subscription__WEBPACK_IMPORTED_MODULE_0__","_i","cancelAnimationFrame","delegate","_AsapScheduler__WEBPACK_IMPORTED_MODULE_0__","_AsapAction__WEBPACK_IMPORTED_MODULE_1__","_util_Immediate__WEBPACK_IMPORTED_MODULE_0__","clearImmediate","setImmediate","activeHandles","resolved","findAndClearHandle","pending","_Observable__WEBPACK_IMPORTED_MODULE_0__","obj","highlightDay_r17","unhighlightDay_r18","eventClicked_r19","tooltipPlacement_r16","day_r13","dayHeaderClicked_r34","day","day_r36","_r0","segment_r41","segment_r44","ctx_r10","_r2","ctx_r11","_r4","_r8","ctx_r12","_r6","DemoComponent","angular_calendar__WEBPACK_IMPORTED_MODULE_1__","Date","date","events","title","color","_demo_utils_colors__WEBPACK_IMPORTED_MODULE_3__","refresh","next","DemoModule","angular_calendar__WEBPACK_IMPORTED_MODULE_2__","angular_calendar__WEBPACK_IMPORTED_MODULE_3__","angular_calendar_date_adapters_date_fns__WEBPACK_IMPORTED_MODULE_4__","ngx_contextmenu__WEBPACK_IMPORTED_MODULE_5__","_demo_utils_module__WEBPACK_IMPORTED_MODULE_6__","_angular_router__WEBPACK_IMPORTED_MODULE_7__","path","component","_component__WEBPACK_IMPORTED_MODULE_8__","CalendarHeaderComponent","viewDate","locale","viewChange","viewDateChange","DemoUtilsModule","_angular_forms__WEBPACK_IMPORTED_MODULE_2__","_calendar_header_component__WEBPACK_IMPORTED_MODULE_4__"],"sources":["webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/keycodes.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/observers.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/overlay.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/portal.js","webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js","webpack:///node_modules/ngx-contextmenu/__ivy_ngcc__/fesm2015/ngx-contextmenu.js","webpack:///node_modules/rxjs/dist/esm5/internal/operators/audit.js","webpack:///node_modules/rxjs/dist/esm5/internal/operators/auditTime.js","webpack:///node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js","webpack:///node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/asap.js","webpack:///node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js","webpack:///node_modules/rxjs/dist/esm5/internal/util/Immediate.js","webpack:///node_modules/rxjs/dist/esm5/internal/util/isObservable.js","webpack:///projects/demos/app/demo-modules/context-menu/template.html","webpack:///projects/demos/app/demo-modules/context-menu/component.ts","webpack:///projects/demos/app/demo-modules/context-menu/module.ts","webpack:///projects/demos/app/demo-modules/demo-utils/calendar-header.component.ts","webpack:///projects/demos/app/demo-modules/demo-utils/module.ts"],"sourcesContent":["import * as i2 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, QueryList, NgZone, Directive, ElementRef, Input, InjectionToken, Optional, EventEmitter, Output, NgModule } from '@angular/core';\nimport { Subject, Subscription, BehaviorSubject, of } from 'rxjs';\nimport { hasModifierKey, A, Z, ZERO, NINE, END, HOME, LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW, TAB, ALT, CONTROL, MAC_META, META, SHIFT } from '@angular/cdk/keycodes';\nimport { tap, debounceTime, filter, map, take, skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { coerceBooleanProperty, coerceElement } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { Platform, _getFocusedElementPierceShadowDom, normalizePassiveListenerOptions, _getEventTarget, _getShadowRoot, PlatformModule } from '@angular/cdk/platform';\nimport { ContentObserver, ObserversModule } from '@angular/cdk/observers';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IDs are delimited by an empty space, as per the spec. */\nimport * as ngcc0 from '@angular/core';\nimport * as ngcc1 from '@angular/cdk/platform';\nimport * as ngcc2 from '@angular/cdk/observers';\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    if (ids.some(existingId => existingId.trim() == id.trim())) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    const filteredIds = ids.filter(val => val != id.trim());\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** ID used for the body container where all messages are appended. */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/** ID prefix used for each created message element. */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/** Attribute given to each host element that is described by a message element. */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/** Global map of all registered message elements that have been placed into the document. */\nconst messageRegistry = new Map();\n/** Container for all registered messages. */\nlet messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n */\nclass AriaDescriber {\n    constructor(_document) {\n        this._document = _document;\n    }\n    describe(hostElement, message, role) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (typeof message !== 'string') {\n            // We need to ensure that the element has an ID.\n            setMessageId(message);\n            messageRegistry.set(key, { messageElement: message, referenceCount: 0 });\n        }\n        else if (!messageRegistry.has(key)) {\n            this._createMessageElement(message, role);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, key)) {\n            this._addMessageReference(hostElement, key);\n        }\n    }\n    removeDescription(hostElement, message, role) {\n        if (!message || !this._isElementNode(hostElement)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (this._isElementDescribedByMessage(hostElement, key)) {\n            this._removeMessageReference(hostElement, key);\n        }\n        // If the message is a string, it means that it's one that we created for the\n        // consumer so we can remove it safely, otherwise we should leave it in place.\n        if (typeof message === 'string') {\n            const registeredMessage = messageRegistry.get(key);\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\n                this._deleteMessageElement(key);\n            }\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    }\n    /** Unregisters all created message elements and removes the message container. */\n    ngOnDestroy() {\n        const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\n        for (let i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    }\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     */\n    _createMessageElement(message, role) {\n        const messageElement = this._document.createElement('div');\n        setMessageId(messageElement);\n        messageElement.textContent = message;\n        if (role) {\n            messageElement.setAttribute('role', role);\n        }\n        this._createMessagesContainer();\n        messagesContainer.appendChild(messageElement);\n        messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });\n    }\n    /** Deletes the message element from the global messages container. */\n    _deleteMessageElement(key) {\n        const registeredMessage = messageRegistry.get(key);\n        const messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(key);\n    }\n    /** Creates the global container for all aria-describedby messages. */\n    _createMessagesContainer() {\n        if (!messagesContainer) {\n            const preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n            // When going from the server to the client, we may end up in a situation where there's\n            // already a container on the page, but we don't have a reference to it. Clear the\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\n            // container, should be slightly faster.\n            if (preExistingContainer && preExistingContainer.parentNode) {\n                preExistingContainer.parentNode.removeChild(preExistingContainer);\n            }\n            messagesContainer = this._document.createElement('div');\n            messagesContainer.id = MESSAGES_CONTAINER_ID;\n            // We add `visibility: hidden` in order to prevent text in this container from\n            // being searchable by the browser's Ctrl + F functionality.\n            // Screen-readers will still read the description for elements with aria-describedby even\n            // when the description element is not visible.\n            messagesContainer.style.visibility = 'hidden';\n            // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n            // the description element doesn't impact page layout.\n            messagesContainer.classList.add('cdk-visually-hidden');\n            this._document.body.appendChild(messagesContainer);\n        }\n    }\n    /** Deletes the global messages container. */\n    _deleteMessagesContainer() {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    }\n    /** Removes all cdk-describedby messages that are hosted through the element. */\n    _removeCdkDescribedByReferenceIds(element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    }\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     */\n    _addMessageReference(element, key) {\n        const registeredMessage = messageRegistry.get(key);\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    }\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     */\n    _removeMessageReference(element, key) {\n        const registeredMessage = messageRegistry.get(key);\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    }\n    /** Returns true if the element has been described by the provided message ID. */\n    _isElementDescribedByMessage(element, key) {\n        const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        const registeredMessage = messageRegistry.get(key);\n        const messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    }\n    /** Determines whether a message can be described on a particular element. */\n    _canBeDescribed(element, message) {\n        if (!this._isElementNode(element)) {\n            return false;\n        }\n        if (message && typeof message === 'object') {\n            // We'd have to make some assumptions about the description element's text, if the consumer\n            // passed in an element. Assume that if an element is passed in, the consumer has verified\n            // that it can be used as a description.\n            return true;\n        }\n        const trimmedMessage = message == null ? '' : `${message}`.trim();\n        const ariaLabel = element.getAttribute('aria-label');\n        // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n        // element, because screen readers will end up reading out the same text twice in a row.\n        return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\n    }\n    /** Checks whether a node is an Element node. */\n    _isElementNode(element) {\n        return element.nodeType === this._document.ELEMENT_NODE;\n    }\n}\nAriaDescriber.fac = function AriaDescriber_Factory(t) { return new (t || AriaDescriber)(ngcc0.inject(DOCUMENT)); };\nAriaDescriber.prov = i0.defineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(i0.inject(i2.DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\nAriaDescriber.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(AriaDescriber, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message, role) {\n    return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element) {\n    if (!element.id) {\n        element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n    constructor(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._activeItem = null;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._vertical = true;\n        this._allowedModifierKeys = [];\n        this._homeAndEnd = false;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = (item) => item.disabled;\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /** Stream that emits whenever the active item of the list manager changes. */\n        this.change = new Subject();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            _items.changes.subscribe((newItems) => {\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && (this._items.length &&\n            this._items.some(item => typeof item.getLabel !== 'function'))) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(letter => this._pressedLetters.push(letter)), debounceTime(debounceInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join(''))).subscribe(inputString => {\n            const items = this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n                if (!this._skipPredicateFn(item) &&\n                    item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem;\n        this.updateActiveItem(item);\n        if (this._activeItem !== previousActiveItem) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem;\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem = activeItem == null ? null : activeItem;\n        this._activeItemIndex = index;\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ActiveDescendantKeyManager extends ListKeyManager {\n    setActiveItem(index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        super.setActiveItem(index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass FocusKeyManager extends ListKeyManager {\n    constructor() {\n        super(...arguments);\n        this._origin = 'program';\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    constructor() {\n        /**\n         * Whether to count an element as focusable even if it is not currently visible.\n         */\n        this.ignoreVisibility = false;\n    }\n}\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n// supported.\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nclass InteractivityChecker {\n    constructor(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    isDisabled(element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    }\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    isVisible(element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    }\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    isTabbable(element) {\n        // Nothing is tabbable on the server \n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        const frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Browsers disable tabbing to an element inside of an invisible frame.\n            if (!this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        let nodeName = element.nodeName.toLowerCase();\n        let tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe' || nodeName === 'object') {\n            // The frame or object's content may be tabbable depending on the content, but it's\n            // not possibly to reliably detect the content of the frames. We always consider such\n            // elements as non-tabbable.\n            return false;\n        }\n        // In iOS, the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        if (nodeName === 'audio') {\n            // Audio elements without controls enabled are never tabbable, regardless\n            // of the tabindex attribute explicitly being set.\n            if (!element.hasAttribute('controls')) {\n                return false;\n            }\n            // Audio elements with controls are by default tabbable unless the\n            // tabindex attribute is set to `-1` explicitly.\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'video') {\n            // For all video elements, if the tabindex attribute is set to `-1`, the video\n            // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n            // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n            // tabindex attribute is the source of truth here.\n            if (tabIndexValue === -1) {\n                return false;\n            }\n            // If the tabindex is explicitly set, and not `-1` (as per check before), the\n            // video element is always tabbable (regardless of whether it has controls or not).\n            if (tabIndexValue !== null) {\n                return true;\n            }\n            // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n            // has controls enabled. Firefox is special as videos are always tabbable regardless\n            // of whether there are controls or not.\n            return this._platform.FIREFOX || element.hasAttribute('controls');\n        }\n        return element.tabIndex >= 0;\n    }\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @param config The config object with options to customize this method's behavior\n     * @returns Whether the element is focusable.\n     */\n    isFocusable(element, config) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) &&\n            ((config === null || config === void 0 ? void 0 : config.ignoreVisibility) || this.isVisible(element));\n    }\n}\nInteractivityChecker.fac = function InteractivityChecker_Factory(t) { return new (t || InteractivityChecker)(ngcc0.inject(ngcc1.Platform)); };\nInteractivityChecker.prov = i0.defineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(i0.inject(i1.Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\nInteractivityChecker.ctorParameters = () => [\n    { type: Platform }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(InteractivityChecker, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc1.Platform }]; }, null); })();\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch (_a) {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return node.ownerDocument && node.ownerDocument.defaultView || window;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change 11.0.0\n */\nclass FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n        this.startAnchorListener = () => this.focusLastTabbableElement();\n        this.endAnchorListener = () => this.focusFirstTabbableElement();\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Whether the focus trap is active. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            if (startAnchor.parentNode) {\n                startAnchor.parentNode.removeChild(startAnchor);\n            }\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            if (endAnchor.parentNode) {\n                endAnchor.parentNode.removeChild(endAnchor);\n            }\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        let markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\n            `[cdkFocusRegion${bound}], ` +\n            `[cdk-focus-${bound}]`);\n        for (let i = 0; i < markers.length; i++) {\n            // @breaking-change 8.0.0\n            if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                    `attribute will be removed in 8.0.0.`, markers[i]);\n            }\n            else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0.`, markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement(options) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` +\n            `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if (redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild === null || focusableChild === void 0 ? void 0 : focusableChild.focus(options);\n                return !!focusableChild;\n            }\n            redirectToElement.focus(options);\n            return true;\n        }\n        return this.focusFirstTabbableElement(options);\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        let children = root.children || root.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        let children = root.children || root.childNodes;\n        for (let i = children.length - 1; i >= 0; i--) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.pipe(take(1)).subscribe(fn);\n        }\n    }\n}\n/**\n * Factory that allows easy instantiation of focus traps.\n * @deprecated Use `ConfigurableFocusTrapFactory` instead.\n * @breaking-change 11.0.0\n */\nclass FocusTrapFactory {\n    constructor(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    create(element, deferCaptureElements = false) {\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    }\n}\nFocusTrapFactory.fac = function FocusTrapFactory_Factory(t) { return new (t || FocusTrapFactory)(ngcc0.inject(InteractivityChecker), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(DOCUMENT)); };\nFocusTrapFactory.prov = i0.defineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(i0.inject(InteractivityChecker), i0.inject(i0.NgZone), i0.inject(i2.DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\nFocusTrapFactory.ctorParameters = () => [\n    { type: InteractivityChecker },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(FocusTrapFactory, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: InteractivityChecker }, { type: ngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n/** Directive for trapping focus within a region. */\nclass CdkTrapFocus {\n    constructor(_elementRef, _focusTrapFactory, \n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 13.0.0\n     */\n    _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n        this._previouslyFocusedElement = null;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    /** Whether the focus trap is active. */\n    get enabled() { return this.focusTrap.enabled; }\n    set enabled(value) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n    /**\n     * Whether the directive should automatically move focus into the trapped region upon\n     * initialization and return focus to the previous activeElement upon destruction.\n     */\n    get autoCapture() { return this._autoCapture; }\n    set autoCapture(value) { this._autoCapture = coerceBooleanProperty(value); }\n    ngOnDestroy() {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    }\n    ngAfterContentInit() {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._captureFocus();\n        }\n    }\n    ngDoCheck() {\n        if (!this.focusTrap.hasAttached()) {\n            this.focusTrap.attachAnchors();\n        }\n    }\n    ngOnChanges(changes) {\n        const autoCaptureChange = changes['autoCapture'];\n        if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture &&\n            this.focusTrap.hasAttached()) {\n            this._captureFocus();\n        }\n    }\n    _captureFocus() {\n        this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();\n        this.focusTrap.focusInitialElementWhenReady();\n    }\n}\nCdkTrapFocus.fac = function CdkTrapFocus_Factory(t) { return new (t || CdkTrapFocus)(ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(FocusTrapFactory), ngcc0.directiveInject(DOCUMENT)); };\nCdkTrapFocus.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkTrapFocus, selectors: [[\"\", \"cdkTrapFocus\", \"\"]], inputs: { enabled: [\"cdkTrapFocus\", \"enabled\"], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\"] }, exportAs: [\"cdkTrapFocus\"], features: [ngcc0.NgOnChangesFeature] });\nCdkTrapFocus.ctorParameters = () => [\n    { type: ElementRef },\n    { type: FocusTrapFactory },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nCdkTrapFocus.propDecorators = {\n    enabled: [{ type: Input, args: ['cdkTrapFocus',] }],\n    autoCapture: [{ type: Input, args: ['cdkTrapFocusAutoCapture',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkTrapFocus, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkTrapFocus]',\n                exportAs: 'cdkTrapFocus'\n            }]\n    }], function () { return [{ type: ngcc0.ElementRef }, { type: FocusTrapFactory }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, { enabled: [{\n            type: Input,\n            args: ['cdkTrapFocus']\n        }], autoCapture: [{\n            type: Input,\n            args: ['cdkTrapFocusAutoCapture']\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {\n        super(_element, _checker, _ngZone, _document, config.defer);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Whether the FocusTrap is enabled. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = new InjectionToken('FOCUS_TRAP_INERT_STRATEGY');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IE 11 compatible closest implementation that is able to start from non-Element Nodes. */\nfunction closest(element, selector) {\n    if (!(element instanceof Node)) {\n        return null;\n    }\n    let curr = element;\n    while (curr != null && !(curr instanceof Element)) {\n        curr = curr.parentNode;\n    }\n    return curr && (hasNativeClosest ?\n        curr.closest(selector) : polyfillClosest(curr, selector));\n}\n/** Polyfill for browsers without Element.closest. */\nfunction polyfillClosest(element, selector) {\n    let curr = element;\n    while (curr != null && !(curr instanceof Element && matches(curr, selector))) {\n        curr = curr.parentNode;\n    }\n    return (curr || null);\n}\nconst hasNativeClosest = typeof Element != 'undefined' && !!Element.prototype.closest;\n/** IE 11 compatible matches implementation. */\nfunction matches(element, selector) {\n    return element.matches ?\n        element.matches(selector) :\n        element['msMatchesSelector'](selector);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    constructor() {\n        /** Focus event handler. */\n        this._listener = null;\n    }\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (!focusTrapRoot.contains(target) && closest(target, 'div.cdk-overlay-pane') === null) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injectable that ensures only the most recently enabled FocusTrap is active. */\nclass FocusTrapManager {\n    constructor() {\n        // A stack of the FocusTraps on the page. Only the FocusTrap at the\n        // top of the stack is active.\n        this._focusTrapStack = [];\n    }\n    /**\n     * Disables the FocusTrap at the top of the stack, and then pushes\n     * the new FocusTrap onto the stack.\n     */\n    register(focusTrap) {\n        // Dedupe focusTraps that register multiple times.\n        this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);\n        let stack = this._focusTrapStack;\n        if (stack.length) {\n            stack[stack.length - 1]._disable();\n        }\n        stack.push(focusTrap);\n        focusTrap._enable();\n    }\n    /**\n     * Removes the FocusTrap from the stack, and activates the\n     * FocusTrap that is the new top of the stack.\n     */\n    deregister(focusTrap) {\n        focusTrap._disable();\n        const stack = this._focusTrapStack;\n        const i = stack.indexOf(focusTrap);\n        if (i !== -1) {\n            stack.splice(i, 1);\n            if (stack.length) {\n                stack[stack.length - 1]._enable();\n            }\n        }\n    }\n}\nFocusTrapManager.fac = function FocusTrapManager_Factory(t) { return new (t || FocusTrapManager)(); };\nFocusTrapManager.prov = i0.defineInjectable({ factory: function FocusTrapManager_Factory() { return new FocusTrapManager(); }, token: FocusTrapManager, providedIn: \"root\" });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(FocusTrapManager, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return []; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Factory that allows easy instantiation of configurable focus traps. */\nclass ConfigurableFocusTrapFactory {\n    constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._focusTrapManager = _focusTrapManager;\n        this._document = _document;\n        // TODO split up the strategies into different modules, similar to DateAdapter.\n        this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();\n    }\n    create(element, config = { defer: false }) {\n        let configObject;\n        if (typeof config === 'boolean') {\n            configObject = { defer: config };\n        }\n        else {\n            configObject = config;\n        }\n        return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);\n    }\n}\nConfigurableFocusTrapFactory.fac = function ConfigurableFocusTrapFactory_Factory(t) { return new (t || ConfigurableFocusTrapFactory)(ngcc0.inject(InteractivityChecker), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(FocusTrapManager), ngcc0.inject(DOCUMENT), ngcc0.inject(FOCUS_TRAP_INERT_STRATEGY, 8)); };\nConfigurableFocusTrapFactory.prov = i0.defineInjectable({ factory: function ConfigurableFocusTrapFactory_Factory() { return new ConfigurableFocusTrapFactory(i0.inject(InteractivityChecker), i0.inject(i0.NgZone), i0.inject(FocusTrapManager), i0.inject(i2.DOCUMENT), i0.inject(FOCUS_TRAP_INERT_STRATEGY, 8)); }, token: ConfigurableFocusTrapFactory, providedIn: \"root\" });\nConfigurableFocusTrapFactory.ctorParameters = () => [\n    { type: InteractivityChecker },\n    { type: NgZone },\n    { type: FocusTrapManager },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FOCUS_TRAP_INERT_STRATEGY,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ConfigurableFocusTrapFactory, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: InteractivityChecker }, { type: ngcc0.NgZone }, { type: FocusTrapManager }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [FOCUS_TRAP_INERT_STRATEGY]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // Some screen readers will dispatch a fake `mousedown` event when pressing enter or space on\n    // a clickable element. We can distinguish these events when both `offsetX` and `offsetY` are\n    // zero. Note that there's an edge case where the user could click the 0x0 spot of the screen\n    // themselves, but that is unlikely to contain interaction elements. Historially we used to check\n    // `event.buttons === 0`, however that no longer works on recent versions of NVDA.\n    return event.offsetX === 0 && event.offsetY === 0;\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) ||\n        (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n    constructor(_platform, ngZone, document, options) {\n        this._platform = _platform;\n        /**\n         * The most recently detected input modality event target. Is null if no input modality has been\n         * detected or if the associated event target is null for some unknown reason.\n         */\n        this._mostRecentTarget = null;\n        /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n        this._modality = new BehaviorSubject(null);\n        /**\n         * The timestamp of the last touch input modality. Used to determine whether mousedown events\n         * should be attributed to mouse or touch.\n         */\n        this._lastTouchMs = 0;\n        /**\n         * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n         * bound.\n         */\n        this._onKeydown = (event) => {\n            var _a, _b;\n            // If this is one of the keys we should ignore, then ignore it and don't update the input\n            // modality to keyboard.\n            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.ignoreKeys) === null || _b === void 0 ? void 0 : _b.some(keyCode => keyCode === event.keyCode)) {\n                return;\n            }\n            this._modality.next('keyboard');\n            this._mostRecentTarget = _getEventTarget(event);\n        };\n        /**\n         * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n         * gets bound.\n         */\n        this._onMousedown = (event) => {\n            // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n            // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n            // after the previous touch event.\n            if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n                return;\n            }\n            // Fake mousedown events are fired by some screen readers when controls are activated by the\n            // screen reader. Attribute them to keyboard input modality.\n            this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n            this._mostRecentTarget = _getEventTarget(event);\n        };\n        /**\n         * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n         * gets bound.\n         */\n        this._onTouchstart = (event) => {\n            // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n            // events are fired. Again, attribute to keyboard input modality.\n            if (isFakeTouchstartFromScreenReader(event)) {\n                this._modality.next('keyboard');\n                return;\n            }\n            // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n            // triggered via mouse vs touch.\n            this._lastTouchMs = Date.now();\n            this._modality.next('touch');\n            this._mostRecentTarget = _getEventTarget(event);\n        };\n        this._options = Object.assign(Object.assign({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);\n        // Skip the first emission as it's null.\n        this.modalityDetected = this._modality.pipe(skip(1));\n        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\n        // modality to detect.\n        if (!_platform.isBrowser) {\n            return;\n        }\n        // Add the event listeners used to detect the user's input modality.\n        ngZone.runOutsideAngular(() => {\n            document.addEventListener('keydown', this._onKeydown, modalityEventListenerOptions);\n            document.addEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);\n            document.addEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);\n        });\n    }\n    /** The most recently detected input modality. */\n    get mostRecentModality() {\n        return this._modality.value;\n    }\n    ngOnDestroy() {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        document.removeEventListener('keydown', this._onKeydown, modalityEventListenerOptions);\n        document.removeEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);\n        document.removeEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);\n    }\n}\nInputModalityDetector.fac = function InputModalityDetector_Factory(t) { return new (t || InputModalityDetector)(ngcc0.inject(ngcc1.Platform), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(DOCUMENT), ngcc0.inject(INPUT_MODALITY_DETECTOR_OPTIONS, 8)); };\nInputModalityDetector.prov = i0.defineInjectable({ factory: function InputModalityDetector_Factory() { return new InputModalityDetector(i0.inject(i1.Platform), i0.inject(i0.NgZone), i0.inject(i2.DOCUMENT), i0.inject(INPUT_MODALITY_DETECTOR_OPTIONS, 8)); }, token: InputModalityDetector, providedIn: \"root\" });\nInputModalityDetector.ctorParameters = () => [\n    { type: Platform },\n    { type: NgZone },\n    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INPUT_MODALITY_DETECTOR_OPTIONS,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(InputModalityDetector, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc1.Platform }, { type: ngcc0.NgZone }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [INPUT_MODALITY_DETECTOR_OPTIONS]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/** @docs-private */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass LiveAnnouncer {\n    constructor(elementToken, _ngZone, _document, _defaultOptions) {\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        // We inject the live element and document as `any` because the constructor signature cannot\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n        // a class decorator causes TypeScript to preserve the constructor signature types.\n        this._document = _document;\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    announce(message, ...args) {\n        const defaultOptions = this._defaultOptions;\n        let politeness;\n        let duration;\n        if (args.length === 1 && typeof args[0] === 'number') {\n            duration = args[0];\n        }\n        else {\n            [politeness, duration] = args;\n        }\n        this.clear();\n        clearTimeout(this._previousTimeout);\n        if (!politeness) {\n            politeness =\n                (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\n        }\n        if (duration == null && defaultOptions) {\n            duration = defaultOptions.duration;\n        }\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return this._ngZone.runOutsideAngular(() => {\n            return new Promise(resolve => {\n                clearTimeout(this._previousTimeout);\n                this._previousTimeout = setTimeout(() => {\n                    this._liveElement.textContent = message;\n                    resolve();\n                    if (typeof duration === 'number') {\n                        this._previousTimeout = setTimeout(() => this.clear(), duration);\n                    }\n                }, 100);\n            });\n        });\n    }\n    /**\n     * Clears the current text from the announcer element. Can be used to prevent\n     * screen readers from reading the text out again while the user is going\n     * through the page landmarks.\n     */\n    clear() {\n        if (this._liveElement) {\n            this._liveElement.textContent = '';\n        }\n    }\n    ngOnDestroy() {\n        clearTimeout(this._previousTimeout);\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n            this._liveElement = null;\n        }\n    }\n    _createLiveElement() {\n        const elementClass = 'cdk-live-announcer-element';\n        const previousElements = this._document.getElementsByClassName(elementClass);\n        const liveEl = this._document.createElement('div');\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n        for (let i = 0; i < previousElements.length; i++) {\n            previousElements[i].parentNode.removeChild(previousElements[i]);\n        }\n        liveEl.classList.add(elementClass);\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    }\n}\nLiveAnnouncer.fac = function LiveAnnouncer_Factory(t) { return new (t || LiveAnnouncer)(ngcc0.inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(DOCUMENT), ngcc0.inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); };\nLiveAnnouncer.prov = i0.defineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(i0.inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), i0.inject(i0.NgZone), i0.inject(i2.DOCUMENT), i0.inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\nLiveAnnouncer.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(LiveAnnouncer, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [LIVE_ANNOUNCER_ELEMENT_TOKEN]\n            }] }, { type: ngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS]\n            }] }]; }, null); })();\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nclass CdkAriaLive {\n    constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n        this._elementRef = _elementRef;\n        this._liveAnnouncer = _liveAnnouncer;\n        this._contentObserver = _contentObserver;\n        this._ngZone = _ngZone;\n        this._politeness = 'polite';\n    }\n    /** The aria-live politeness level to use when announcing messages. */\n    get politeness() { return this._politeness; }\n    set politeness(value) {\n        this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n        if (this._politeness === 'off') {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n                this._subscription = null;\n            }\n        }\n        else if (!this._subscription) {\n            this._subscription = this._ngZone.runOutsideAngular(() => {\n                return this._contentObserver\n                    .observe(this._elementRef)\n                    .subscribe(() => {\n                    // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                    const elementText = this._elementRef.nativeElement.textContent;\n                    // The `MutationObserver` fires also for attribute\n                    // changes which we don't want to announce.\n                    if (elementText !== this._previousAnnouncedText) {\n                        this._liveAnnouncer.announce(elementText, this._politeness);\n                        this._previousAnnouncedText = elementText;\n                    }\n                });\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this._subscription) {\n            this._subscription.unsubscribe();\n        }\n    }\n}\nCdkAriaLive.fac = function CdkAriaLive_Factory(t) { return new (t || CdkAriaLive)(ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(LiveAnnouncer), ngcc0.directiveInject(ngcc2.ContentObserver), ngcc0.directiveInject(ngcc0.NgZone)); };\nCdkAriaLive.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkAriaLive, selectors: [[\"\", \"cdkAriaLive\", \"\"]], inputs: { politeness: [\"cdkAriaLive\", \"politeness\"] }, exportAs: [\"cdkAriaLive\"] });\nCdkAriaLive.ctorParameters = () => [\n    { type: ElementRef },\n    { type: LiveAnnouncer },\n    { type: ContentObserver },\n    { type: NgZone }\n];\nCdkAriaLive.propDecorators = {\n    politeness: [{ type: Input, args: ['cdkAriaLive',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkAriaLive, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkAriaLive]',\n                exportAs: 'cdkAriaLive'\n            }]\n    }], function () { return [{ type: ngcc0.ElementRef }, { type: LiveAnnouncer }, { type: ngcc2.ContentObserver }, { type: ngcc0.NgZone }]; }, { politeness: [{\n            type: Input,\n            args: ['cdkAriaLive']\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n    constructor(_ngZone, _platform, _inputModalityDetector, \n    /** @breaking-change 11.0.0 make document required */\n    document, options) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        this._inputModalityDetector = _inputModalityDetector;\n        /** The focus origin that the next focus event is a result of. */\n        this._origin = null;\n        /** Whether the window has just been focused. */\n        this._windowFocused = false;\n        /**\n         * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n         * focus events to touch interactions requires special logic.\n         */\n        this._originFromTouchInteraction = false;\n        /** Map of elements being monitored to their info. */\n        this._elementInfo = new Map();\n        /** The number of elements currently being monitored. */\n        this._monitoredElementCount = 0;\n        /**\n         * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n         * as well as the number of monitored elements that they contain. We have to treat focus/blur\n         * handlers differently from the rest of the events, because the browser won't emit events\n         * to the document when focus moves inside of a shadow root.\n         */\n        this._rootNodeFocusListenerCount = new Map();\n        /**\n         * Event listener for `focus` events on the window.\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\n         */\n        this._windowFocusListener = () => {\n            // Make a note of when the window regains focus, so we can\n            // restore the origin info for the focused element.\n            this._windowFocused = true;\n            this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n        };\n        /** Subject for stopping our InputModalityDetector subscription. */\n        this._stopInputModalityDetector = new Subject();\n        /**\n         * Event listener for `focus` and 'blur' events on the document.\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\n         */\n        this._rootNodeFocusAndBlurListener = (event) => {\n            const target = _getEventTarget(event);\n            const handler = event.type === 'focus' ? this._onFocus : this._onBlur;\n            // We need to walk up the ancestor chain in order to support `checkChildren`.\n            for (let element = target; element; element = element.parentElement) {\n                handler.call(this, event, element);\n            }\n        };\n        this._document = document;\n        this._detectionMode = (options === null || options === void 0 ? void 0 : options.detectionMode) || 0 /* IMMEDIATE */;\n    }\n    monitor(element, checkChildren = false) {\n        const nativeElement = coerceElement(element);\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n            return of(null);\n        }\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\n        // to the `document`, if focus is moving within the same shadow root.\n        const rootNode = _getShadowRoot(nativeElement) || this._getDocument();\n        const cachedInfo = this._elementInfo.get(nativeElement);\n        // Check if we're already monitoring this element.\n        if (cachedInfo) {\n            if (checkChildren) {\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                // robust solution.\n                cachedInfo.checkChildren = true;\n            }\n            return cachedInfo.subject;\n        }\n        // Create monitored element info.\n        const info = {\n            checkChildren: checkChildren,\n            subject: new Subject(),\n            rootNode\n        };\n        this._elementInfo.set(nativeElement, info);\n        this._registerGlobalListeners(info);\n        return info.subject;\n    }\n    stopMonitoring(element) {\n        const nativeElement = coerceElement(element);\n        const elementInfo = this._elementInfo.get(nativeElement);\n        if (elementInfo) {\n            elementInfo.subject.complete();\n            this._setClasses(nativeElement);\n            this._elementInfo.delete(nativeElement);\n            this._removeGlobalListeners(elementInfo);\n        }\n    }\n    focusVia(element, origin, options) {\n        const nativeElement = coerceElement(element);\n        const focusedElement = this._getDocument().activeElement;\n        // If the element is focused already, calling `focus` again won't trigger the event listener\n        // which means that the focus classes won't be updated. If that's the case, update the classes\n        // directly without waiting for an event.\n        if (nativeElement === focusedElement) {\n            this._getClosestElementsInfo(nativeElement)\n                .forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n        }\n        else {\n            this._setOrigin(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                nativeElement.focus(options);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    /** Access injected document if available or fallback to global document reference */\n    _getDocument() {\n        return this._document || document;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        const doc = this._getDocument();\n        return doc.defaultView || window;\n    }\n    _toggleClass(element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    }\n    _getFocusOrigin(focusEventTarget) {\n        if (this._origin) {\n            // If the origin was realized via a touch interaction, we need to perform additional checks\n            // to determine whether the focus origin should be attributed to touch or program.\n            if (this._originFromTouchInteraction) {\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n            }\n            else {\n                return this._origin;\n            }\n        }\n        // If the window has just regained focus, we can restore the most recent origin from before the\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n        // focus. This typically means one of two things happened:\n        //\n        // 1) The element was programmatically focused, or\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\n        //    events).\n        //\n        // Because we can't distinguish between these two cases, we default to setting `program`.\n        return (this._windowFocused && this._lastFocusOrigin) ? this._lastFocusOrigin : 'program';\n    }\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    _shouldBeAttributedToTouch(focusEventTarget) {\n        // Please note that this check is not perfect. Consider the following edge case:\n        //\n        // <div #parent tabindex=\"0\">\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\n        // focusVia(parent, 'program') to focus #parent.\n        return (this._detectionMode === 1 /* EVENTUAL */) ||\n            !!(focusEventTarget === null || focusEventTarget === void 0 ? void 0 : focusEventTarget.contains(this._inputModalityDetector._mostRecentTarget));\n    }\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    _setClasses(element, origin) {\n        this._toggleClass(element, 'cdk-focused', !!origin);\n        this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n        this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n        this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n        this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n    }\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    _setOrigin(origin, isFromInteraction = false) {\n        this._ngZone.runOutsideAngular(() => {\n            this._origin = origin;\n            this._originFromTouchInteraction = (origin === 'touch') && isFromInteraction;\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\n            // the event queue. Before doing so, clear any pending timeouts.\n            if (this._detectionMode === 0 /* IMMEDIATE */) {\n                clearTimeout(this._originTimeoutId);\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n                this._originTimeoutId = setTimeout(() => this._origin = null, ms);\n            }\n        });\n    }\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    _onFocus(event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        const focusEventTarget = _getEventTarget(event);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n            return;\n        }\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n    }\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo.subject, null);\n    }\n    _emitOrigin(subject, origin) {\n        this._ngZone.run(() => subject.next(origin));\n    }\n    _registerGlobalListeners(elementInfo) {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        const rootNode = elementInfo.rootNode;\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n        if (!rootNodeFocusListeners) {\n            this._ngZone.runOutsideAngular(() => {\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n            });\n        }\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount === 1) {\n            // Note: we listen to events in the capture phase so we\n            // can detect them even if the user stops propagation.\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                window.addEventListener('focus', this._windowFocusListener);\n            });\n            // The InputModalityDetector is also just a collection of global listeners.\n            this._inputModalityDetector.modalityDetected\n                .pipe(takeUntil(this._stopInputModalityDetector))\n                .subscribe(modality => { this._setOrigin(modality, true /* isFromInteraction */); });\n        }\n    }\n    _removeGlobalListeners(elementInfo) {\n        const rootNode = elementInfo.rootNode;\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n            if (rootNodeFocusListeners > 1) {\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n            }\n            else {\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                this._rootNodeFocusListenerCount.delete(rootNode);\n            }\n        }\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            const window = this._getWindow();\n            window.removeEventListener('focus', this._windowFocusListener);\n            // Equivalently, stop our InputModalityDetector subscription.\n            this._stopInputModalityDetector.next();\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        }\n    }\n    /** Updates all the state on an element once its focus origin has changed. */\n    _originChanged(element, origin, elementInfo) {\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo.subject, origin);\n        this._lastFocusOrigin = origin;\n    }\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    _getClosestElementsInfo(element) {\n        const results = [];\n        this._elementInfo.forEach((info, currentElement) => {\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                results.push([currentElement, info]);\n            }\n        });\n        return results;\n    }\n}\nFocusMonitor.fac = function FocusMonitor_Factory(t) { return new (t || FocusMonitor)(ngcc0.inject(ngcc0.NgZone), ngcc0.inject(ngcc1.Platform), ngcc0.inject(InputModalityDetector), ngcc0.inject(DOCUMENT, 8), ngcc0.inject(FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); };\nFocusMonitor.prov = i0.defineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(i0.inject(i0.NgZone), i0.inject(i1.Platform), i0.inject(InputModalityDetector), i0.inject(i2.DOCUMENT, 8), i0.inject(FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); }, token: FocusMonitor, providedIn: \"root\" });\nFocusMonitor.ctorParameters = () => [\n    { type: NgZone },\n    { type: Platform },\n    { type: InputModalityDetector },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FOCUS_MONITOR_DEFAULT_OPTIONS,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(FocusMonitor, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc0.NgZone }, { type: ngcc1.Platform }, { type: InputModalityDetector }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [FOCUS_MONITOR_DEFAULT_OPTIONS]\n            }] }]; }, null); })();\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n    constructor(_elementRef, _focusMonitor) {\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n    }\n    ngAfterViewInit() {\n        const element = this._elementRef.nativeElement;\n        this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => this.cdkFocusChange.emit(origin));\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        if (this._monitorSubscription) {\n            this._monitorSubscription.unsubscribe();\n        }\n    }\n}\nCdkMonitorFocus.fac = function CdkMonitorFocus_Factory(t) { return new (t || CdkMonitorFocus)(ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(FocusMonitor)); };\nCdkMonitorFocus.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkMonitorFocus, selectors: [[\"\", \"cdkMonitorElementFocus\", \"\"], [\"\", \"cdkMonitorSubtreeFocus\", \"\"]], outputs: { cdkFocusChange: \"cdkFocusChange\" } });\nCdkMonitorFocus.ctorParameters = () => [\n    { type: ElementRef },\n    { type: FocusMonitor }\n];\nCdkMonitorFocus.propDecorators = {\n    cdkFocusChange: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkMonitorFocus, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]'\n            }]\n    }], function () { return [{ type: ngcc0.ElementRef }, { type: FocusMonitor }]; }, { cdkFocusChange: [{\n            type: Output\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\nclass HighContrastModeDetector {\n    constructor(_platform, document) {\n        this._platform = _platform;\n        this._document = document;\n    }\n    /** Gets the current high-contrast-mode for the page. */\n    getHighContrastMode() {\n        if (!this._platform.isBrowser) {\n            return 0 /* NONE */;\n        }\n        // Create a test element with an arbitrary background-color that is neither black nor\n        // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n        // appending the test element to the DOM does not affect layout by absolutely positioning it\n        const testElement = this._document.createElement('div');\n        testElement.style.backgroundColor = 'rgb(1,2,3)';\n        testElement.style.position = 'absolute';\n        this._document.body.appendChild(testElement);\n        // Get the computed style for the background color, collapsing spaces to normalize between\n        // browsers. Once we get this color, we no longer need the test element. Access the `window`\n        // via the document so we can fake it in tests. Note that we have extra null checks, because\n        // this logic will likely run during app bootstrap and throwing can break the entire app.\n        const documentWindow = this._document.defaultView || window;\n        const computedStyle = (documentWindow && documentWindow.getComputedStyle) ?\n            documentWindow.getComputedStyle(testElement) : null;\n        const computedColor = (computedStyle && computedStyle.backgroundColor || '').replace(/ /g, '');\n        this._document.body.removeChild(testElement);\n        switch (computedColor) {\n            case 'rgb(0,0,0)': return 2 /* WHITE_ON_BLACK */;\n            case 'rgb(255,255,255)': return 1 /* BLACK_ON_WHITE */;\n        }\n        return 0 /* NONE */;\n    }\n    /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n    _applyBodyHighContrastModeCssClasses() {\n        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {\n            const bodyClasses = this._document.body.classList;\n            // IE11 doesn't support `classList` operations with multiple arguments\n            bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n            bodyClasses.remove(BLACK_ON_WHITE_CSS_CLASS);\n            bodyClasses.remove(WHITE_ON_BLACK_CSS_CLASS);\n            this._hasCheckedHighContrastMode = true;\n            const mode = this.getHighContrastMode();\n            if (mode === 1 /* BLACK_ON_WHITE */) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                bodyClasses.add(BLACK_ON_WHITE_CSS_CLASS);\n            }\n            else if (mode === 2 /* WHITE_ON_BLACK */) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                bodyClasses.add(WHITE_ON_BLACK_CSS_CLASS);\n            }\n        }\n    }\n}\nHighContrastModeDetector.fac = function HighContrastModeDetector_Factory(t) { return new (t || HighContrastModeDetector)(ngcc0.inject(ngcc1.Platform), ngcc0.inject(DOCUMENT)); };\nHighContrastModeDetector.prov = i0.defineInjectable({ factory: function HighContrastModeDetector_Factory() { return new HighContrastModeDetector(i0.inject(i1.Platform), i0.inject(i2.DOCUMENT)); }, token: HighContrastModeDetector, providedIn: \"root\" });\nHighContrastModeDetector.ctorParameters = () => [\n    { type: Platform },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(HighContrastModeDetector, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc1.Platform }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass A11yModule {\n    constructor(highContrastModeDetector) {\n        highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n    }\n}\nA11yModule.fac = function A11yModule_Factory(t) { return new (t || A11yModule)(ngcc0.inject(HighContrastModeDetector)); };\nA11yModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: A11yModule });\nA11yModule.inj = /*@__PURE__*/ ngcc0.defineInjector({ imports: [[PlatformModule, ObserversModule]] });\nA11yModule.ctorParameters = () => [\n    { type: HighContrastModeDetector }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(A11yModule, [{\n        type: NgModule,\n        args: [{\n                imports: [PlatformModule, ObserversModule],\n                declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]\n            }]\n    }], function () { return [{ type: HighContrastModeDetector }]; }, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(A11yModule, { declarations: function () { return [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]; }, imports: function () { return [PlatformModule, ObserversModule]; }, exports: function () { return [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]; } }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { A11yModule, ActiveDescendantKeyManager, AriaDescriber, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, CDK_DESCRIBEDBY_ID_PREFIX, CdkAriaLive, CdkMonitorFocus, CdkTrapFocus, ConfigurableFocusTrap, ConfigurableFocusTrapFactory, EventListenerFocusTrapInertStrategy, FOCUS_MONITOR_DEFAULT_OPTIONS, FOCUS_TRAP_INERT_STRATEGY, FocusKeyManager, FocusMonitor, FocusTrap, FocusTrapFactory, HighContrastModeDetector, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, INPUT_MODALITY_DETECTOR_OPTIONS, InputModalityDetector, InteractivityChecker, IsFocusableConfig, LIVE_ANNOUNCER_DEFAULT_OPTIONS, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, ListKeyManager, LiveAnnouncer, MESSAGES_CONTAINER_ID, isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader, FocusTrapManager as angular_material_src_cdk_a11y_a11y_a };\n\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, EventEmitter, Injectable, Optional, Inject, Directive, Output, Input, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\nimport * as ngcc0 from '@angular/core';\nconst DIR_DOCUMENT = new InjectionToken('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/** @docs-private */\nfunction DIR_DOCUMENT_FACTORY() {\n    return inject(DOCUMENT);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nclass Directionality {\n    constructor(_document) {\n        /** The current 'ltr' or 'rtl' value. */\n        this.value = 'ltr';\n        /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            const bodyDir = _document.body ? _document.body.dir : null;\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            const value = bodyDir || htmlDir;\n            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\n        }\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDirectionality.fac = function Directionality_Factory(t) { return new (t || Directionality)(ngcc0.inject(DIR_DOCUMENT, 8)); };\nDirectionality.prov = i0.defineInjectable({ factory: function Directionality_Factory() { return new Directionality(i0.inject(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\nDirectionality.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(Directionality, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [DIR_DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n    constructor() {\n        /** Normalized direction that accounts for invalid/unsupported values. */\n        this._dir = 'ltr';\n        /** Whether the `value` has been set to its initial value. */\n        this._isInitialized = false;\n        /** Event emitted when the direction changes. */\n        this.change = new EventEmitter();\n    }\n    /** @docs-private */\n    get dir() { return this._dir; }\n    set dir(value) {\n        const old = this._dir;\n        const normalizedValue = value ? value.toLowerCase() : value;\n        this._rawDir = value;\n        this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\n        if (old !== this._dir && this._isInitialized) {\n            this.change.emit(this._dir);\n        }\n    }\n    /** Current layout direction of the element. */\n    get value() { return this.dir; }\n    /** Initialize once default value has been set. */\n    ngAfterContentInit() {\n        this._isInitialized = true;\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDir.fac = function Dir_Factory(t) { return new (t || Dir)(); };\nDir.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: Dir, selectors: [[\"\", \"dir\", \"\"]], hostVars: 1, hostBindings: function Dir_HostBindings(rf, ctx) { if (rf & 2) {\n        ngcc0.attribute(\"dir\", ctx._rawDir);\n    } }, inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, exportAs: [\"dir\"], features: [ngcc0.ProvidersFeature([{ provide: Directionality, useExisting: Dir }])] });\nDir.propDecorators = {\n    change: [{ type: Output, args: ['dirChange',] }],\n    dir: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(Dir, [{\n        type: Directive,\n        args: [{\n                selector: '[dir]',\n                providers: [{ provide: Directionality, useExisting: Dir }],\n                host: { '[attr.dir]': '_rawDir' },\n                exportAs: 'dir'\n            }]\n    }], function () { return []; }, { change: [{\n            type: Output,\n            args: ['dirChange']\n        }], dir: [{\n            type: Input\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass BidiModule {\n}\nBidiModule.fac = function BidiModule_Factory(t) { return new (t || BidiModule)(); };\nBidiModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: BidiModule });\nBidiModule.inj = /*@__PURE__*/ ngcc0.defineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(BidiModule, [{\n        type: NgModule,\n        args: [{\n                exports: [Dir],\n                declarations: [Dir]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(BidiModule, { declarations: [Dir], exports: [Dir] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BidiModule, DIR_DOCUMENT, Dir, Directionality, DIR_DOCUMENT_FACTORY as angular_material_src_cdk_bidi_bidi_a };\n\n","import { isObservable, of, Subject } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken } from '@angular/core';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ngcc0 from '@angular/core';\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource.\n    return value && typeof value.connect === 'function';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return isObservable(this._data) ? this._data : of(this._data);\n    }\n    disconnect() { }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n                operation = 1 /* INSERTED */;\n            }\n            else if (currentIndex == null) {\n                viewContainerRef.remove(adjustedPreviousIndex);\n                operation = 3 /* REMOVED */;\n            }\n            else {\n                view = viewContainerRef.get(adjustedPreviousIndex);\n                viewContainerRef.move(view, currentIndex);\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n    constructor() {\n        /**\n         * The size of the cache used to store unused views.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n         */\n        this.viewCacheSize = 20;\n        /**\n         * View cache that stores embedded view instances that have been previously stamped out,\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\n         * creating brand new ones.\n         *\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n         */\n        this._viewCache = [];\n    }\n    /** Apply changes to the DOM. */\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) { // Item added.\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;\n            }\n            else if (currentIndex == null) { // Item removed.\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n                operation = 3 /* REMOVED */;\n            }\n            else { // Item moved.\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n        for (const view of this._viewCache) {\n            view.destroy();\n        }\n        this._viewCache = [];\n    }\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n        if (cachedView) {\n            cachedView.context.$implicit = value;\n            return undefined;\n        }\n        const viewArgs = viewArgsFactory();\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n    }\n    /** Detaches the view at the given index and inserts into the view cache. */\n    _detachAndCacheView(index, viewContainerRef) {\n        const detachedView = viewContainerRef.detach(index);\n        this._maybeCacheView(detachedView, viewContainerRef);\n    }\n    /** Moves view at the previous index to the current index. */\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n        const view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = value;\n        return view;\n    }\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    _maybeCacheView(view, viewContainerRef) {\n        if (this._viewCache.length < this.viewCacheSize) {\n            this._viewCache.push(view);\n        }\n        else {\n            const index = viewContainerRef.indexOf(view);\n            // The host component could remove views from the container outside of\n            // the view repeater. It's unlikely this will occur, but just in case,\n            // destroy the view on its own, otherwise destroy it through the\n            // container to ensure that all the references are removed.\n            if (index === -1) {\n                view.destroy();\n            }\n            else {\n                viewContainerRef.remove(index);\n            }\n        }\n    }\n    /** Inserts a recycled view from the cache at the given index. */\n    _insertViewFromCache(index, viewContainerRef) {\n        const cachedView = this._viewCache.pop();\n        if (cachedView) {\n            viewContainerRef.insert(cachedView, index);\n        }\n        return cachedView || null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new Subject();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    /**\n     * Selects a value or an array of values.\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Deselects a value or an array of values.\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     */\n    toggle(value) {\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     */\n    clear() {\n        this._unmarkAll();\n        this._emitChangeEvent();\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(value);\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            this._selection.add(value);\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n    constructor() {\n        this._listeners = [];\n    }\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id, name) {\n        for (let listener of this._listeners) {\n            listener(id, name);\n        }\n    }\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener) {\n        this._listeners.push(listener);\n        return () => {\n            this._listeners = this._listeners.filter((registered) => {\n                return listener !== registered;\n            });\n        };\n    }\n    ngOnDestroy() {\n        this._listeners = [];\n    }\n}\nUniqueSelectionDispatcher.fac = function UniqueSelectionDispatcher_Factory(t) { return new (t || UniqueSelectionDispatcher)(); };\nUniqueSelectionDispatcher.prov = i0.defineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(UniqueSelectionDispatcher, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return []; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, getMultipleValuesInSingleSelectionError, isDataSource };\n\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAC_ENTER = 3;\nconst BACKSPACE = 8;\nconst TAB = 9;\nconst NUM_CENTER = 12;\nconst ENTER = 13;\nconst SHIFT = 16;\nconst CONTROL = 17;\nconst ALT = 18;\nconst PAUSE = 19;\nconst CAPS_LOCK = 20;\nconst ESCAPE = 27;\nconst SPACE = 32;\nconst PAGE_UP = 33;\nconst PAGE_DOWN = 34;\nconst END = 35;\nconst HOME = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\nconst PLUS_SIGN = 43;\nconst PRINT_SCREEN = 44;\nconst INSERT = 45;\nconst DELETE = 46;\nconst ZERO = 48;\nconst ONE = 49;\nconst TWO = 50;\nconst THREE = 51;\nconst FOUR = 52;\nconst FIVE = 53;\nconst SIX = 54;\nconst SEVEN = 55;\nconst EIGHT = 56;\nconst NINE = 57;\nconst FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nconst FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nconst QUESTION_MARK = 63;\nconst AT_SIGN = 64;\nconst A = 65;\nconst B = 66;\nconst C = 67;\nconst D = 68;\nconst E = 69;\nconst F = 70;\nconst G = 71;\nconst H = 72;\nconst I = 73;\nconst J = 74;\nconst K = 75;\nconst L = 76;\nconst M = 77;\nconst N = 78;\nconst O = 79;\nconst P = 80;\nconst Q = 81;\nconst R = 82;\nconst S = 83;\nconst T = 84;\nconst U = 85;\nconst V = 86;\nconst W = 87;\nconst X = 88;\nconst Y = 89;\nconst Z = 90;\nconst META = 91; // WIN_KEY_LEFT\nconst MAC_WK_CMD_LEFT = 91;\nconst MAC_WK_CMD_RIGHT = 93;\nconst CONTEXT_MENU = 93;\nconst NUMPAD_ZERO = 96;\nconst NUMPAD_ONE = 97;\nconst NUMPAD_TWO = 98;\nconst NUMPAD_THREE = 99;\nconst NUMPAD_FOUR = 100;\nconst NUMPAD_FIVE = 101;\nconst NUMPAD_SIX = 102;\nconst NUMPAD_SEVEN = 103;\nconst NUMPAD_EIGHT = 104;\nconst NUMPAD_NINE = 105;\nconst NUMPAD_MULTIPLY = 106;\nconst NUMPAD_PLUS = 107;\nconst NUMPAD_MINUS = 109;\nconst NUMPAD_PERIOD = 110;\nconst NUMPAD_DIVIDE = 111;\nconst F1 = 112;\nconst F2 = 113;\nconst F3 = 114;\nconst F4 = 115;\nconst F5 = 116;\nconst F6 = 117;\nconst F7 = 118;\nconst F8 = 119;\nconst F9 = 120;\nconst F10 = 121;\nconst F11 = 122;\nconst F12 = 123;\nconst NUM_LOCK = 144;\nconst SCROLL_LOCK = 145;\nconst FIRST_MEDIA = 166;\nconst FF_MINUS = 173;\nconst MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nconst VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nconst VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nconst FF_MUTE = 181;\nconst FF_VOLUME_DOWN = 182;\nconst LAST_MEDIA = 183;\nconst FF_VOLUME_UP = 183;\nconst SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nconst EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nconst COMMA = 188;\nconst DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nconst PERIOD = 190;\nconst SLASH = 191;\nconst APOSTROPHE = 192;\nconst TILDE = 192;\nconst OPEN_SQUARE_BRACKET = 219;\nconst BACKSLASH = 220;\nconst CLOSE_SQUARE_BRACKET = 221;\nconst SINGLE_QUOTE = 222;\nconst MAC_META = 224;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { A, ALT, APOSTROPHE, AT_SIGN, B, BACKSLASH, BACKSPACE, C, CAPS_LOCK, CLOSE_SQUARE_BRACKET, COMMA, CONTEXT_MENU, CONTROL, D, DASH, DELETE, DOWN_ARROW, E, EIGHT, END, ENTER, EQUALS, ESCAPE, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FF_EQUALS, FF_MINUS, FF_MUTE, FF_SEMICOLON, FF_VOLUME_DOWN, FF_VOLUME_UP, FIRST_MEDIA, FIVE, FOUR, G, H, HOME, I, INSERT, J, K, L, LAST_MEDIA, LEFT_ARROW, M, MAC_ENTER, MAC_META, MAC_WK_CMD_LEFT, MAC_WK_CMD_RIGHT, META, MUTE, N, NINE, NUMPAD_DIVIDE, NUMPAD_EIGHT, NUMPAD_FIVE, NUMPAD_FOUR, NUMPAD_MINUS, NUMPAD_MULTIPLY, NUMPAD_NINE, NUMPAD_ONE, NUMPAD_PERIOD, NUMPAD_PLUS, NUMPAD_SEVEN, NUMPAD_SIX, NUMPAD_THREE, NUMPAD_TWO, NUMPAD_ZERO, NUM_CENTER, NUM_LOCK, O, ONE, OPEN_SQUARE_BRACKET, P, PAGE_DOWN, PAGE_UP, PAUSE, PERIOD, PLUS_SIGN, PRINT_SCREEN, Q, QUESTION_MARK, R, RIGHT_ARROW, S, SCROLL_LOCK, SEMICOLON, SEVEN, SHIFT, SINGLE_QUOTE, SIX, SLASH, SPACE, T, TAB, THREE, TILDE, TWO, U, UP_ARROW, V, VOLUME_DOWN, VOLUME_UP, W, X, Y, Z, ZERO, hasModifierKey };\n\n","import { coerceElement, coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, ElementRef, NgZone, Output, Input, NgModule } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\nimport * as ngcc0 from '@angular/core';\nclass MutationObserverFactory {\n    create(callback) {\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n    }\n}\nMutationObserverFactory.fac = function MutationObserverFactory_Factory(t) { return new (t || MutationObserverFactory)(); };\nMutationObserverFactory.prov = i0.defineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(MutationObserverFactory, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], null, null); })();\n/** An injectable service that allows watching elements for changes to their content. */\nclass ContentObserver {\n    constructor(_mutationObserverFactory) {\n        this._mutationObserverFactory = _mutationObserverFactory;\n        /** Keeps track of the existing MutationObservers so they can be reused. */\n        this._observedElements = new Map();\n    }\n    ngOnDestroy() {\n        this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n    }\n    observe(elementOrRef) {\n        const element = coerceElement(elementOrRef);\n        return new Observable((observer) => {\n            const stream = this._observeElement(element);\n            const subscription = stream.subscribe(observer);\n            return () => {\n                subscription.unsubscribe();\n                this._unobserveElement(element);\n            };\n        });\n    }\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    _observeElement(element) {\n        if (!this._observedElements.has(element)) {\n            const stream = new Subject();\n            const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n            if (observer) {\n                observer.observe(element, {\n                    characterData: true,\n                    childList: true,\n                    subtree: true\n                });\n            }\n            this._observedElements.set(element, { observer, stream, count: 1 });\n        }\n        else {\n            this._observedElements.get(element).count++;\n        }\n        return this._observedElements.get(element).stream;\n    }\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    _unobserveElement(element) {\n        if (this._observedElements.has(element)) {\n            this._observedElements.get(element).count--;\n            if (!this._observedElements.get(element).count) {\n                this._cleanupObserver(element);\n            }\n        }\n    }\n    /** Clean up the underlying MutationObserver for the specified element. */\n    _cleanupObserver(element) {\n        if (this._observedElements.has(element)) {\n            const { observer, stream } = this._observedElements.get(element);\n            if (observer) {\n                observer.disconnect();\n            }\n            stream.complete();\n            this._observedElements.delete(element);\n        }\n    }\n}\nContentObserver.fac = function ContentObserver_Factory(t) { return new (t || ContentObserver)(ngcc0.inject(MutationObserverFactory)); };\nContentObserver.prov = i0.defineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(i0.inject(MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\nContentObserver.ctorParameters = () => [\n    { type: MutationObserverFactory }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContentObserver, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: MutationObserverFactory }]; }, null); })();\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nclass CdkObserveContent {\n    constructor(_contentObserver, _elementRef, _ngZone) {\n        this._contentObserver = _contentObserver;\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        /** Event emitted for each change in the element's content. */\n        this.event = new EventEmitter();\n        this._disabled = false;\n        this._currentSubscription = null;\n    }\n    /**\n     * Whether observing content is disabled. This option can be used\n     * to disconnect the underlying MutationObserver until it is needed.\n     */\n    get disabled() { return this._disabled; }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._disabled ? this._unsubscribe() : this._subscribe();\n    }\n    /** Debounce interval for emitting the changes. */\n    get debounce() { return this._debounce; }\n    set debounce(value) {\n        this._debounce = coerceNumberProperty(value);\n        this._subscribe();\n    }\n    ngAfterContentInit() {\n        if (!this._currentSubscription && !this.disabled) {\n            this._subscribe();\n        }\n    }\n    ngOnDestroy() {\n        this._unsubscribe();\n    }\n    _subscribe() {\n        this._unsubscribe();\n        const stream = this._contentObserver.observe(this._elementRef);\n        // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n        // Consider brining it back inside the zone next time we're making breaking changes.\n        // Bringing it back inside can cause things like infinite change detection loops and changed\n        // after checked errors if people's code isn't handling it properly.\n        this._ngZone.runOutsideAngular(() => {\n            this._currentSubscription =\n                (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n        });\n    }\n    _unsubscribe() {\n        var _a;\n        (_a = this._currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n}\nCdkObserveContent.fac = function CdkObserveContent_Factory(t) { return new (t || CdkObserveContent)(ngcc0.directiveInject(ContentObserver), ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(ngcc0.NgZone)); };\nCdkObserveContent.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkObserveContent, selectors: [[\"\", \"cdkObserveContent\", \"\"]], inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\"], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"] });\nCdkObserveContent.ctorParameters = () => [\n    { type: ContentObserver },\n    { type: ElementRef },\n    { type: NgZone }\n];\nCdkObserveContent.propDecorators = {\n    event: [{ type: Output, args: ['cdkObserveContent',] }],\n    disabled: [{ type: Input, args: ['cdkObserveContentDisabled',] }],\n    debounce: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkObserveContent, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkObserveContent]',\n                exportAs: 'cdkObserveContent'\n            }]\n    }], function () { return [{ type: ContentObserver }, { type: ngcc0.ElementRef }, { type: ngcc0.NgZone }]; }, { event: [{\n            type: Output,\n            args: ['cdkObserveContent']\n        }], disabled: [{\n            type: Input,\n            args: ['cdkObserveContentDisabled']\n        }], debounce: [{\n            type: Input\n        }] }); })();\nclass ObserversModule {\n}\nObserversModule.fac = function ObserversModule_Factory(t) { return new (t || ObserversModule)(); };\nObserversModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: ObserversModule });\nObserversModule.inj = /*@__PURE__*/ ngcc0.defineInjector({ providers: [MutationObserverFactory] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ObserversModule, [{\n        type: NgModule,\n        args: [{\n                exports: [CdkObserveContent],\n                declarations: [CdkObserveContent],\n                providers: [MutationObserverFactory]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(ObserversModule, { declarations: [CdkObserveContent], exports: [CdkObserveContent] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkObserveContent, ContentObserver, MutationObserverFactory, ObserversModule };\n\n","import * as i1 from '@angular/cdk/scrolling';\nimport { ScrollDispatcher, ViewportRuler, ScrollingModule } from '@angular/cdk/scrolling';\nimport * as ngcc0 from '@angular/core';\nimport * as ngcc1 from '@angular/cdk/scrolling';\nimport * as ngcc2 from '@angular/cdk/platform';\nimport * as ngcc3 from '@angular/cdk/bidi';\nimport * as ngcc4 from '@angular/common';\nexport { CdkScrollable, ScrollDispatcher, ViewportRuler } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/common';\nimport { DOCUMENT, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, NgZone, Inject, Optional, ElementRef, ApplicationRef, ComponentFactoryResolver, Injector, InjectionToken, Directive, EventEmitter, TemplateRef, ViewContainerRef, Input, Output, NgModule } from '@angular/core';\nimport { coerceCssPixelValue, coerceArray, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i2 from '@angular/cdk/platform';\nimport { supportsScrollBehavior, _getEventTarget, Platform } from '@angular/cdk/platform';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { Subject, Subscription, merge } from 'rxjs';\nimport { take, takeUntil, takeWhile } from 'rxjs/operators';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst scrollBehaviorSupported = supportsScrollBehavior();\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n    constructor(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach() { }\n    /** Blocks page-level scroll while the attached overlay is open. */\n    enable() {\n        if (this._canBeEnabled()) {\n            const root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    }\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    disable() {\n        if (this._isEnabled) {\n            const html = this._document.documentElement;\n            const body = this._document.body;\n            const htmlStyle = html.style;\n            const bodyStyle = body.style;\n            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n            this._isEnabled = false;\n            htmlStyle.left = this._previousHTMLStyles.left;\n            htmlStyle.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n            // because it can throw off feature detections in `supportsScrollBehavior` which\n            // checks for `'scrollBehavior' in documentElement.style`.\n            if (scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n            }\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            if (scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n                bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n            }\n        }\n    }\n    _canBeEnabled() {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        const html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        const body = this._document.body;\n        const viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n    constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /** Detaches the overlay ref and disables the scroll strategy. */\n        this._detach = () => {\n            this.disable();\n            if (this._overlayRef.hasAttached()) {\n                this._ngZone.run(() => this._overlayRef.detach());\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables the closing of the attached overlay on scroll. */\n    enable() {\n        if (this._scrollSubscription) {\n            return;\n        }\n        const stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(() => {\n                const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n                    this._detach();\n                }\n                else {\n                    this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    }\n    /** Disables the closing the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n    /** Does nothing, as this scroll strategy is a no-op. */\n    enable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    disable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    attach() { }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(containerBounds => {\n        const outsideAbove = element.bottom < containerBounds.top;\n        const outsideBelow = element.top > containerBounds.bottom;\n        const outsideLeft = element.right < containerBounds.left;\n        const outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(scrollContainerRect => {\n        const clippedAbove = element.top < scrollContainerRect.top;\n        const clippedBelow = element.bottom > scrollContainerRect.bottom;\n        const clippedLeft = element.left < scrollContainerRect.left;\n        const clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables repositioning of the attached overlay on scroll. */\n    enable() {\n        if (!this._scrollSubscription) {\n            const throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n                this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (this._config && this._config.autoClose) {\n                    const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n                    const { width, height } = this._viewportRuler.getViewportSize();\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    const parentRects = [{ width, height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        this.disable();\n                        this._ngZone.run(() => this._overlayRef.detach());\n                    }\n                }\n            });\n        }\n    }\n    /** Disables repositioning of the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /** Do nothing on scroll. */\n        this.noop = () => new NoopScrollStrategy();\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n        /** Block scrolling. */\n        this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n        this._document = document;\n    }\n}\nScrollStrategyOptions.fac = function ScrollStrategyOptions_Factory(t) { return new (t || ScrollStrategyOptions)(ngcc0.inject(ngcc1.ScrollDispatcher), ngcc0.inject(ngcc1.ViewportRuler), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(DOCUMENT)); };\nScrollStrategyOptions.prov = i0.defineInjectable({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(i0.inject(i1.ScrollDispatcher), i0.inject(i1.ViewportRuler), i0.inject(i0.NgZone), i0.inject(i1$1.DOCUMENT)); }, token: ScrollStrategyOptions, providedIn: \"root\" });\nScrollStrategyOptions.ctorParameters = () => [\n    { type: ScrollDispatcher },\n    { type: ViewportRuler },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ScrollStrategyOptions, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc1.ScrollDispatcher }, { type: ngcc1.ViewportRuler }, { type: ngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n    constructor(config) {\n        /** Strategy to be used when handling scroll events while the overlay is open. */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /** Custom class to add to the overlay pane. */\n        this.panelClass = '';\n        /** Whether the overlay has a backdrop. */\n        this.hasBackdrop = false;\n        /** Custom class to add to the backdrop */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.disposeOnNavigation = false;\n        if (config) {\n            // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n            // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n            // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n            const configKeys = Object.keys(config);\n            for (const key of configKeys) {\n                if (config[key] !== undefined) {\n                    // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                    // as \"I don't know *which* key this is, so the only valid value is the intersection\n                    // of all the posible values.\" In this case, that happens to be `undefined`. TypeScript\n                    // is not smart enough to see that the right-hand-side is actually an access of the same\n                    // exact type with the same exact key, meaning that the value type must be identical.\n                    // So we use `any` to work around this.\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n    constructor(origin, overlay, \n    /** Offset along the X axis. */\n    offsetX, \n    /** Offset along the Y axis. */\n    offsetY, \n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.panelClass = panelClass;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {\n}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n    constructor(\n    /** The position used as a result of this change. */\n    connectionPair, \n    /** @docs-private */\n    scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n}\nConnectedOverlayPositionChange.ctorParameters = () => [\n    { type: ConnectionPositionPair },\n    { type: ScrollingVisibility, decorators: [{ type: Optional }] }\n];\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n    if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"top\", \"bottom\" or \"center\".`);\n    }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n    if (value !== 'start' && value !== 'end' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"start\", \"end\" or \"center\".`);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass BaseOverlayDispatcher {\n    constructor(document) {\n        /** Currently attached overlays in the order they were attached. */\n        this._attachedOverlays = [];\n        this._document = document;\n    }\n    ngOnDestroy() {\n        this.detach();\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        // Ensure that we don't get the same overlay multiple times.\n        this.remove(overlayRef);\n        this._attachedOverlays.push(overlayRef);\n    }\n    /** Remove an overlay from the list of attached overlay refs. */\n    remove(overlayRef) {\n        const index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this.detach();\n        }\n    }\n}\nBaseOverlayDispatcher.fac = function BaseOverlayDispatcher_Factory(t) { return new (t || BaseOverlayDispatcher)(ngcc0.inject(DOCUMENT)); };\nBaseOverlayDispatcher.prov = i0.defineInjectable({ factory: function BaseOverlayDispatcher_Factory() { return new BaseOverlayDispatcher(i0.inject(i1$1.DOCUMENT)); }, token: BaseOverlayDispatcher, providedIn: \"root\" });\nBaseOverlayDispatcher.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(BaseOverlayDispatcher, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n    constructor(document) {\n        super(document);\n        /** Keyboard event listener that will be attached to the body. */\n        this._keydownListener = (event) => {\n            const overlays = this._attachedOverlays;\n            for (let i = overlays.length - 1; i > -1; i--) {\n                // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                // We want to target the most recent overlay, rather than trying to match where the event came\n                // from, because some components might open an overlay, but keep focus on a trigger element\n                // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                // because we don't want overlays that don't handle keyboard events to block the ones below\n                // them that do.\n                if (overlays[i]._keydownEvents.observers.length > 0) {\n                    overlays[i]._keydownEvents.next(event);\n                    break;\n                }\n            }\n        };\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        super.add(overlayRef);\n        // Lazily start dispatcher once first overlay is added\n        if (!this._isAttached) {\n            this._document.body.addEventListener('keydown', this._keydownListener);\n            this._isAttached = true;\n        }\n    }\n    /** Detaches the global keyboard event listener. */\n    detach() {\n        if (this._isAttached) {\n            this._document.body.removeEventListener('keydown', this._keydownListener);\n            this._isAttached = false;\n        }\n    }\n}\nOverlayKeyboardDispatcher.fac = function OverlayKeyboardDispatcher_Factory(t) { return new (t || OverlayKeyboardDispatcher)(ngcc0.inject(DOCUMENT)); };\nOverlayKeyboardDispatcher.prov = i0.defineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(i0.inject(i1$1.DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: \"root\" });\nOverlayKeyboardDispatcher.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(OverlayKeyboardDispatcher, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n    constructor(document, _platform) {\n        super(document);\n        this._platform = _platform;\n        this._cursorStyleIsSet = false;\n        /** Click event listener that will be attached to the body propagate phase. */\n        this._clickListener = (event) => {\n            const target = _getEventTarget(event);\n            // We copy the array because the original may be modified asynchronously if the\n            // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n            // the for loop.\n            const overlays = this._attachedOverlays.slice();\n            // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n            // We want to target all overlays for which the click could be considered as outside click.\n            // As soon as we reach an overlay for which the click is not outside click we break off\n            // the loop.\n            for (let i = overlays.length - 1; i > -1; i--) {\n                const overlayRef = overlays[i];\n                if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n                    continue;\n                }\n                // If it's a click inside the overlay, just break - we should do nothing\n                // If it's an outside click dispatch the mouse event, and proceed with the next overlay\n                if (overlayRef.overlayElement.contains(target)) {\n                    break;\n                }\n                overlayRef._outsidePointerEvents.next(event);\n            }\n        };\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        super.add(overlayRef);\n        // Safari on iOS does not generate click events for non-interactive\n        // elements. However, we want to receive a click for any element outside\n        // the overlay. We can force a \"clickable\" state by setting\n        // `cursor: pointer` on the document body. See:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n        // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n        if (!this._isAttached) {\n            const body = this._document.body;\n            body.addEventListener('click', this._clickListener, true);\n            body.addEventListener('auxclick', this._clickListener, true);\n            body.addEventListener('contextmenu', this._clickListener, true);\n            // click event is not fired on iOS. To make element \"clickable\" we are\n            // setting the cursor to pointer\n            if (this._platform.IOS && !this._cursorStyleIsSet) {\n                this._cursorOriginalValue = body.style.cursor;\n                body.style.cursor = 'pointer';\n                this._cursorStyleIsSet = true;\n            }\n            this._isAttached = true;\n        }\n    }\n    /** Detaches the global keyboard event listener. */\n    detach() {\n        if (this._isAttached) {\n            const body = this._document.body;\n            body.removeEventListener('click', this._clickListener, true);\n            body.removeEventListener('auxclick', this._clickListener, true);\n            body.removeEventListener('contextmenu', this._clickListener, true);\n            if (this._platform.IOS && this._cursorStyleIsSet) {\n                body.style.cursor = this._cursorOriginalValue;\n                this._cursorStyleIsSet = false;\n            }\n            this._isAttached = false;\n        }\n    }\n}\nOverlayOutsideClickDispatcher.fac = function OverlayOutsideClickDispatcher_Factory(t) { return new (t || OverlayOutsideClickDispatcher)(ngcc0.inject(DOCUMENT), ngcc0.inject(ngcc2.Platform)); };\nOverlayOutsideClickDispatcher.prov = i0.defineInjectable({ factory: function OverlayOutsideClickDispatcher_Factory() { return new OverlayOutsideClickDispatcher(i0.inject(i1$1.DOCUMENT), i0.inject(i2.Platform)); }, token: OverlayOutsideClickDispatcher, providedIn: \"root\" });\nOverlayOutsideClickDispatcher.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Platform }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(OverlayOutsideClickDispatcher, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ngcc2.Platform }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst globalsForTest = (typeof window !== 'undefined' ? window : {});\n/**\n * Whether we're in a testing environment.\n * TODO(crisbeto): remove this once we have an overlay testing module or Angular starts tearing\n * down the testing `NgModule` (see https://github.com/angular/angular/issues/18831).\n */\nconst isTestEnvironment = (typeof globalsForTest.__karma__ !== 'undefined' && !!globalsForTest.__karma__) ||\n    (typeof globalsForTest.jasmine !== 'undefined' && !!globalsForTest.jasmine) ||\n    (typeof globalsForTest.jest !== 'undefined' && !!globalsForTest.jest) ||\n    (typeof globalsForTest.Mocha !== 'undefined' && !!globalsForTest.Mocha);\n/** Container inside which all overlays will render. */\nclass OverlayContainer {\n    constructor(document, _platform) {\n        this._platform = _platform;\n        this._document = document;\n    }\n    ngOnDestroy() {\n        const container = this._containerElement;\n        if (container && container.parentNode) {\n            container.parentNode.removeChild(container);\n        }\n    }\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    getContainerElement() {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    }\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    _createContainer() {\n        const containerClass = 'cdk-overlay-container';\n        if (this._platform.isBrowser || isTestEnvironment) {\n            const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` +\n                `.${containerClass}[platform=\"test\"]`);\n            // Remove any old containers from the opposite platform.\n            // This can happen when transitioning from the server to the client.\n            for (let i = 0; i < oppositePlatformContainers.length; i++) {\n                oppositePlatformContainers[i].parentNode.removeChild(oppositePlatformContainers[i]);\n            }\n        }\n        const container = this._document.createElement('div');\n        container.classList.add(containerClass);\n        // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n        // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n        // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n        // To mitigate the problem we made it so that only containers from a different platform are\n        // cleared, but the side-effect was that people started depending on the overly-aggressive\n        // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n        // module which does the cleanup, we try to detect that we're in a test environment and we\n        // always clear the container. See #17006.\n        // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n        if (isTestEnvironment) {\n            container.setAttribute('platform', 'test');\n        }\n        else if (!this._platform.isBrowser) {\n            container.setAttribute('platform', 'server');\n        }\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    }\n}\nOverlayContainer.fac = function OverlayContainer_Factory(t) { return new (t || OverlayContainer)(ngcc0.inject(DOCUMENT), ngcc0.inject(ngcc2.Platform)); };\nOverlayContainer.prov = i0.defineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(i0.inject(i1$1.DOCUMENT), i0.inject(i2.Platform)); }, token: OverlayContainer, providedIn: \"root\" });\nOverlayContainer.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Platform }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(OverlayContainer, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ngcc2.Platform }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n    constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._host = _host;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._location = _location;\n        this._outsideClickDispatcher = _outsideClickDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        this._locationChanges = Subscription.EMPTY;\n        this._backdropClickHandler = (event) => this._backdropClick.next(event);\n        /** Stream of keydown events dispatched to this overlay. */\n        this._keydownEvents = new Subject();\n        /** Stream of mouse outside events dispatched to this overlay. */\n        this._outsidePointerEvents = new Subject();\n        if (_config.scrollStrategy) {\n            this._scrollStrategy = _config.scrollStrategy;\n            this._scrollStrategy.attach(this);\n        }\n        this._positionStrategy = _config.positionStrategy;\n    }\n    /** The overlay's HTML element */\n    get overlayElement() {\n        return this._pane;\n    }\n    /** The overlay's backdrop HTML element. */\n    get backdropElement() {\n        return this._backdropElement;\n    }\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     */\n    get hostElement() {\n        return this._host;\n    }\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    attach(portal) {\n        let attachResult = this._portalOutlet.attach(portal);\n        // Update the pane element with the given configuration.\n        if (!this._host.parentElement && this._previousHostParent) {\n            this._previousHostParent.appendChild(this._host);\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.attach(this);\n        }\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._scrollStrategy) {\n            this._scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable\n            .pipe(take(1))\n            .subscribe(() => {\n            // The overlay could've been detached before the zone has stabilized.\n            if (this.hasAttached()) {\n                this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, true);\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        if (this._config.disposeOnNavigation) {\n            this._locationChanges = this._location.subscribe(() => this.dispose());\n        }\n        this._outsideClickDispatcher.add(this);\n        return attachResult;\n    }\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    detach() {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._positionStrategy && this._positionStrategy.detach) {\n            this._positionStrategy.detach();\n        }\n        if (this._scrollStrategy) {\n            this._scrollStrategy.disable();\n        }\n        const detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking.\n        this._keyboardDispatcher.remove(this);\n        // Keeping the host element in the DOM can cause scroll jank, because it still gets\n        // rendered, even though it's transparent and unclickable which is why we remove it.\n        this._detachContentWhenStable();\n        this._locationChanges.unsubscribe();\n        this._outsideClickDispatcher.remove(this);\n        return detachmentResult;\n    }\n    /** Cleans up the overlay from the DOM. */\n    dispose() {\n        const isAttached = this.hasAttached();\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._disposeScrollStrategy();\n        this.detachBackdrop();\n        this._locationChanges.unsubscribe();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        this._outsidePointerEvents.complete();\n        this._outsideClickDispatcher.remove(this);\n        if (this._host && this._host.parentNode) {\n            this._host.parentNode.removeChild(this._host);\n            this._host = null;\n        }\n        this._previousHostParent = this._pane = null;\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    }\n    /** Whether the overlay has attached content. */\n    hasAttached() {\n        return this._portalOutlet.hasAttached();\n    }\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    backdropClick() {\n        return this._backdropClick;\n    }\n    /** Gets an observable that emits when the overlay has been attached. */\n    attachments() {\n        return this._attachments;\n    }\n    /** Gets an observable that emits when the overlay has been detached. */\n    detachments() {\n        return this._detachments;\n    }\n    /** Gets an observable of keydown events targeted to this overlay. */\n    keydownEvents() {\n        return this._keydownEvents;\n    }\n    /** Gets an observable of pointer events targeted outside this overlay. */\n    outsidePointerEvents() {\n        return this._outsidePointerEvents;\n    }\n    /** Gets the current overlay configuration, which is immutable. */\n    getConfig() {\n        return this._config;\n    }\n    /** Updates the position of the overlay based on the position strategy. */\n    updatePosition() {\n        if (this._positionStrategy) {\n            this._positionStrategy.apply();\n        }\n    }\n    /** Switches to a new position strategy and updates the overlay position. */\n    updatePositionStrategy(strategy) {\n        if (strategy === this._positionStrategy) {\n            return;\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._positionStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            this.updatePosition();\n        }\n    }\n    /** Update the size properties of the overlay. */\n    updateSize(sizeConfig) {\n        this._config = Object.assign(Object.assign({}, this._config), sizeConfig);\n        this._updateElementSize();\n    }\n    /** Sets the LTR/RTL direction for the overlay. */\n    setDirection(dir) {\n        this._config = Object.assign(Object.assign({}, this._config), { direction: dir });\n        this._updateElementDirection();\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, true);\n        }\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, false);\n        }\n    }\n    /**\n     * Returns the layout direction of the overlay panel.\n     */\n    getDirection() {\n        const direction = this._config.direction;\n        if (!direction) {\n            return 'ltr';\n        }\n        return typeof direction === 'string' ? direction : direction.value;\n    }\n    /** Switches to a new scroll strategy. */\n    updateScrollStrategy(strategy) {\n        if (strategy === this._scrollStrategy) {\n            return;\n        }\n        this._disposeScrollStrategy();\n        this._scrollStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            strategy.enable();\n        }\n    }\n    /** Updates the text direction of the overlay panel. */\n    _updateElementDirection() {\n        this._host.setAttribute('dir', this.getDirection());\n    }\n    /** Updates the size of the overlay element based on the overlay config. */\n    _updateElementSize() {\n        if (!this._pane) {\n            return;\n        }\n        const style = this._pane.style;\n        style.width = coerceCssPixelValue(this._config.width);\n        style.height = coerceCssPixelValue(this._config.height);\n        style.minWidth = coerceCssPixelValue(this._config.minWidth);\n        style.minHeight = coerceCssPixelValue(this._config.minHeight);\n        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n    }\n    /** Toggles the pointer events for the overlay pane element. */\n    _togglePointerEvents(enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n    }\n    /** Attaches a backdrop for this overlay. */\n    _attachBackdrop() {\n        const showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n        }\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._host.parentElement.insertBefore(this._backdropElement, this._host);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', this._backdropClickHandler);\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => {\n                    if (this._backdropElement) {\n                        this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    }\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     */\n    _updateStackingOrder() {\n        if (this._host.nextSibling) {\n            this._host.parentNode.appendChild(this._host);\n        }\n    }\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    detachBackdrop() {\n        let backdropToDetach = this._backdropElement;\n        if (!backdropToDetach) {\n            return;\n        }\n        let timeoutId;\n        let finishDetach = () => {\n            // It may not be attached to anything in certain cases (e.g. unit tests).\n            if (backdropToDetach) {\n                backdropToDetach.removeEventListener('click', this._backdropClickHandler);\n                backdropToDetach.removeEventListener('transitionend', finishDetach);\n                if (backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n            }\n            // It is possible that a new portal has been attached to this overlay since we started\n            // removing the backdrop. If that is the case, only clear the backdrop reference if it\n            // is still the same instance that we started to remove.\n            if (this._backdropElement == backdropToDetach) {\n                this._backdropElement = null;\n            }\n            if (this._config.backdropClass) {\n                this._toggleClasses(backdropToDetach, this._config.backdropClass, false);\n            }\n            clearTimeout(timeoutId);\n        };\n        backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n        this._ngZone.runOutsideAngular(() => {\n            backdropToDetach.addEventListener('transitionend', finishDetach);\n        });\n        // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n        // In this case we make it unclickable and we try to remove it after a delay.\n        backdropToDetach.style.pointerEvents = 'none';\n        // Run this outside the Angular zone because there's nothing that Angular cares about.\n        // If it were to run inside the Angular zone, every test that used Overlay would have to be\n        // either async or fakeAsync.\n        timeoutId = this._ngZone.runOutsideAngular(() => setTimeout(finishDetach, 500));\n    }\n    /** Toggles a single CSS class or an array of classes on an element. */\n    _toggleClasses(element, cssClasses, isAdd) {\n        const classList = element.classList;\n        coerceArray(cssClasses).forEach(cssClass => {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            // Also trying to add an empty string to a DOMTokenList will throw.\n            if (cssClass) {\n                isAdd ? classList.add(cssClass) : classList.remove(cssClass);\n            }\n        });\n    }\n    /** Detaches the overlay content next time the zone stabilizes. */\n    _detachContentWhenStable() {\n        // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n        // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n        // be patched to run inside the zone, which will throw us into an infinite loop.\n        this._ngZone.runOutsideAngular(() => {\n            // We can't remove the host here immediately, because the overlay pane's content\n            // might still be animating. This stream helps us avoid interrupting the animation\n            // by waiting for the pane to become empty.\n            const subscription = this._ngZone.onStable\n                .pipe(takeUntil(merge(this._attachments, this._detachments)))\n                .subscribe(() => {\n                // Needs a couple of checks for the pane and host, because\n                // they may have been removed by the time the zone stabilizes.\n                if (!this._pane || !this._host || this._pane.children.length === 0) {\n                    if (this._pane && this._config.panelClass) {\n                        this._toggleClasses(this._pane, this._config.panelClass, false);\n                    }\n                    if (this._host && this._host.parentElement) {\n                        this._previousHostParent = this._host.parentElement;\n                        this._previousHostParent.removeChild(this._host);\n                    }\n                    subscription.unsubscribe();\n                }\n            });\n        });\n    }\n    /** Disposes of a scroll strategy. */\n    _disposeScrollStrategy() {\n        const scrollStrategy = this._scrollStrategy;\n        if (scrollStrategy) {\n            scrollStrategy.disable();\n            if (scrollStrategy.detach) {\n                scrollStrategy.detach();\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass FlexibleConnectedPositionStrategy {\n    constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n        /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n        this._lastBoundingBoxSize = { width: 0, height: 0 };\n        /** Whether the overlay was pushed in a previous positioning. */\n        this._isPushed = false;\n        /** Whether the overlay can be pushed on-screen on the initial open. */\n        this._canPush = true;\n        /** Whether the overlay can grow via flexible width/height after the initial open. */\n        this._growAfterOpen = false;\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        this._hasFlexibleDimensions = true;\n        /** Whether the overlay position is locked. */\n        this._positionLocked = false;\n        /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n        this._viewportMargin = 0;\n        /** The Scrollable containers used to check scrollable view properties on position change. */\n        this._scrollables = [];\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        /** Subject that emits whenever the position changes. */\n        this._positionChanges = new Subject();\n        /** Subscription to viewport size changes. */\n        this._resizeSubscription = Subscription.EMPTY;\n        /** Default offset for the overlay along the x axis. */\n        this._offsetX = 0;\n        /** Default offset for the overlay along the y axis. */\n        this._offsetY = 0;\n        /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n        this._appliedPanelClasses = [];\n        /** Observable sequence of position changes. */\n        this.positionChanges = this._positionChanges;\n        this.setOrigin(connectedTo);\n    }\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && overlayRef !== this._overlayRef &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('This position strategy is already attached to an overlay');\n        }\n        this._validatePositions();\n        overlayRef.hostElement.classList.add(boundingBoxClass);\n        this._overlayRef = overlayRef;\n        this._boundingBox = overlayRef.hostElement;\n        this._pane = overlayRef.overlayElement;\n        this._isDisposed = false;\n        this._isInitialRender = true;\n        this._lastPosition = null;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n            // When the window is resized, we want to trigger the next reposition as if it\n            // was an initial render, in order for the strategy to pick a new optimal position,\n            // otherwise position locking will cause it to stay at the old one.\n            this._isInitialRender = true;\n            this.apply();\n        });\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * @docs-private\n     */\n    apply() {\n        // We shouldn't do anything if the strategy was disposed or we're on the server.\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the old position, in order to\n        // prevent the overlay from jumping around.\n        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n            this.reapplyLastPosition();\n            return;\n        }\n        this._clearPanelClasses();\n        this._resetOverlayElementStyles();\n        this._resetBoundingBoxStyles();\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        // We use the viewport rect to determine whether a position would go off-screen.\n        this._viewportRect = this._getNarrowedViewportRect();\n        this._originRect = this._getOriginRect();\n        this._overlayRect = this._pane.getBoundingClientRect();\n        const originRect = this._originRect;\n        const overlayRect = this._overlayRect;\n        const viewportRect = this._viewportRect;\n        // Positions where the overlay will fit with flexible dimensions.\n        const flexibleFits = [];\n        // Fallback if none of the preferred positions fit within the viewport.\n        let fallback;\n        // Go through each of the preferred positions looking for a good fit.\n        // If a good fit is found, it will be applied immediately.\n        for (let pos of this._preferredPositions) {\n            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n            let originPoint = this._getOriginPoint(originRect, pos);\n            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n            // overlay in this position. We use the top-left corner for calculations and later translate\n            // this into an appropriate (top, left, bottom, right) style.\n            let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            // Calculate how well the overlay would fit into the viewport with this point.\n            let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n            // If the overlay, without any further work, fits into the viewport, use this position.\n            if (overlayFit.isCompletelyWithinViewport) {\n                this._isPushed = false;\n                this._applyPosition(pos, originPoint);\n                return;\n            }\n            // If the overlay has flexible dimensions, we can use this position\n            // so long as there's enough space for the minimum dimensions.\n            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                // Save positions where the overlay will fit with flexible dimensions. We will use these\n                // if none of the positions fit *without* flexible dimensions.\n                flexibleFits.push({\n                    position: pos,\n                    origin: originPoint,\n                    overlayRect,\n                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n                });\n                continue;\n            }\n            // If the current preferred position does not fit on the screen, remember the position\n            // if it has more visible area on-screen than we've seen and move onto the next preferred\n            // position.\n            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                fallback = { overlayFit, overlayPoint, originPoint, position: pos, overlayRect };\n            }\n        }\n        // If there are any positions where the overlay would fit with flexible dimensions, choose the\n        // one that has the greatest area available modified by the position's weight\n        if (flexibleFits.length) {\n            let bestFit = null;\n            let bestScore = -1;\n            for (const fit of flexibleFits) {\n                const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestFit = fit;\n                }\n            }\n            this._isPushed = false;\n            this._applyPosition(bestFit.position, bestFit.origin);\n            return;\n        }\n        // When none of the preferred positions fit within the viewport, take the position\n        // that went off-screen the least and attempt to push it on-screen.\n        if (this._canPush) {\n            // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n            this._isPushed = true;\n            this._applyPosition(fallback.position, fallback.originPoint);\n            return;\n        }\n        // All options for getting the overlay within the viewport have been exhausted, so go with the\n        // position that went off-screen the least.\n        this._applyPosition(fallback.position, fallback.originPoint);\n    }\n    detach() {\n        this._clearPanelClasses();\n        this._lastPosition = null;\n        this._previousPushAmount = null;\n        this._resizeSubscription.unsubscribe();\n    }\n    /** Cleanup after the element gets destroyed. */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // We can't use `_resetBoundingBoxStyles` here, because it resets\n        // some properties to zero, rather than removing them.\n        if (this._boundingBox) {\n            extendStyles(this._boundingBox.style, {\n                top: '',\n                left: '',\n                right: '',\n                bottom: '',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        }\n        if (this._pane) {\n            this._resetOverlayElementStyles();\n        }\n        if (this._overlayRef) {\n            this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n        }\n        this.detach();\n        this._positionChanges.complete();\n        this._overlayRef = this._boundingBox = null;\n        this._isDisposed = true;\n    }\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    reapplyLastPosition() {\n        if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            this._viewportRect = this._getNarrowedViewportRect();\n            const lastPosition = this._lastPosition || this._preferredPositions[0];\n            const originPoint = this._getOriginPoint(this._originRect, lastPosition);\n            this._applyPosition(lastPosition, originPoint);\n        }\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._scrollables = scrollables;\n        return this;\n    }\n    /**\n     * Adds new preferred positions.\n     * @param positions List of positions options for this overlay.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions;\n        // If the last calculated position object isn't part of the positions anymore, clear\n        // it in order to avoid it being picked up if the consumer tries to re-apply.\n        if (positions.indexOf(this._lastPosition) === -1) {\n            this._lastPosition = null;\n        }\n        this._validatePositions();\n        return this;\n    }\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @param margin Required margin between the overlay and the viewport edge in pixels.\n     */\n    withViewportMargin(margin) {\n        this._viewportMargin = margin;\n        return this;\n    }\n    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n    withFlexibleDimensions(flexibleDimensions = true) {\n        this._hasFlexibleDimensions = flexibleDimensions;\n        return this;\n    }\n    /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n    withGrowAfterOpen(growAfterOpen = true) {\n        this._growAfterOpen = growAfterOpen;\n        return this;\n    }\n    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    withPush(canPush = true) {\n        this._canPush = canPush;\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked = true) {\n        this._positionLocked = isLocked;\n        return this;\n    }\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @param origin Reference to the new origin.\n     */\n    setOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @param offset New offset in the X axis.\n     */\n    withDefaultOffsetX(offset) {\n        this._offsetX = offset;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @param offset New offset in the Y axis.\n     */\n    withDefaultOffsetY(offset) {\n        this._offsetY = offset;\n        return this;\n    }\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @param selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     */\n    withTransformOriginOn(selector) {\n        this._transformOriginSelector = selector;\n        return this;\n    }\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     */\n    _getOriginPoint(originRect, pos) {\n        let x;\n        if (pos.originX == 'center') {\n            // Note: when centering we should always use the `left`\n            // offset, otherwise the position will be wrong in RTL.\n            x = originRect.left + (originRect.width / 2);\n        }\n        else {\n            const startX = this._isRtl() ? originRect.right : originRect.left;\n            const endX = this._isRtl() ? originRect.left : originRect.right;\n            x = pos.originX == 'start' ? startX : endX;\n        }\n        let y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x, y };\n    }\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     */\n    _getOverlayPoint(originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the\n        // potential overlay position relative to the origin point.\n        let overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n        }\n        let overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY,\n        };\n    }\n    /** Gets how well an overlay at the given point will fit within the viewport. */\n    _getOverlayFit(point, rawOverlayRect, viewport, position) {\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        let { x, y } = point;\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        // Account for the offsets since they could push the overlay out of the viewport.\n        if (offsetX) {\n            x += offsetX;\n        }\n        if (offsetY) {\n            y += offsetY;\n        }\n        // How much the overlay would overflow at this position, on each side.\n        let leftOverflow = 0 - x;\n        let rightOverflow = (x + overlay.width) - viewport.width;\n        let topOverflow = 0 - y;\n        let bottomOverflow = (y + overlay.height) - viewport.height;\n        // Visible parts of the element on each axis.\n        let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n        let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n        let visibleArea = visibleWidth * visibleHeight;\n        return {\n            visibleArea,\n            isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n            fitsInViewportVertically: visibleHeight === overlay.height,\n            fitsInViewportHorizontally: visibleWidth == overlay.width,\n        };\n    }\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @param fit How well the overlay fits in the viewport at some position.\n     * @param point The (x, y) coordinates of the overlat at some position.\n     * @param viewport The geometry of the viewport.\n     */\n    _canFitWithFlexibleDimensions(fit, point, viewport) {\n        if (this._hasFlexibleDimensions) {\n            const availableHeight = viewport.bottom - point.y;\n            const availableWidth = viewport.right - point.x;\n            const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n            const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n            const verticalFit = fit.fitsInViewportVertically ||\n                (minHeight != null && minHeight <= availableHeight);\n            const horizontalFit = fit.fitsInViewportHorizontally ||\n                (minWidth != null && minWidth <= availableWidth);\n            return verticalFit && horizontalFit;\n        }\n        return false;\n    }\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n     * right and bottom).\n     *\n     * @param start Starting point from which the overlay is pushed.\n     * @param overlay Dimensions of the overlay.\n     * @param scrollPosition Current viewport scroll position.\n     * @returns The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {\n        // If the position is locked and we've pushed the overlay already, reuse the previous push\n        // amount, rather than pushing it again. If we were to continue pushing, the element would\n        // remain in the viewport, which goes against the expectations when position locking is enabled.\n        if (this._previousPushAmount && this._positionLocked) {\n            return {\n                x: start.x + this._previousPushAmount.x,\n                y: start.y + this._previousPushAmount.y\n            };\n        }\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        const viewport = this._viewportRect;\n        // Determine how much the overlay goes outside the viewport on each\n        // side, which we'll use to decide which direction to push it.\n        const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n        const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n        const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n        const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n        // Amount by which to push the overlay in each axis such that it remains on-screen.\n        let pushX = 0;\n        let pushY = 0;\n        // If the overlay fits completely within the bounds of the viewport, push it from whichever\n        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n        // viewport and allow for the trailing end of the overlay to go out of bounds.\n        if (overlay.width <= viewport.width) {\n            pushX = overflowLeft || -overflowRight;\n        }\n        else {\n            pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n        }\n        if (overlay.height <= viewport.height) {\n            pushY = overflowTop || -overflowBottom;\n        }\n        else {\n            pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n        }\n        this._previousPushAmount = { x: pushX, y: pushY };\n        return {\n            x: start.x + pushX,\n            y: start.y + pushY,\n        };\n    }\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @param position The position preference\n     * @param originPoint The point on the origin element where the overlay is connected.\n     */\n    _applyPosition(position, originPoint) {\n        this._setTransformOrigin(position);\n        this._setOverlayElementStyles(originPoint, position);\n        this._setBoundingBoxStyles(originPoint, position);\n        if (position.panelClass) {\n            this._addPanelClasses(position.panelClass);\n        }\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastPosition = position;\n        // Notify that the position has been changed along with its change properties.\n        // We only emit if we've got any subscriptions, because the scroll visibility\n        // calculcations can be somewhat expensive.\n        if (this._positionChanges.observers.length) {\n            const scrollableViewProperties = this._getScrollVisibility();\n            const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n            this._positionChanges.next(changeEvent);\n        }\n        this._isInitialRender = false;\n    }\n    /** Sets the transform origin based on the configured selector and the passed-in position.  */\n    _setTransformOrigin(position) {\n        if (!this._transformOriginSelector) {\n            return;\n        }\n        const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n        let xOrigin;\n        let yOrigin = position.overlayY;\n        if (position.overlayX === 'center') {\n            xOrigin = 'center';\n        }\n        else if (this._isRtl()) {\n            xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n        }\n        else {\n            xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n        }\n        for (let i = 0; i < elements.length; i++) {\n            elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n        }\n    }\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     */\n    _calculateBoundingBoxRect(origin, position) {\n        const viewport = this._viewportRect;\n        const isRtl = this._isRtl();\n        let height, top, bottom;\n        if (position.overlayY === 'top') {\n            // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n            top = origin.y;\n            height = viewport.height - top + this._viewportMargin;\n        }\n        else if (position.overlayY === 'bottom') {\n            // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n            // the viewport margin back in, because the viewport rect is narrowed down to remove the\n            // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n            bottom = viewport.height - origin.y + this._viewportMargin * 2;\n            height = viewport.height - bottom + this._viewportMargin;\n        }\n        else {\n            // If neither top nor bottom, it means that the overlay is vertically centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n            // `origin.y - viewport.top`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n            const previousHeight = this._lastBoundingBoxSize.height;\n            height = smallestDistanceToViewportEdge * 2;\n            top = origin.y - smallestDistanceToViewportEdge;\n            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                top = origin.y - (previousHeight / 2);\n            }\n        }\n        // The overlay is opening 'right-ward' (the content flows to the right).\n        const isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||\n            (position.overlayX === 'end' && isRtl);\n        // The overlay is opening 'left-ward' (the content flows to the left).\n        const isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||\n            (position.overlayX === 'start' && isRtl);\n        let width, left, right;\n        if (isBoundedByLeftViewportEdge) {\n            right = viewport.width - origin.x + this._viewportMargin;\n            width = origin.x - this._viewportMargin;\n        }\n        else if (isBoundedByRightViewportEdge) {\n            left = origin.x;\n            width = viewport.right - origin.x;\n        }\n        else {\n            // If neither start nor end, it means that the overlay is horizontally centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.right - origin.x` and\n            // `origin.x - viewport.left`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n            const previousWidth = this._lastBoundingBoxSize.width;\n            width = smallestDistanceToViewportEdge * 2;\n            left = origin.x - smallestDistanceToViewportEdge;\n            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                left = origin.x - (previousWidth / 2);\n            }\n        }\n        return { top: top, left: left, bottom: bottom, right: right, width, height };\n    }\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stetches to the bounds of the viewport.\n     *\n     * @param origin The point on the origin element where the overlay is connected.\n     * @param position The position preference\n     */\n    _setBoundingBoxStyles(origin, position) {\n        const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n        // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n        // when applying a new size.\n        if (!this._isInitialRender && !this._growAfterOpen) {\n            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n        }\n        const styles = {};\n        if (this._hasExactPosition()) {\n            styles.top = styles.left = '0';\n            styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n            styles.width = styles.height = '100%';\n        }\n        else {\n            const maxHeight = this._overlayRef.getConfig().maxHeight;\n            const maxWidth = this._overlayRef.getConfig().maxWidth;\n            styles.height = coerceCssPixelValue(boundingBoxRect.height);\n            styles.top = coerceCssPixelValue(boundingBoxRect.top);\n            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n            styles.width = coerceCssPixelValue(boundingBoxRect.width);\n            styles.left = coerceCssPixelValue(boundingBoxRect.left);\n            styles.right = coerceCssPixelValue(boundingBoxRect.right);\n            // Push the pane content towards the proper direction.\n            if (position.overlayX === 'center') {\n                styles.alignItems = 'center';\n            }\n            else {\n                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n            }\n            if (position.overlayY === 'center') {\n                styles.justifyContent = 'center';\n            }\n            else {\n                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n            }\n            if (maxHeight) {\n                styles.maxHeight = coerceCssPixelValue(maxHeight);\n            }\n            if (maxWidth) {\n                styles.maxWidth = coerceCssPixelValue(maxWidth);\n            }\n        }\n        this._lastBoundingBoxSize = boundingBoxRect;\n        extendStyles(this._boundingBox.style, styles);\n    }\n    /** Resets the styles for the bounding box so that a new positioning can be computed. */\n    _resetBoundingBoxStyles() {\n        extendStyles(this._boundingBox.style, {\n            top: '0',\n            left: '0',\n            right: '0',\n            bottom: '0',\n            height: '',\n            width: '',\n            alignItems: '',\n            justifyContent: '',\n        });\n    }\n    /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n    _resetOverlayElementStyles() {\n        extendStyles(this._pane.style, {\n            top: '',\n            left: '',\n            bottom: '',\n            right: '',\n            position: '',\n            transform: '',\n        });\n    }\n    /** Sets positioning styles to the overlay element. */\n    _setOverlayElementStyles(originPoint, position) {\n        const styles = {};\n        const hasExactPosition = this._hasExactPosition();\n        const hasFlexibleDimensions = this._hasFlexibleDimensions;\n        const config = this._overlayRef.getConfig();\n        if (hasExactPosition) {\n            const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n        }\n        else {\n            styles.position = 'static';\n        }\n        // Use a transform to apply the offsets. We do this because the `center` positions rely on\n        // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n        // off the position. We also can't use margins, because they won't have an effect in some\n        // cases where the element doesn't have anything to \"push off of\". Finally, this works\n        // better both with flexible and non-flexible positioning.\n        let transformString = '';\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        if (offsetX) {\n            transformString += `translateX(${offsetX}px) `;\n        }\n        if (offsetY) {\n            transformString += `translateY(${offsetY}px)`;\n        }\n        styles.transform = transformString.trim();\n        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n        // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n        // Note that this doesn't apply when we have an exact position, in which case we do want to\n        // apply them because they'll be cleared from the bounding box.\n        if (config.maxHeight) {\n            if (hasExactPosition) {\n                styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxHeight = '';\n            }\n        }\n        if (config.maxWidth) {\n            if (hasExactPosition) {\n                styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxWidth = '';\n            }\n        }\n        extendStyles(this._pane.style, styles);\n    }\n    /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayY(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the\n        // preferred position has changed since the last `apply`.\n        let styles = { top: '', bottom: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        let virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;\n        // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n        // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n        // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n        // otherwise our positioning will be thrown off.\n        overlayPoint.y -= virtualKeyboardOffset;\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n        // above or below the origin and the direction in which the element will expand.\n        if (position.overlayY === 'bottom') {\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            const documentHeight = this._document.documentElement.clientHeight;\n            styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n        }\n        else {\n            styles.top = coerceCssPixelValue(overlayPoint.y);\n        }\n        return styles;\n    }\n    /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayX(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        let styles = { left: '', right: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        let horizontalStyleProperty;\n        if (this._isRtl()) {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        if (horizontalStyleProperty === 'right') {\n            const documentWidth = this._document.documentElement.clientWidth;\n            styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n        }\n        else {\n            styles.left = coerceCssPixelValue(overlayPoint.x);\n        }\n        return styles;\n    }\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     */\n    _getScrollVisibility() {\n        // Note: needs fresh rects since the position could've changed.\n        const originBounds = this._getOriginRect();\n        const overlayBounds = this._pane.getBoundingClientRect();\n        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n        // every time, we should be able to use the scrollTop of the containers if the size of those\n        // containers hasn't changed.\n        const scrollContainerBounds = this._scrollables.map(scrollable => {\n            return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n        });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    }\n    /** Subtracts the amount that an element is overflowing on an axis from its length. */\n    _subtractOverflows(length, ...overflows) {\n        return overflows.reduce((currentValue, currentOverflow) => {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    }\n    /** Narrows the given viewport rect by the current _viewportMargin. */\n    _getNarrowedViewportRect() {\n        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n        // and `innerHeight` that do. This is necessary, because the overlay container uses\n        // 100% `width` and `height` which don't include the scrollbar either.\n        const width = this._document.documentElement.clientWidth;\n        const height = this._document.documentElement.clientHeight;\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        return {\n            top: scrollPosition.top + this._viewportMargin,\n            left: scrollPosition.left + this._viewportMargin,\n            right: scrollPosition.left + width - this._viewportMargin,\n            bottom: scrollPosition.top + height - this._viewportMargin,\n            width: width - (2 * this._viewportMargin),\n            height: height - (2 * this._viewportMargin),\n        };\n    }\n    /** Whether the we're dealing with an RTL context */\n    _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /** Determines whether the overlay uses exact or flexible positioning. */\n    _hasExactPosition() {\n        return !this._hasFlexibleDimensions || this._isPushed;\n    }\n    /** Retrieves the offset of a position along the x or y axis. */\n    _getOffset(position, axis) {\n        if (axis === 'x') {\n            // We don't do something like `position['offset' + axis]` in\n            // order to avoid breking minifiers that rename properties.\n            return position.offsetX == null ? this._offsetX : position.offsetX;\n        }\n        return position.offsetY == null ? this._offsetY : position.offsetY;\n    }\n    /** Validates that the current position match the expected values. */\n    _validatePositions() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!this._preferredPositions.length) {\n                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n            }\n            // TODO(crisbeto): remove these once Angular's template type\n            // checking is advanced enough to catch these cases.\n            this._preferredPositions.forEach(pair => {\n                validateHorizontalPosition('originX', pair.originX);\n                validateVerticalPosition('originY', pair.originY);\n                validateHorizontalPosition('overlayX', pair.overlayX);\n                validateVerticalPosition('overlayY', pair.overlayY);\n            });\n        }\n    }\n    /** Adds a single CSS class or an array of classes on the overlay panel. */\n    _addPanelClasses(cssClasses) {\n        if (this._pane) {\n            coerceArray(cssClasses).forEach(cssClass => {\n                if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                    this._appliedPanelClasses.push(cssClass);\n                    this._pane.classList.add(cssClass);\n                }\n            });\n        }\n    }\n    /** Clears the classes that the position strategy has applied from the overlay panel. */\n    _clearPanelClasses() {\n        if (this._pane) {\n            this._appliedPanelClasses.forEach(cssClass => {\n                this._pane.classList.remove(cssClass);\n            });\n            this._appliedPanelClasses = [];\n        }\n    }\n    /** Returns the ClientRect of the current origin. */\n    _getOriginRect() {\n        const origin = this._origin;\n        if (origin instanceof ElementRef) {\n            return origin.nativeElement.getBoundingClientRect();\n        }\n        // Check for Element so SVG elements are also supported.\n        if (origin instanceof Element) {\n            return origin.getBoundingClientRect();\n        }\n        const width = origin.width || 0;\n        const height = origin.height || 0;\n        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n        return {\n            top: origin.y,\n            bottom: origin.y + height,\n            left: origin.x,\n            right: origin.x + width,\n            height,\n            width\n        };\n    }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            destination[key] = source[key];\n        }\n    }\n    return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n    if (typeof input !== 'number' && input != null) {\n        const [value, units] = input.split(cssUnitPattern);\n        return (!units || units === 'px') ? parseFloat(value) : null;\n    }\n    return input || null;\n}\n/**\n * Gets a version of an element's bounding `ClientRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `ClientRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect) {\n    return {\n        top: Math.floor(clientRect.top),\n        right: Math.floor(clientRect.right),\n        bottom: Math.floor(clientRect.bottom),\n        left: Math.floor(clientRect.left),\n        width: Math.floor(clientRect.width),\n        height: Math.floor(clientRect.height)\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative to some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n * @deprecated Use `FlexibleConnectedPositionStrategy` instead.\n * @breaking-change 8.0.0\n */\nclass ConnectedPositionStrategy {\n    constructor(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain\n        // the extra logic, we create an instance of the positioning strategy that has some\n        // defaults that make it behave as the old position strategy and to which we'll\n        // proxy all of the API calls.\n        this._positionStrategy = new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withViewportMargin(0);\n        this.withFallbackPosition(originPos, overlayPos);\n        this.onPositionChange = this._positionStrategy.positionChanges;\n    }\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /** Attach this position strategy to an overlay. */\n    attach(overlayRef) {\n        this._overlayRef = overlayRef;\n        this._positionStrategy.attach(overlayRef);\n        if (this._direction) {\n            overlayRef.setDirection(this._direction);\n            this._direction = null;\n        }\n    }\n    /** Disposes all resources used by the position strategy. */\n    dispose() {\n        this._positionStrategy.dispose();\n    }\n    /** @docs-private */\n    detach() {\n        this._positionStrategy.detach();\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    apply() {\n        this._positionStrategy.apply();\n    }\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    recalculateLastPosition() {\n        this._positionStrategy.reapplyLastPosition();\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._positionStrategy.withScrollableContainers(scrollables);\n    }\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {\n        const position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        this._positionStrategy.withPositions(this._preferredPositions);\n        return this;\n    }\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    withDirection(dir) {\n        // Since the direction might be declared before the strategy is attached,\n        // we save the value in a temporary property and we'll transfer it to the\n        // overlay ref on attachment.\n        if (this._overlayRef) {\n            this._overlayRef.setDirection(dir);\n        }\n        else {\n            this._direction = dir;\n        }\n        return this;\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    withOffsetX(offset) {\n        this._positionStrategy.withDefaultOffsetX(offset);\n        return this;\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    withOffsetY(offset) {\n        this._positionStrategy.withDefaultOffsetY(offset);\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked) {\n        this._positionStrategy.withLockedPosition(isLocked);\n        return this;\n    }\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions.slice();\n        this._positionStrategy.withPositions(this._preferredPositions);\n        return this;\n    }\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    setOrigin(origin) {\n        this._positionStrategy.setOrigin(origin);\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n    constructor() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n    }\n    attach(overlayRef) {\n        const config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n        overlayRef.hostElement.classList.add(wrapperClass);\n        this._isDisposed = false;\n    }\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    top(value = '') {\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    left(value = '') {\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    bottom(value = '') {\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    right(value = '') {\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    width(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    }\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    height(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    }\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    centerHorizontally(offset = '') {\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    }\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    centerVertically(offset = '') {\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    }\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     */\n    apply() {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parentStyles = this._overlayRef.hostElement.style;\n        const config = this._overlayRef.getConfig();\n        const { width, height, maxWidth, maxHeight } = config;\n        const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') &&\n            (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n        const shouldBeFlushVertically = (height === '100%' || height === '100vh') &&\n            (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n        styles.position = this._cssPosition;\n        styles.marginLeft = shouldBeFlushHorizontally ? '0' : this._leftOffset;\n        styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        if (shouldBeFlushHorizontally) {\n            parentStyles.justifyContent = 'flex-start';\n        }\n        else if (this._justifyContent === 'center') {\n            parentStyles.justifyContent = 'center';\n        }\n        else if (this._overlayRef.getConfig().direction === 'rtl') {\n            // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we\n            // don't want that because our positioning is explicitly `left` and `right`, hence\n            // why we do another inversion to ensure that the overlay stays in the same position.\n            // TODO: reconsider this if we add `start` and `end` methods.\n            if (this._justifyContent === 'flex-start') {\n                parentStyles.justifyContent = 'flex-end';\n            }\n            else if (this._justifyContent === 'flex-end') {\n                parentStyles.justifyContent = 'flex-start';\n            }\n        }\n        else {\n            parentStyles.justifyContent = this._justifyContent;\n        }\n        parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n    }\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * @docs-private\n     */\n    dispose() {\n        if (this._isDisposed || !this._overlayRef) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parent = this._overlayRef.hostElement;\n        const parentStyles = parent.style;\n        parent.classList.remove(wrapperClass);\n        parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =\n            styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n        this._overlayRef = null;\n        this._isDisposed = true;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Builder for overlay position strategy. */\nclass OverlayPositionBuilder {\n    constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    global() {\n        return new GlobalPositionStrategy();\n    }\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     * @deprecated Use `flexibleConnectedTo` instead.\n     * @breaking-change 8.0.0\n     */\n    connectedTo(elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n    }\n    /**\n     * Creates a flexible position strategy.\n     * @param origin Origin relative to which to position the overlay.\n     */\n    flexibleConnectedTo(origin) {\n        return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n    }\n}\nOverlayPositionBuilder.fac = function OverlayPositionBuilder_Factory(t) { return new (t || OverlayPositionBuilder)(ngcc0.inject(ngcc1.ViewportRuler), ngcc0.inject(DOCUMENT), ngcc0.inject(ngcc2.Platform), ngcc0.inject(OverlayContainer)); };\nOverlayPositionBuilder.prov = i0.defineInjectable({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(i0.inject(i1.ViewportRuler), i0.inject(i1$1.DOCUMENT), i0.inject(i2.Platform), i0.inject(OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: \"root\" });\nOverlayPositionBuilder.ctorParameters = () => [\n    { type: ViewportRuler },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Platform },\n    { type: OverlayContainer }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(OverlayPositionBuilder, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc1.ViewportRuler }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ngcc2.Platform }, { type: OverlayContainer }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\n// Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n// which needs to be different depending on where OverlayModule is imported.\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n    constructor(\n    /** Scrolling strategies that can be used when creating an overlay. */\n    scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._directionality = _directionality;\n        this._location = _location;\n        this._outsideClickDispatcher = _outsideClickDispatcher;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    create(config) {\n        const host = this._createHostElement();\n        const pane = this._createPaneElement(host);\n        const portalOutlet = this._createPortalOutlet(pane);\n        const overlayConfig = new OverlayConfig(config);\n        overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n        return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher);\n    }\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    position() {\n        return this._positionBuilder;\n    }\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @returns Newly-created pane element\n     */\n    _createPaneElement(host) {\n        const pane = this._document.createElement('div');\n        pane.id = `cdk-overlay-${nextUniqueId++}`;\n        pane.classList.add('cdk-overlay-pane');\n        host.appendChild(pane);\n        return pane;\n    }\n    /**\n     * Creates the host element that wraps around an overlay\n     * and can be used for advanced positioning.\n     * @returns Newly-create host element.\n     */\n    _createHostElement() {\n        const host = this._document.createElement('div');\n        this._overlayContainer.getContainerElement().appendChild(host);\n        return host;\n    }\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param pane The DOM element to turn into a portal outlet.\n     * @returns A portal outlet for the given DOM element.\n     */\n    _createPortalOutlet(pane) {\n        // We have to resolve the ApplicationRef later in order to allow people\n        // to use overlay-based providers during app initialization.\n        if (!this._appRef) {\n            this._appRef = this._injector.get(ApplicationRef);\n        }\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n    }\n}\nOverlay.fac = function Overlay_Factory(t) { return new (t || Overlay)(ngcc0.inject(ScrollStrategyOptions), ngcc0.inject(OverlayContainer), ngcc0.inject(ngcc0.ComponentFactoryResolver), ngcc0.inject(OverlayPositionBuilder), ngcc0.inject(OverlayKeyboardDispatcher), ngcc0.inject(ngcc0.Injector), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(DOCUMENT), ngcc0.inject(ngcc3.Directionality), ngcc0.inject(ngcc4.Location), ngcc0.inject(OverlayOutsideClickDispatcher)); };\nOverlay.prov = /*@__PURE__*/ ngcc0.defineInjectable({ token: Overlay, factory: Overlay.fac });\nOverlay.ctorParameters = () => [\n    { type: ScrollStrategyOptions },\n    { type: OverlayContainer },\n    { type: ComponentFactoryResolver },\n    { type: OverlayPositionBuilder },\n    { type: OverlayKeyboardDispatcher },\n    { type: Injector },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Directionality },\n    { type: Location },\n    { type: OverlayOutsideClickDispatcher }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(Overlay, [{\n        type: Injectable\n    }], function () { return [{ type: ScrollStrategyOptions }, { type: OverlayContainer }, { type: ngcc0.ComponentFactoryResolver }, { type: OverlayPositionBuilder }, { type: OverlayKeyboardDispatcher }, { type: ngcc0.Injector }, { type: ngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ngcc3.Directionality }, { type: ngcc4.Location }, { type: OverlayOutsideClickDispatcher }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [\n    {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n    },\n    {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n    }\n];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nCdkOverlayOrigin.fac = function CdkOverlayOrigin_Factory(t) { return new (t || CdkOverlayOrigin)(ngcc0.directiveInject(ngcc0.ElementRef)); };\nCdkOverlayOrigin.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkOverlayOrigin, selectors: [[\"\", \"cdk-overlay-origin\", \"\"], [\"\", \"overlay-origin\", \"\"], [\"\", \"cdkOverlayOrigin\", \"\"]], exportAs: [\"cdkOverlayOrigin\"] });\nCdkOverlayOrigin.ctorParameters = () => [\n    { type: ElementRef }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkOverlayOrigin, [{\n        type: Directive,\n        args: [{\n                selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                exportAs: 'cdkOverlayOrigin'\n            }]\n    }], function () { return [{ type: ngcc0.ElementRef }]; }, null); })();\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n        this._overlay = _overlay;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._lockPosition = false;\n        this._growAfterOpen = false;\n        this._flexibleDimensions = false;\n        this._push = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._attachSubscription = Subscription.EMPTY;\n        this._detachSubscription = Subscription.EMPTY;\n        this._positionSubscription = Subscription.EMPTY;\n        /** Margin between the overlay and the viewport edges. */\n        this.viewportMargin = 0;\n        /** Whether the overlay is open. */\n        this.open = false;\n        /** Whether the overlay can be closed by user interaction. */\n        this.disableClose = false;\n        /** Event emitted when the backdrop is clicked. */\n        this.backdropClick = new EventEmitter();\n        /** Event emitted when the position has changed. */\n        this.positionChange = new EventEmitter();\n        /** Event emitted when the overlay has been attached. */\n        this.attach = new EventEmitter();\n        /** Event emitted when the overlay has been detached. */\n        this.detach = new EventEmitter();\n        /** Emits when there are keyboard events that are targeted at the overlay. */\n        this.overlayKeydown = new EventEmitter();\n        /** Emits when there are mouse outside click events that are targeted at the overlay. */\n        this.overlayOutsideClick = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n        this._scrollStrategyFactory = scrollStrategyFactory;\n        this.scrollStrategy = this._scrollStrategyFactory();\n    }\n    /** The offset in pixels for the overlay connection point on the x-axis */\n    get offsetX() { return this._offsetX; }\n    set offsetX(offsetX) {\n        this._offsetX = offsetX;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /** The offset in pixels for the overlay connection point on the y-axis */\n    get offsetY() { return this._offsetY; }\n    set offsetY(offsetY) {\n        this._offsetY = offsetY;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /** Whether or not the overlay should attach a backdrop. */\n    get hasBackdrop() { return this._hasBackdrop; }\n    set hasBackdrop(value) { this._hasBackdrop = coerceBooleanProperty(value); }\n    /** Whether or not the overlay should be locked when scrolling. */\n    get lockPosition() { return this._lockPosition; }\n    set lockPosition(value) { this._lockPosition = coerceBooleanProperty(value); }\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    get flexibleDimensions() { return this._flexibleDimensions; }\n    set flexibleDimensions(value) {\n        this._flexibleDimensions = coerceBooleanProperty(value);\n    }\n    /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n    get growAfterOpen() { return this._growAfterOpen; }\n    set growAfterOpen(value) { this._growAfterOpen = coerceBooleanProperty(value); }\n    /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    get push() { return this._push; }\n    set push(value) { this._push = coerceBooleanProperty(value); }\n    /** The associated overlay reference. */\n    get overlayRef() {\n        return this._overlayRef;\n    }\n    /** The element's layout direction. */\n    get dir() {\n        return this._dir ? this._dir.value : 'ltr';\n    }\n    ngOnDestroy() {\n        this._attachSubscription.unsubscribe();\n        this._detachSubscription.unsubscribe();\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n    }\n    ngOnChanges(changes) {\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n            this._overlayRef.updateSize({\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n            });\n            if (changes['origin'] && this.open) {\n                this._position.apply();\n            }\n        }\n        if (changes['open']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    }\n    /** Creates an overlay */\n    _createOverlay() {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());\n        this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n        this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n        overlayRef.keydownEvents().subscribe((event) => {\n            this.overlayKeydown.next(event);\n            if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n                event.preventDefault();\n                this._detachOverlay();\n            }\n        });\n        this._overlayRef.outsidePointerEvents().subscribe((event) => {\n            this.overlayOutsideClick.next(event);\n        });\n    }\n    /** Builds the overlay config based on the directive's inputs */\n    _buildConfig() {\n        const positionStrategy = this._position =\n            this.positionStrategy || this._createPositionStrategy();\n        const overlayConfig = new OverlayConfig({\n            direction: this._dir,\n            positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        if (this.panelClass) {\n            overlayConfig.panelClass = this.panelClass;\n        }\n        return overlayConfig;\n    }\n    /** Updates the state of a position strategy, based on the values of the directive inputs. */\n    _updatePositionStrategy(positionStrategy) {\n        const positions = this.positions.map(currentPosition => ({\n            originX: currentPosition.originX,\n            originY: currentPosition.originY,\n            overlayX: currentPosition.overlayX,\n            overlayY: currentPosition.overlayY,\n            offsetX: currentPosition.offsetX || this.offsetX,\n            offsetY: currentPosition.offsetY || this.offsetY,\n            panelClass: currentPosition.panelClass || undefined,\n        }));\n        return positionStrategy\n            .setOrigin(this.origin.elementRef)\n            .withPositions(positions)\n            .withFlexibleDimensions(this.flexibleDimensions)\n            .withPush(this.push)\n            .withGrowAfterOpen(this.growAfterOpen)\n            .withViewportMargin(this.viewportMargin)\n            .withLockedPosition(this.lockPosition)\n            .withTransformOriginOn(this.transformOriginSelector);\n    }\n    /** Returns the position strategy of the overlay to be set on the overlay config */\n    _createPositionStrategy() {\n        const strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);\n        this._updatePositionStrategy(strategy);\n        return strategy;\n    }\n    /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n    _attachOverlay() {\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        else {\n            // Update the overlay size, in case the directive's inputs have changed\n            this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n        }\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n                this.backdropClick.emit(event);\n            });\n        }\n        else {\n            this._backdropSubscription.unsubscribe();\n        }\n        this._positionSubscription.unsubscribe();\n        // Only subscribe to `positionChanges` if requested, because putting\n        // together all the information for it can be expensive.\n        if (this.positionChange.observers.length > 0) {\n            this._positionSubscription = this._position.positionChanges\n                .pipe(takeWhile(() => this.positionChange.observers.length > 0))\n                .subscribe(position => {\n                this.positionChange.emit(position);\n                if (this.positionChange.observers.length === 0) {\n                    this._positionSubscription.unsubscribe();\n                }\n            });\n        }\n    }\n    /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n    _detachOverlay() {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n    }\n}\nCdkConnectedOverlay.fac = function CdkConnectedOverlay_Factory(t) { return new (t || CdkConnectedOverlay)(ngcc0.directiveInject(Overlay), ngcc0.directiveInject(ngcc0.TemplateRef), ngcc0.directiveInject(ngcc0.ViewContainerRef), ngcc0.directiveInject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), ngcc0.directiveInject(ngcc3.Directionality, 8)); };\nCdkConnectedOverlay.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkConnectedOverlay, selectors: [[\"\", \"cdk-connected-overlay\", \"\"], [\"\", \"connected-overlay\", \"\"], [\"\", \"cdkConnectedOverlay\", \"\"]], inputs: { viewportMargin: [\"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"], open: [\"cdkConnectedOverlayOpen\", \"open\"], disableClose: [\"cdkConnectedOverlayDisableClose\", \"disableClose\"], scrollStrategy: [\"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"], offsetX: [\"cdkConnectedOverlayOffsetX\", \"offsetX\"], offsetY: [\"cdkConnectedOverlayOffsetY\", \"offsetY\"], hasBackdrop: [\"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\"], lockPosition: [\"cdkConnectedOverlayLockPosition\", \"lockPosition\"], flexibleDimensions: [\"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\"], growAfterOpen: [\"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\"], push: [\"cdkConnectedOverlayPush\", \"push\"], positions: [\"cdkConnectedOverlayPositions\", \"positions\"], origin: [\"cdkConnectedOverlayOrigin\", \"origin\"], positionStrategy: [\"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"], width: [\"cdkConnectedOverlayWidth\", \"width\"], height: [\"cdkConnectedOverlayHeight\", \"height\"], minWidth: [\"cdkConnectedOverlayMinWidth\", \"minWidth\"], minHeight: [\"cdkConnectedOverlayMinHeight\", \"minHeight\"], backdropClass: [\"cdkConnectedOverlayBackdropClass\", \"backdropClass\"], panelClass: [\"cdkConnectedOverlayPanelClass\", \"panelClass\"], transformOriginSelector: [\"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"] }, outputs: { backdropClick: \"backdropClick\", positionChange: \"positionChange\", attach: \"attach\", detach: \"detach\", overlayKeydown: \"overlayKeydown\", overlayOutsideClick: \"overlayOutsideClick\" }, exportAs: [\"cdkConnectedOverlay\"], features: [ngcc0.NgOnChangesFeature] });\nCdkConnectedOverlay.ctorParameters = () => [\n    { type: Overlay },\n    { type: TemplateRef },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] }\n];\nCdkConnectedOverlay.propDecorators = {\n    origin: [{ type: Input, args: ['cdkConnectedOverlayOrigin',] }],\n    positions: [{ type: Input, args: ['cdkConnectedOverlayPositions',] }],\n    positionStrategy: [{ type: Input, args: ['cdkConnectedOverlayPositionStrategy',] }],\n    offsetX: [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] }],\n    offsetY: [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] }],\n    width: [{ type: Input, args: ['cdkConnectedOverlayWidth',] }],\n    height: [{ type: Input, args: ['cdkConnectedOverlayHeight',] }],\n    minWidth: [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] }],\n    minHeight: [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] }],\n    backdropClass: [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] }],\n    panelClass: [{ type: Input, args: ['cdkConnectedOverlayPanelClass',] }],\n    viewportMargin: [{ type: Input, args: ['cdkConnectedOverlayViewportMargin',] }],\n    scrollStrategy: [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] }],\n    open: [{ type: Input, args: ['cdkConnectedOverlayOpen',] }],\n    disableClose: [{ type: Input, args: ['cdkConnectedOverlayDisableClose',] }],\n    transformOriginSelector: [{ type: Input, args: ['cdkConnectedOverlayTransformOriginOn',] }],\n    hasBackdrop: [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] }],\n    lockPosition: [{ type: Input, args: ['cdkConnectedOverlayLockPosition',] }],\n    flexibleDimensions: [{ type: Input, args: ['cdkConnectedOverlayFlexibleDimensions',] }],\n    growAfterOpen: [{ type: Input, args: ['cdkConnectedOverlayGrowAfterOpen',] }],\n    push: [{ type: Input, args: ['cdkConnectedOverlayPush',] }],\n    backdropClick: [{ type: Output }],\n    positionChange: [{ type: Output }],\n    attach: [{ type: Output }],\n    detach: [{ type: Output }],\n    overlayKeydown: [{ type: Output }],\n    overlayOutsideClick: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkConnectedOverlay, [{\n        type: Directive,\n        args: [{\n                selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                exportAs: 'cdkConnectedOverlay'\n            }]\n    }], function () { return [{ type: Overlay }, { type: ngcc0.TemplateRef }, { type: ngcc0.ViewContainerRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]\n            }] }, { type: ngcc3.Directionality, decorators: [{\n                type: Optional\n            }] }]; }, { viewportMargin: [{\n            type: Input,\n            args: ['cdkConnectedOverlayViewportMargin']\n        }], open: [{\n            type: Input,\n            args: ['cdkConnectedOverlayOpen']\n        }], disableClose: [{\n            type: Input,\n            args: ['cdkConnectedOverlayDisableClose']\n        }], backdropClick: [{\n            type: Output\n        }], positionChange: [{\n            type: Output\n        }], attach: [{\n            type: Output\n        }], detach: [{\n            type: Output\n        }], overlayKeydown: [{\n            type: Output\n        }], overlayOutsideClick: [{\n            type: Output\n        }], scrollStrategy: [{\n            type: Input,\n            args: ['cdkConnectedOverlayScrollStrategy']\n        }], offsetX: [{\n            type: Input,\n            args: ['cdkConnectedOverlayOffsetX']\n        }], offsetY: [{\n            type: Input,\n            args: ['cdkConnectedOverlayOffsetY']\n        }], hasBackdrop: [{\n            type: Input,\n            args: ['cdkConnectedOverlayHasBackdrop']\n        }], lockPosition: [{\n            type: Input,\n            args: ['cdkConnectedOverlayLockPosition']\n        }], flexibleDimensions: [{\n            type: Input,\n            args: ['cdkConnectedOverlayFlexibleDimensions']\n        }], growAfterOpen: [{\n            type: Input,\n            args: ['cdkConnectedOverlayGrowAfterOpen']\n        }], push: [{\n            type: Input,\n            args: ['cdkConnectedOverlayPush']\n        }], positions: [{\n            type: Input,\n            args: ['cdkConnectedOverlayPositions']\n        }], origin: [{\n            type: Input,\n            args: ['cdkConnectedOverlayOrigin']\n        }], positionStrategy: [{\n            type: Input,\n            args: ['cdkConnectedOverlayPositionStrategy']\n        }], width: [{\n            type: Input,\n            args: ['cdkConnectedOverlayWidth']\n        }], height: [{\n            type: Input,\n            args: ['cdkConnectedOverlayHeight']\n        }], minWidth: [{\n            type: Input,\n            args: ['cdkConnectedOverlayMinWidth']\n        }], minHeight: [{\n            type: Input,\n            args: ['cdkConnectedOverlayMinHeight']\n        }], backdropClass: [{\n            type: Input,\n            args: ['cdkConnectedOverlayBackdropClass']\n        }], panelClass: [{\n            type: Input,\n            args: ['cdkConnectedOverlayPanelClass']\n        }], transformOriginSelector: [{\n            type: Input,\n            args: ['cdkConnectedOverlayTransformOriginOn']\n        }] }); })();\n/** @docs-private */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass OverlayModule {\n}\nOverlayModule.fac = function OverlayModule_Factory(t) { return new (t || OverlayModule)(); };\nOverlayModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: OverlayModule });\nOverlayModule.inj = /*@__PURE__*/ ngcc0.defineInjector({ providers: [\n        Overlay,\n        CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n    ], imports: [[BidiModule, PortalModule, ScrollingModule], ScrollingModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(OverlayModule, [{\n        type: NgModule,\n        args: [{\n                imports: [BidiModule, PortalModule, ScrollingModule],\n                exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n                declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                providers: [\n                    Overlay,\n                    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(OverlayModule, { declarations: function () { return [CdkConnectedOverlay, CdkOverlayOrigin]; }, imports: function () { return [BidiModule, PortalModule, ScrollingModule]; }, exports: function () { return [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]; } }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nclass FullscreenOverlayContainer extends OverlayContainer {\n    constructor(_document, platform) {\n        super(_document, platform);\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._fullScreenEventName && this._fullScreenListener) {\n            this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n        }\n    }\n    _createContainer() {\n        super._createContainer();\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n    }\n    _adjustParentForFullscreenChange() {\n        if (!this._containerElement) {\n            return;\n        }\n        const fullscreenElement = this.getFullscreenElement();\n        const parent = fullscreenElement || this._document.body;\n        parent.appendChild(this._containerElement);\n    }\n    _addFullscreenChangeListener(fn) {\n        const eventName = this._getEventName();\n        if (eventName) {\n            if (this._fullScreenListener) {\n                this._document.removeEventListener(eventName, this._fullScreenListener);\n            }\n            this._document.addEventListener(eventName, fn);\n            this._fullScreenListener = fn;\n        }\n    }\n    _getEventName() {\n        if (!this._fullScreenEventName) {\n            const _document = this._document;\n            if (_document.fullscreenEnabled) {\n                this._fullScreenEventName = 'fullscreenchange';\n            }\n            else if (_document.webkitFullscreenEnabled) {\n                this._fullScreenEventName = 'webkitfullscreenchange';\n            }\n            else if (_document.mozFullScreenEnabled) {\n                this._fullScreenEventName = 'mozfullscreenchange';\n            }\n            else if (_document.msFullscreenEnabled) {\n                this._fullScreenEventName = 'MSFullscreenChange';\n            }\n        }\n        return this._fullScreenEventName;\n    }\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    getFullscreenElement() {\n        const _document = this._document;\n        return _document.fullscreenElement ||\n            _document.webkitFullscreenElement ||\n            _document.mozFullScreenElement ||\n            _document.msFullscreenElement ||\n            null;\n    }\n}\nFullscreenOverlayContainer.fac = function FullscreenOverlayContainer_Factory(t) { return new (t || FullscreenOverlayContainer)(ngcc0.inject(DOCUMENT), ngcc0.inject(ngcc2.Platform)); };\nFullscreenOverlayContainer.prov = i0.defineInjectable({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(i0.inject(i1$1.DOCUMENT), i0.inject(i2.Platform)); }, token: FullscreenOverlayContainer, providedIn: \"root\" });\nFullscreenOverlayContainer.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Platform }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(FullscreenOverlayContainer, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: ngcc2.Platform }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BlockScrollStrategy, CdkConnectedOverlay, CdkOverlayOrigin, CloseScrollStrategy, ConnectedOverlayPositionChange, ConnectedPositionStrategy, ConnectionPositionPair, FlexibleConnectedPositionStrategy, FullscreenOverlayContainer, GlobalPositionStrategy, NoopScrollStrategy, Overlay, OverlayConfig, OverlayContainer, OverlayKeyboardDispatcher, OverlayModule, OverlayOutsideClickDispatcher, OverlayPositionBuilder, OverlayRef, RepositionScrollStrategy, ScrollStrategyOptions, ScrollingVisibility, validateHorizontalPosition, validateVerticalPosition, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as angular_material_src_cdk_overlay_overlay_a, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as angular_material_src_cdk_overlay_overlay_b, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as angular_material_src_cdk_overlay_overlay_c, BaseOverlayDispatcher as angular_material_src_cdk_overlay_overlay_d };\n\n","import { ElementRef, Directive, TemplateRef, ViewContainerRef, EventEmitter, ComponentFactoryResolver, Inject, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nimport * as ngcc0 from '@angular/core';\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n    /** Attach this portal to a host. */\n    attach(host) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (host == null) {\n                throwNullPortalOutletError();\n            }\n            if (host.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n        }\n        this._attachedHost = host;\n        return host.attach(this);\n    }\n    /** Detach this portal from its host */\n    detach() {\n        let host = this._attachedHost;\n        if (host != null) {\n            this._attachedHost = null;\n            host.detach();\n        }\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwNoPortalAttachedError();\n        }\n    }\n    /** Whether this portal is attached to a host. */\n    get isAttached() {\n        return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    setAttachedHost(host) {\n        this._attachedHost = host;\n    }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n    constructor(component, viewContainerRef, injector, componentFactoryResolver) {\n        super();\n        this.component = component;\n        this.viewContainerRef = viewContainerRef;\n        this.injector = injector;\n        this.componentFactoryResolver = componentFactoryResolver;\n    }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n    constructor(template, viewContainerRef, context) {\n        super();\n        this.templateRef = template;\n        this.viewContainerRef = viewContainerRef;\n        this.context = context;\n    }\n    get origin() {\n        return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    attach(host, context = this.context) {\n        this.context = context;\n        return super.attach(host);\n    }\n    detach() {\n        this.context = undefined;\n        return super.detach();\n    }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass DomPortal extends Portal {\n    constructor(element) {\n        super();\n        this.element = element instanceof ElementRef ? element.nativeElement : element;\n    }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n    constructor() {\n        /** Whether this host has already been permanently disposed. */\n        this._isDisposed = false;\n        // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n        this.attachDomPortal = null;\n    }\n    /** Whether this host has an attached portal. */\n    hasAttached() {\n        return !!this._attachedPortal;\n    }\n    /** Attaches a portal. */\n    attach(portal) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!portal) {\n                throwNullPortalError();\n            }\n            if (this.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n            if (this._isDisposed) {\n                throwPortalOutletAlreadyDisposedError();\n            }\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n            // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n        }\n        else if (this.attachDomPortal && portal instanceof DomPortal) {\n            this._attachedPortal = portal;\n            return this.attachDomPortal(portal);\n        }\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwUnknownPortalTypeError();\n        }\n    }\n    /** Detaches a previously attached portal. */\n    detach() {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    }\n    /** Permanently dispose of this portal host. */\n    dispose() {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    }\n    /** @docs-private */\n    setDisposeFn(fn) {\n        this._disposeFn = fn;\n    }\n    _invokeDisposeFn() {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n    constructor(\n    /** Element into which the content is projected. */\n    outletElement, _componentFactoryResolver, _appRef, _defaultInjector, \n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document) {\n        super();\n        this.outletElement = outletElement;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._defaultInjector = _defaultInjector;\n        /**\n         * Attaches a DOM portal by transferring its content into the outlet.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 10.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            element.parentNode.insertBefore(anchorNode, element);\n            this.outletElement.appendChild(element);\n            this._attachedPortal = portal;\n            super.setDisposeFn(() => {\n                // We can't use `replaceWith` here because IE doesn't support it.\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        let componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n            this.setDisposeFn(() => componentRef.destroy());\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(() => {\n                this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        this._attachedPortal = portal;\n        return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        let viewContainer = portal.viewContainerRef;\n        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n        // Note that we want to detect changes after the nodes have been moved so that\n        // any directives inside the portal that are looking at the DOM inside a lifecycle\n        // hook won't be invoked too early.\n        viewRef.detectChanges();\n        this.setDisposeFn((() => {\n            let index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        this._attachedPortal = portal;\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     */\n    dispose() {\n        super.dispose();\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    }\n    /** Gets the root HTMLElement for an instantiated component. */\n    _getComponentRootNode(componentRef) {\n        return componentRef.hostView.rootNodes[0];\n    }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nclass CdkPortal extends TemplatePortal {\n    constructor(templateRef, viewContainerRef) {\n        super(templateRef, viewContainerRef);\n    }\n}\nCdkPortal.fac = function CdkPortal_Factory(t) { return new (t || CdkPortal)(ngcc0.directiveInject(ngcc0.TemplateRef), ngcc0.directiveInject(ngcc0.ViewContainerRef)); };\nCdkPortal.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkPortal, selectors: [[\"\", \"cdkPortal\", \"\"]], exportAs: [\"cdkPortal\"], features: [ngcc0.InheritDefinitionFeature] });\nCdkPortal.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ViewContainerRef }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkPortal, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkPortal]',\n                exportAs: 'cdkPortal'\n            }]\n    }], function () { return [{ type: ngcc0.TemplateRef }, { type: ngcc0.ViewContainerRef }]; }, null); })();\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\nclass TemplatePortalDirective extends CdkPortal {\n}\nTemplatePortalDirective.fac = /*@__PURE__*/ function () { let TemplatePortalDirective_BaseFactory; return function TemplatePortalDirective_Factory(t) { return (TemplatePortalDirective_BaseFactory || (TemplatePortalDirective_BaseFactory = ngcc0.getInheritedFactory(TemplatePortalDirective)))(t || TemplatePortalDirective); }; }();\nTemplatePortalDirective.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: TemplatePortalDirective, selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]], exportAs: [\"cdkPortal\"], features: [ngcc0.ProvidersFeature([{\n                provide: CdkPortal,\n                useExisting: TemplatePortalDirective\n            }]), ngcc0.InheritDefinitionFeature] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(TemplatePortalDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[cdk-portal], [portal]',\n                exportAs: 'cdkPortal',\n                providers: [{\n                        provide: CdkPortal,\n                        useExisting: TemplatePortalDirective\n                    }]\n            }]\n    }], null, null); })();\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nclass CdkPortalOutlet extends BasePortalOutlet {\n    constructor(_componentFactoryResolver, _viewContainerRef, \n    /**\n     * @deprecated `_document` parameter to be made required.\n     * @breaking-change 9.0.0\n     */\n    _document) {\n        super();\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._viewContainerRef = _viewContainerRef;\n        /** Whether the portal component is initialized. */\n        this._isInitialized = false;\n        /** Emits when a portal is attached to the outlet. */\n        this.attached = new EventEmitter();\n        /**\n         * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 9.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            portal.setAttachedHost(this);\n            element.parentNode.insertBefore(anchorNode, element);\n            this._getRootNode().appendChild(element);\n            this._attachedPortal = portal;\n            super.setDisposeFn(() => {\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /** Portal associated with the Portal outlet. */\n    get portal() {\n        return this._attachedPortal;\n    }\n    set portal(portal) {\n        // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n        // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n        // and attach a portal programmatically in the parent component. When Angular does the first CD\n        // round, it will fire the setter with empty string, causing the user's content to be cleared.\n        if (this.hasAttached() && !portal && !this._isInitialized) {\n            return;\n        }\n        if (this.hasAttached()) {\n            super.detach();\n        }\n        if (portal) {\n            super.attach(portal);\n        }\n        this._attachedPortal = portal;\n    }\n    /** Component or view reference that is attached to the portal. */\n    get attachedRef() {\n        return this._attachedRef;\n    }\n    ngOnInit() {\n        this._isInitialized = true;\n    }\n    ngOnDestroy() {\n        super.dispose();\n        this._attachedPortal = null;\n        this._attachedRef = null;\n    }\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        const viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n        // If we're using a view container that's different from the injected one (e.g. when the portal\n        // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n        // inside of the alternate view container.\n        if (viewContainerRef !== this._viewContainerRef) {\n            this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n        }\n        super.setDisposeFn(() => ref.destroy());\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n    }\n    /**\n     * Attach the given TemplatePortal to this PortalHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        portal.setAttachedHost(this);\n        const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        super.setDisposeFn(() => this._viewContainerRef.clear());\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n    }\n    /** Gets the root node of the portal outlet. */\n    _getRootNode() {\n        const nativeElement = this._viewContainerRef.element.nativeElement;\n        // The directive could be set on a template which will result in a comment\n        // node being the root. Use the comment's parent node if that is the case.\n        return (nativeElement.nodeType === nativeElement.ELEMENT_NODE ?\n            nativeElement : nativeElement.parentNode);\n    }\n}\nCdkPortalOutlet.fac = function CdkPortalOutlet_Factory(t) { return new (t || CdkPortalOutlet)(ngcc0.directiveInject(ngcc0.ComponentFactoryResolver), ngcc0.directiveInject(ngcc0.ViewContainerRef), ngcc0.directiveInject(DOCUMENT)); };\nCdkPortalOutlet.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkPortalOutlet, selectors: [[\"\", \"cdkPortalOutlet\", \"\"]], inputs: { portal: [\"cdkPortalOutlet\", \"portal\"] }, outputs: { attached: \"attached\" }, exportAs: [\"cdkPortalOutlet\"], features: [ngcc0.InheritDefinitionFeature] });\nCdkPortalOutlet.ctorParameters = () => [\n    { type: ComponentFactoryResolver },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nCdkPortalOutlet.propDecorators = {\n    attached: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkPortalOutlet, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkPortalOutlet]',\n                exportAs: 'cdkPortalOutlet',\n                inputs: ['portal: cdkPortalOutlet']\n            }]\n    }], function () { return [{ type: ngcc0.ComponentFactoryResolver }, { type: ngcc0.ViewContainerRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, { attached: [{\n            type: Output\n        }] }); })();\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass PortalHostDirective extends CdkPortalOutlet {\n}\nPortalHostDirective.fac = /*@__PURE__*/ function () { let PortalHostDirective_BaseFactory; return function PortalHostDirective_Factory(t) { return (PortalHostDirective_BaseFactory || (PortalHostDirective_BaseFactory = ngcc0.getInheritedFactory(PortalHostDirective)))(t || PortalHostDirective); }; }();\nPortalHostDirective.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: PortalHostDirective, selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]], inputs: { portal: [\"cdkPortalHost\", \"portal\"] }, exportAs: [\"cdkPortalHost\"], features: [ngcc0.ProvidersFeature([{\n                provide: CdkPortalOutlet,\n                useExisting: PortalHostDirective\n            }]), ngcc0.InheritDefinitionFeature] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(PortalHostDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkPortalHost], [portalHost]',\n                exportAs: 'cdkPortalHost',\n                inputs: ['portal: cdkPortalHost'],\n                providers: [{\n                        provide: CdkPortalOutlet,\n                        useExisting: PortalHostDirective\n                    }]\n            }]\n    }], null, null); })();\nclass PortalModule {\n}\nPortalModule.fac = function PortalModule_Factory(t) { return new (t || PortalModule)(); };\nPortalModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: PortalModule });\nPortalModule.inj = /*@__PURE__*/ ngcc0.defineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(PortalModule, [{\n        type: NgModule,\n        args: [{\n                exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n                declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(PortalModule, { declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective], exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n    constructor(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    get(token, notFoundValue) {\n        const value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BasePortalHost, BasePortalOutlet, CdkPortal, CdkPortalOutlet, ComponentPortal, DomPortal, DomPortalHost, DomPortalOutlet, Portal, PortalHostDirective, PortalInjector, PortalModule, TemplatePortal, TemplatePortalDirective };\n\n","import { coerceNumberProperty, coerceElement, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, forwardRef, Input, Injectable, NgZone, Optional, Inject, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Output, ViewChild, ViewContainerRef, TemplateRef, IterableDiffers, SkipSelf, NgModule } from '@angular/core';\nimport { Subject, of, Observable, fromEvent, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/platform';\nimport { Platform, getRtlScrollAxisType, supportsScrollBehavior, PlatformModule } from '@angular/cdk/platform';\nimport * as i2 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { isDataSource, ArrayDataSource, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the virtual scrolling strategy. */\nimport * as ngcc0 from '@angular/core';\nimport * as ngcc1 from '@angular/cdk/platform';\nimport * as ngcc2 from '@angular/cdk/bidi';\nimport * as ngcc3 from '@angular/cdk/collections';\n\nconst _c0 = [\"contentWrapper\"];\nconst _c1 = [\"*\"];\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new Subject();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() { }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() { }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        // Prevent NaN as result when dividing by zero.\n        let firstVisibleIndex = (this._itemSize > 0) ? scrollOffset / this._itemSize : 0;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports fixed-size items. */\nclass CdkFixedSizeVirtualScroll {\n    constructor() {\n        this._itemSize = 20;\n        this._minBufferPx = 100;\n        this._maxBufferPx = 200;\n        /** The scroll strategy used by this directive. */\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    /** The size of the items in the list (in pixels). */\n    get itemSize() { return this._itemSize; }\n    set itemSize(value) { this._itemSize = coerceNumberProperty(value); }\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx() { return this._minBufferPx; }\n    set minBufferPx(value) { this._minBufferPx = coerceNumberProperty(value); }\n    /**\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n     */\n    get maxBufferPx() { return this._maxBufferPx; }\n    set maxBufferPx(value) { this._maxBufferPx = coerceNumberProperty(value); }\n    ngOnChanges() {\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n}\nCdkFixedSizeVirtualScroll.fac = function CdkFixedSizeVirtualScroll_Factory(t) { return new (t || CdkFixedSizeVirtualScroll)(); };\nCdkFixedSizeVirtualScroll.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkFixedSizeVirtualScroll, selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]], inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, features: [ngcc0.ProvidersFeature([{\n                provide: VIRTUAL_SCROLL_STRATEGY,\n                useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\n            }]), ngcc0.NgOnChangesFeature] });\nCdkFixedSizeVirtualScroll.propDecorators = {\n    itemSize: [{ type: Input }],\n    minBufferPx: [{ type: Input }],\n    maxBufferPx: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkFixedSizeVirtualScroll, [{\n        type: Directive,\n        args: [{\n                selector: 'cdk-virtual-scroll-viewport[itemSize]',\n                providers: [{\n                        provide: VIRTUAL_SCROLL_STRATEGY,\n                        useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\n                    }]\n            }]\n    }], function () { return []; }, { itemSize: [{\n            type: Input\n        }], minBufferPx: [{\n            type: Input\n        }], maxBufferPx: [{\n            type: Input\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nclass ScrollDispatcher {\n    constructor(_ngZone, _platform, document) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n        this._scrolled = new Subject();\n        /** Keeps track of the global `scroll` and `resize` subscriptions. */\n        this._globalSubscription = null;\n        /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n        this._document = document;\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    register(scrollable) {\n        if (!this.scrollContainers.has(scrollable)) {\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n                .subscribe(() => this._scrolled.next(scrollable)));\n        }\n    }\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    deregister(scrollable) {\n        const scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    }\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n        if (!this._platform.isBrowser) {\n            return of();\n        }\n        return new Observable((observer) => {\n            if (!this._globalSubscription) {\n                this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            const subscription = auditTimeInMs > 0 ?\n                this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                this._scrolled.subscribe(observer);\n            this._scrolledCount++;\n            return () => {\n                subscription.unsubscribe();\n                this._scrolledCount--;\n                if (!this._scrolledCount) {\n                    this._removeGlobalListener();\n                }\n            };\n        });\n    }\n    ngOnDestroy() {\n        this._removeGlobalListener();\n        this.scrollContainers.forEach((_, container) => this.deregister(container));\n        this._scrolled.complete();\n    }\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementOrElementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(target => {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    }\n    /** Returns all registered Scrollables that contain the provided element. */\n    getAncestorScrollContainers(elementOrElementRef) {\n        const scrollingContainers = [];\n        this.scrollContainers.forEach((_subscription, scrollable) => {\n            if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Returns true if the element is contained within the provided Scrollable. */\n    _scrollableContainsElement(scrollable, elementOrElementRef) {\n        let element = coerceElement(elementOrElementRef);\n        let scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    }\n    /** Sets up the global scroll listeners. */\n    _addGlobalListener() {\n        this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n            const window = this._getWindow();\n            return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n        });\n    }\n    /** Cleans up the global scroll listener. */\n    _removeGlobalListener() {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    }\n}\nScrollDispatcher.fac = function ScrollDispatcher_Factory(t) { return new (t || ScrollDispatcher)(ngcc0.inject(ngcc0.NgZone), ngcc0.inject(ngcc1.Platform), ngcc0.inject(DOCUMENT, 8)); };\nScrollDispatcher.prov = i0.defineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(i0.inject(i0.NgZone), i0.inject(i1.Platform), i0.inject(i2.DOCUMENT, 8)); }, token: ScrollDispatcher, providedIn: \"root\" });\nScrollDispatcher.ctorParameters = () => [\n    { type: NgZone },\n    { type: Platform },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ScrollDispatcher, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc0.NgZone }, { type: ngcc1.Platform }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nclass CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        this.elementRef = elementRef;\n        this.scrollDispatcher = scrollDispatcher;\n        this.ngZone = ngZone;\n        this.dir = dir;\n        this._destroyed = new Subject();\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\n            .subscribe(observer)));\n    }\n    ngOnInit() {\n        this.scrollDispatcher.register(this);\n    }\n    ngOnDestroy() {\n        this.scrollDispatcher.deregister(this);\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Returns observable that emits when a scroll event is fired on the host element. */\n    elementScrolled() {\n        return this._elementScrolled;\n    }\n    /** Gets the ElementRef for the viewport. */\n    getElementRef() {\n        return this.elementRef;\n    }\n    /**\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param options specified the offsets to scroll to.\n     */\n    scrollTo(options) {\n        const el = this.elementRef.nativeElement;\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        // Rewrite start & end offsets as right or left offsets.\n        if (options.left == null) {\n            options.left = isRtl ? options.end : options.start;\n        }\n        if (options.right == null) {\n            options.right = isRtl ? options.start : options.end;\n        }\n        // Rewrite the bottom offset as a top offset.\n        if (options.bottom != null) {\n            options.top =\n                el.scrollHeight - el.clientHeight - options.bottom;\n        }\n        // Rewrite the right offset as a left offset.\n        if (isRtl && getRtlScrollAxisType() != 0 /* NORMAL */) {\n            if (options.left != null) {\n                options.right =\n                    el.scrollWidth - el.clientWidth - options.left;\n            }\n            if (getRtlScrollAxisType() == 2 /* INVERTED */) {\n                options.left = options.right;\n            }\n            else if (getRtlScrollAxisType() == 1 /* NEGATED */) {\n                options.left = options.right ? -options.right : options.right;\n            }\n        }\n        else {\n            if (options.right != null) {\n                options.left =\n                    el.scrollWidth - el.clientWidth - options.right;\n            }\n        }\n        this._applyScrollToOptions(options);\n    }\n    _applyScrollToOptions(options) {\n        const el = this.elementRef.nativeElement;\n        if (supportsScrollBehavior()) {\n            el.scrollTo(options);\n        }\n        else {\n            if (options.top != null) {\n                el.scrollTop = options.top;\n            }\n            if (options.left != null) {\n                el.scrollLeft = options.left;\n            }\n        }\n    }\n    /**\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param from The edge to measure from.\n     */\n    measureScrollOffset(from) {\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const el = this.elementRef.nativeElement;\n        if (from == 'top') {\n            return el.scrollTop;\n        }\n        if (from == 'bottom') {\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\n        }\n        // Rewrite start & end as left or right offsets.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        if (from == 'start') {\n            from = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            from = isRtl ? LEFT : RIGHT;\n        }\n        if (isRtl && getRtlScrollAxisType() == 2 /* INVERTED */) {\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n            else {\n                return el.scrollLeft;\n            }\n        }\n        else if (isRtl && getRtlScrollAxisType() == 1 /* NEGATED */) {\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\n            }\n            else {\n                return -el.scrollLeft;\n            }\n        }\n        else {\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n            // (scrollWidth - clientWidth) when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft;\n            }\n            else {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n        }\n    }\n}\nCdkScrollable.fac = function CdkScrollable_Factory(t) { return new (t || CdkScrollable)(ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(ScrollDispatcher), ngcc0.directiveInject(ngcc0.NgZone), ngcc0.directiveInject(ngcc2.Directionality, 8)); };\nCdkScrollable.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkScrollable, selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]] });\nCdkScrollable.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ScrollDispatcher },\n    { type: NgZone },\n    { type: Directionality, decorators: [{ type: Optional }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkScrollable, [{\n        type: Directive,\n        args: [{\n                selector: '[cdk-scrollable], [cdkScrollable]'\n            }]\n    }], function () { return [{ type: ngcc0.ElementRef }, { type: ScrollDispatcher }, { type: ngcc0.NgZone }, { type: ngcc2.Directionality, decorators: [{\n                type: Optional\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\nclass ViewportRuler {\n    constructor(_platform, ngZone, document) {\n        this._platform = _platform;\n        /** Stream of viewport change events. */\n        this._change = new Subject();\n        /** Event listener that will be used to handle the viewport change events. */\n        this._changeListener = (event) => {\n            this._change.next(event);\n        };\n        this._document = document;\n        ngZone.runOutsideAngular(() => {\n            if (_platform.isBrowser) {\n                const window = this._getWindow();\n                // Note that bind the events ourselves, rather than going through something like RxJS's\n                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n                window.addEventListener('resize', this._changeListener);\n                window.addEventListener('orientationchange', this._changeListener);\n            }\n            // Clear the cached position so that the viewport is re-measured next time it is required.\n            // We don't need to keep track of the subscription, because it is completed on destroy.\n            this.change().subscribe(() => this._viewportSize = null);\n        });\n    }\n    ngOnDestroy() {\n        if (this._platform.isBrowser) {\n            const window = this._getWindow();\n            window.removeEventListener('resize', this._changeListener);\n            window.removeEventListener('orientationchange', this._changeListener);\n        }\n        this._change.complete();\n    }\n    /** Returns the viewport's width and height. */\n    getViewportSize() {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n        if (!this._platform.isBrowser) {\n            this._viewportSize = null;\n        }\n        return output;\n    }\n    /** Gets a ClientRect for the viewport's bounds. */\n    getViewportRect() {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        const scrollPosition = this.getViewportScrollPosition();\n        const { width, height } = this.getViewportSize();\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height,\n            width,\n        };\n    }\n    /** Gets the (top, left) scroll position of the viewport. */\n    getViewportScrollPosition() {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n            return { top: 0, left: 0 };\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        const document = this._document;\n        const window = this._getWindow();\n        const documentElement = document.documentElement;\n        const documentRect = documentElement.getBoundingClientRect();\n        const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            documentElement.scrollTop || 0;\n        const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            documentElement.scrollLeft || 0;\n        return { top, left };\n    }\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * This stream emits outside of the Angular zone.\n     * @param throttleTime Time in milliseconds to throttle the stream.\n     */\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Updates the cached viewport size. */\n    _updateViewportSize() {\n        const window = this._getWindow();\n        this._viewportSize = this._platform.isBrowser ?\n            { width: window.innerWidth, height: window.innerHeight } :\n            { width: 0, height: 0 };\n    }\n}\nViewportRuler.fac = function ViewportRuler_Factory(t) { return new (t || ViewportRuler)(ngcc0.inject(ngcc1.Platform), ngcc0.inject(ngcc0.NgZone), ngcc0.inject(DOCUMENT, 8)); };\nViewportRuler.prov = i0.defineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(i0.inject(i1.Platform), i0.inject(i0.NgZone), i0.inject(i2.DOCUMENT, 8)); }, token: ViewportRuler, providedIn: \"root\" });\nViewportRuler.ctorParameters = () => [\n    { type: Platform },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ViewportRuler, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ngcc1.Platform }, { type: ngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nclass CdkVirtualScrollViewport extends CdkScrollable {\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n        this.elementRef = elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._scrollStrategy = _scrollStrategy;\n        /** Emits when the viewport is detached from a CdkVirtualForOf. */\n        this._detachedSubject = new Subject();\n        /** Emits when the rendered range changes. */\n        this._renderedRangeSubject = new Subject();\n        this._orientation = 'vertical';\n        this._appendOnly = false;\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\n        // performance.\n        /** Emits when the index of the first element visible in the viewport changes. */\n        this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n        /** A stream that emits whenever the rendered range changes. */\n        this.renderedRangeStream = this._renderedRangeSubject;\n        /**\n         * The total size of all content (in pixels), including content that is not currently rendered.\n         */\n        this._totalContentSize = 0;\n        /** A string representing the `style.width` property value to be used for the spacer element. */\n        this._totalContentWidth = '';\n        /** A string representing the `style.height` property value to be used for the spacer element. */\n        this._totalContentHeight = '';\n        /** The currently rendered range of indices. */\n        this._renderedRange = { start: 0, end: 0 };\n        /** The length of the data bound to this viewport (in number of items). */\n        this._dataLength = 0;\n        /** The size of the viewport (in pixels). */\n        this._viewportSize = 0;\n        /** The last rendered content offset that was set. */\n        this._renderedContentOffset = 0;\n        /**\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\n         * be rewritten as an offset to the start of the content).\n         */\n        this._renderedContentOffsetNeedsRewrite = false;\n        /** Whether there is a pending change detection cycle. */\n        this._isChangeDetectionPending = false;\n        /** A list of functions to run after the next change detection cycle. */\n        this._runAfterChangeDetection = [];\n        /** Subscription to changes in the viewport size. */\n        this._viewportChanges = Subscription.EMPTY;\n        if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n        }\n        this._viewportChanges = viewportRuler.change().subscribe(() => {\n            this.checkViewportSize();\n        });\n    }\n    /** The direction the viewport scrolls. */\n    get orientation() {\n        return this._orientation;\n    }\n    set orientation(orientation) {\n        if (this._orientation !== orientation) {\n            this._orientation = orientation;\n            this._calculateSpacerSize();\n        }\n    }\n    /**\n     * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n     * will be removed.\n     */\n    get appendOnly() {\n        return this._appendOnly;\n    }\n    set appendOnly(value) {\n        this._appendOnly = coerceBooleanProperty(value);\n    }\n    ngOnInit() {\n        super.ngOnInit();\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\n        // ourselves instead.\n        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n            this._measureViewportSize();\n            this._scrollStrategy.attach(this);\n            this.elementScrolled()\n                .pipe(\n            // Start off with a fake scroll event so we properly detect our initial position.\n            startWith(null), \n            // Collect multiple events into one until the next animation frame. This way if\n            // there are multiple scroll events in the same frame we only need to recheck\n            // our layout once.\n            auditTime(0, SCROLL_SCHEDULER))\n                .subscribe(() => this._scrollStrategy.onContentScrolled());\n            this._markChangeDetectionNeeded();\n        }));\n    }\n    ngOnDestroy() {\n        this.detach();\n        this._scrollStrategy.detach();\n        // Complete all subjects\n        this._renderedRangeSubject.complete();\n        this._detachedSubject.complete();\n        this._viewportChanges.unsubscribe();\n        super.ngOnDestroy();\n    }\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n    attach(forOf) {\n        if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CdkVirtualScrollViewport is already attached.');\n        }\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n        // change detection loop ourselves.\n        this.ngZone.runOutsideAngular(() => {\n            this._forOf = forOf;\n            this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n                const newLength = data.length;\n                if (newLength !== this._dataLength) {\n                    this._dataLength = newLength;\n                    this._scrollStrategy.onDataLengthChanged();\n                }\n                this._doChangeDetection();\n            });\n        });\n    }\n    /** Detaches the current `CdkVirtualForOf`. */\n    detach() {\n        this._forOf = null;\n        this._detachedSubject.next();\n    }\n    /** Gets the length of the data bound to this viewport (in number of items). */\n    getDataLength() {\n        return this._dataLength;\n    }\n    /** Gets the size of the viewport (in pixels). */\n    getViewportSize() {\n        return this._viewportSize;\n    }\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n    // setting it to something else, but its error prone and should probably be split into\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n    /** Get the current rendered range of items. */\n    getRenderedRange() {\n        return this._renderedRange;\n    }\n    /**\n     * Sets the total size of all content (in pixels), including content that is not currently\n     * rendered.\n     */\n    setTotalContentSize(size) {\n        if (this._totalContentSize !== size) {\n            this._totalContentSize = size;\n            this._calculateSpacerSize();\n            this._markChangeDetectionNeeded();\n        }\n    }\n    /** Sets the currently rendered range of indices. */\n    setRenderedRange(range) {\n        if (!rangesEqual(this._renderedRange, range)) {\n            if (this.appendOnly) {\n                range = { start: 0, end: Math.max(this._renderedRange.end, range.end) };\n            }\n            this._renderedRangeSubject.next(this._renderedRange = range);\n            this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n        }\n    }\n    /**\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n     */\n    getOffsetToRenderedContentStart() {\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n    }\n    /**\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\n     * (in pixels).\n     */\n    setRenderedContentOffset(offset, to = 'to-start') {\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n        // in the negative direction.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        const isHorizontal = this.orientation == 'horizontal';\n        const axis = isHorizontal ? 'X' : 'Y';\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n        this._renderedContentOffset = offset;\n        if (to === 'to-end') {\n            transform += ` translate${axis}(-100%)`;\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n            // expand upward).\n            this._renderedContentOffsetNeedsRewrite = true;\n        }\n        if (this._renderedContentTransform != transform) {\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\n            // into the string.\n            this._renderedContentTransform = transform;\n            this._markChangeDetectionNeeded(() => {\n                if (this._renderedContentOffsetNeedsRewrite) {\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\n                    this._renderedContentOffsetNeedsRewrite = false;\n                    this.setRenderedContentOffset(this._renderedContentOffset);\n                }\n                else {\n                    this._scrollStrategy.onRenderedOffsetChanged();\n                }\n            });\n        }\n    }\n    /**\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n     * @param offset The offset to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToOffset(offset, behavior = 'auto') {\n        const options = { behavior };\n        if (this.orientation === 'horizontal') {\n            options.start = offset;\n        }\n        else {\n            options.top = offset;\n        }\n        this.scrollTo(options);\n    }\n    /**\n     * Scrolls to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToIndex(index, behavior = 'auto') {\n        this._scrollStrategy.scrollToIndex(index, behavior);\n    }\n    /**\n     * Gets the current scroll offset from the start of the viewport (in pixels).\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n     *     in horizontal mode.\n     */\n    measureScrollOffset(from) {\n        return from ?\n            super.measureScrollOffset(from) :\n            super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\n    }\n    /** Measure the combined size of all of the rendered items. */\n    measureRenderedContentSize() {\n        const contentEl = this._contentWrapper.nativeElement;\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n    }\n    /**\n     * Measure the total combined size of the given range. Throws if the range includes items that are\n     * not rendered.\n     */\n    measureRangeSize(range) {\n        if (!this._forOf) {\n            return 0;\n        }\n        return this._forOf.measureRangeSize(range, this.orientation);\n    }\n    /** Update the viewport dimensions and re-render. */\n    checkViewportSize() {\n        // TODO: Cleanup later when add logic for handling content resize\n        this._measureViewportSize();\n        this._scrollStrategy.onDataLengthChanged();\n    }\n    /** Measure the viewport size. */\n    _measureViewportSize() {\n        const viewportEl = this.elementRef.nativeElement;\n        this._viewportSize = this.orientation === 'horizontal' ?\n            viewportEl.clientWidth : viewportEl.clientHeight;\n    }\n    /** Queue up change detection to run. */\n    _markChangeDetectionNeeded(runAfter) {\n        if (runAfter) {\n            this._runAfterChangeDetection.push(runAfter);\n        }\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\n        if (!this._isChangeDetectionPending) {\n            this._isChangeDetectionPending = true;\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._doChangeDetection();\n            }));\n        }\n    }\n    /** Run change detection. */\n    _doChangeDetection() {\n        this._isChangeDetectionPending = false;\n        // Apply the content transform. The transform can't be set via an Angular binding because\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n        // the `Number` function first to coerce it to a numeric value.\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\n        // instead does not properly check the projected content.\n        this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n        const runAfterChangeDetection = this._runAfterChangeDetection;\n        this._runAfterChangeDetection = [];\n        for (const fn of runAfterChangeDetection) {\n            fn();\n        }\n    }\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\n    _calculateSpacerSize() {\n        this._totalContentHeight =\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n        this._totalContentWidth =\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n    }\n}\nCdkVirtualScrollViewport.fac = function CdkVirtualScrollViewport_Factory(t) { return new (t || CdkVirtualScrollViewport)(ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(ngcc0.ChangeDetectorRef), ngcc0.directiveInject(ngcc0.NgZone), ngcc0.directiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ngcc0.directiveInject(ngcc2.Directionality, 8), ngcc0.directiveInject(ScrollDispatcher), ngcc0.directiveInject(ViewportRuler)); };\nCdkVirtualScrollViewport.cmp = /*@__PURE__*/ ngcc0.defineComponent({ type: CdkVirtualScrollViewport, selectors: [[\"cdk-virtual-scroll-viewport\"]], viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) { if (rf & 1) {\n        ngcc0.viewQuery(_c0, 7);\n    } if (rf & 2) {\n        let _t;\n        ngcc0.queryRefresh(_t = ngcc0.loadQuery()) && (ctx._contentWrapper = _t.first);\n    } }, hostAttrs: [1, \"cdk-virtual-scroll-viewport\"], hostVars: 4, hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) { if (rf & 2) {\n        ngcc0.classProp(\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\n    } }, inputs: { orientation: \"orientation\", appendOnly: \"appendOnly\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, features: [ngcc0.ProvidersFeature([{\n                provide: CdkScrollable,\n                useExisting: CdkVirtualScrollViewport\n            }]), ngcc0.InheritDefinitionFeature], ngContentSelectors: _c1, decls: 10, vars: 4, consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]], template: function CdkVirtualScrollViewport_Template(rf, ctx) { if (rf & 1) {\n        ngcc0.projectionDef();\n        ngcc0.text(0, \"\\n\");\n        ngcc0.elementStart(1, \"div\", 0, 1);\n        ngcc0.text(3, \"\\n  \");\n        ngcc0.projection(4);\n        ngcc0.text(5, \"\\n\");\n        ngcc0.elementEnd();\n        ngcc0.text(6, \"\\n\");\n        ngcc0.text(7, \"\\n\");\n        ngcc0.element(8, \"div\", 2);\n        ngcc0.text(9, \"\\n\");\n    } if (rf & 2) {\n        ngcc0.advance(8);\n        ngcc0.styleProp(\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\n    } }, styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"], encapsulation: 2, changeDetection: 0 });\nCdkVirtualScrollViewport.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [VIRTUAL_SCROLL_STRATEGY,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: ScrollDispatcher },\n    { type: ViewportRuler }\n];\nCdkVirtualScrollViewport.propDecorators = {\n    orientation: [{ type: Input }],\n    appendOnly: [{ type: Input }],\n    scrolledIndexChange: [{ type: Output }],\n    _contentWrapper: [{ type: ViewChild, args: ['contentWrapper', { static: true },] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkVirtualScrollViewport, [{\n        type: Component,\n        args: [{\n                selector: 'cdk-virtual-scroll-viewport',\n                template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\",\n                host: {\n                    'class': 'cdk-virtual-scroll-viewport',\n                    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n                    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"'\n                },\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                providers: [{\n                        provide: CdkScrollable,\n                        useExisting: CdkVirtualScrollViewport\n                    }],\n                styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"]\n            }]\n    }], function () { return [{ type: ngcc0.ElementRef }, { type: ngcc0.ChangeDetectorRef }, { type: ngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [VIRTUAL_SCROLL_STRATEGY]\n            }] }, { type: ngcc2.Directionality, decorators: [{\n                type: Optional\n            }] }, { type: ScrollDispatcher }, { type: ViewportRuler }]; }, { scrolledIndexChange: [{\n            type: Output\n        }], orientation: [{\n            type: Input\n        }], appendOnly: [{\n            type: Input\n        }], _contentWrapper: [{\n            type: ViewChild,\n            args: ['contentWrapper', { static: true }]\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    if (orientation === 'horizontal') {\n        return direction === 'start' ? rect.left : rect.right;\n    }\n    return direction === 'start' ? rect.top : rect.bottom;\n}\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\nclass CdkVirtualForOf {\n    constructor(\n    /** The view container to add items to. */\n    _viewContainerRef, \n    /** The template to use when stamping out new items. */\n    _template, \n    /** The set of available differs. */\n    _differs, \n    /** The strategy used to render items in the virtual scroll viewport. */\n    _viewRepeater, \n    /** The virtual scrolling viewport that these items are being rendered in. */\n    _viewport, ngZone) {\n        this._viewContainerRef = _viewContainerRef;\n        this._template = _template;\n        this._differs = _differs;\n        this._viewRepeater = _viewRepeater;\n        this._viewport = _viewport;\n        /** Emits when the rendered view of the data changes. */\n        this.viewChange = new Subject();\n        /** Subject that emits when a new DataSource instance is given. */\n        this._dataSourceChanges = new Subject();\n        /** Emits whenever the data in the current DataSource changes. */\n        this.dataStream = this._dataSourceChanges\n            .pipe(\n        // Start off with null `DataSource`.\n        startWith(null), \n        // Bundle up the previous and current data sources so we can work with both.\n        pairwise(), \n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\n        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)), \n        // Replay the last emitted data when someone subscribes.\n        shareReplay(1));\n        /** The differ used to calculate changes to the data. */\n        this._differ = null;\n        /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n        this._needsUpdate = false;\n        this._destroyed = new Subject();\n        this.dataStream.subscribe(data => {\n            this._data = data;\n            this._onRenderedDataChange();\n        });\n        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n            this._renderedRange = range;\n            ngZone.run(() => this.viewChange.next(this._renderedRange));\n            this._onRenderedDataChange();\n        });\n        this._viewport.attach(this);\n    }\n    /** The DataSource to display. */\n    get cdkVirtualForOf() {\n        return this._cdkVirtualForOf;\n    }\n    set cdkVirtualForOf(value) {\n        this._cdkVirtualForOf = value;\n        if (isDataSource(value)) {\n            this._dataSourceChanges.next(value);\n        }\n        else {\n            // If value is an an NgIterable, convert it to an array.\n            this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\n        }\n    }\n    /**\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n     * the item and produces a value to be used as the item's identity when tracking changes.\n     */\n    get cdkVirtualForTrackBy() {\n        return this._cdkVirtualForTrackBy;\n    }\n    set cdkVirtualForTrackBy(fn) {\n        this._needsUpdate = true;\n        this._cdkVirtualForTrackBy = fn ?\n            (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\n            undefined;\n    }\n    /** The template used to stamp out new elements. */\n    set cdkVirtualForTemplate(value) {\n        if (value) {\n            this._needsUpdate = true;\n            this._template = value;\n        }\n    }\n    /**\n     * The size of the cache used to store templates that are not being used for re-use later.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n     */\n    get cdkVirtualForTemplateCacheSize() {\n        return this._viewRepeater.viewCacheSize;\n    }\n    set cdkVirtualForTemplateCacheSize(size) {\n        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\n    }\n    /**\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n     * in the specified range. Throws an error if the range includes items that are not currently\n     * rendered.\n     */\n    measureRangeSize(range, orientation) {\n        if (range.start >= range.end) {\n            return 0;\n        }\n        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\n        }\n        // The index into the list of rendered views for the first item in the range.\n        const renderedStartIndex = range.start - this._renderedRange.start;\n        // The length of the range we're measuring.\n        const rangeLen = range.end - range.start;\n        // Loop over all the views, find the first and land node and compute the size by subtracting\n        // the top of the first node from the bottom of the last one.\n        let firstNode;\n        let lastNode;\n        // Find the first node by starting from the beginning and going forwards.\n        for (let i = 0; i < rangeLen; i++) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                firstNode = lastNode = view.rootNodes[0];\n                break;\n            }\n        }\n        // Find the last node by starting from the end and going backwards.\n        for (let i = rangeLen - 1; i > -1; i--) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                lastNode = view.rootNodes[view.rootNodes.length - 1];\n                break;\n            }\n        }\n        return firstNode && lastNode ?\n            getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;\n    }\n    ngDoCheck() {\n        if (this._differ && this._needsUpdate) {\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n            // changing (need to do this diff).\n            const changes = this._differ.diff(this._renderedItems);\n            if (!changes) {\n                this._updateContext();\n            }\n            else {\n                this._applyChanges(changes);\n            }\n            this._needsUpdate = false;\n        }\n    }\n    ngOnDestroy() {\n        this._viewport.detach();\n        this._dataSourceChanges.next(undefined);\n        this._dataSourceChanges.complete();\n        this.viewChange.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._viewRepeater.detach();\n    }\n    /** React to scroll state changes in the viewport. */\n    _onRenderedDataChange() {\n        if (!this._renderedRange) {\n            return;\n        }\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n        if (!this._differ) {\n            // Use a wrapper function for the `trackBy` so any new values are\n            // picked up automatically without having to recreate the differ.\n            this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n                return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n            });\n        }\n        this._needsUpdate = true;\n    }\n    /** Swap out one `DataSource` for another. */\n    _changeDataSource(oldDs, newDs) {\n        if (oldDs) {\n            oldDs.disconnect(this);\n        }\n        this._needsUpdate = true;\n        return newDs ? newDs.connect(this) : of();\n    }\n    /** Update the `CdkVirtualForOfContext` for all views. */\n    _updateContext() {\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n            view.detectChanges();\n        }\n    }\n    /** Apply changes to the DOM. */\n    _applyChanges(changes) {\n        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);\n        // Update $implicit for any items that had an identity change.\n        changes.forEachIdentityChange((record) => {\n            const view = this._viewContainerRef.get(record.currentIndex);\n            view.context.$implicit = record.item;\n        });\n        // Update the context variables on all items.\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n        }\n    }\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\n    _updateComputedContextProperties(context) {\n        context.first = context.index === 0;\n        context.last = context.index === context.count - 1;\n        context.even = context.index % 2 === 0;\n        context.odd = !context.even;\n    }\n    _getEmbeddedViewArgs(record, index) {\n        // Note that it's important that we insert the item directly at the proper index,\n        // rather than inserting it and the moving it in place, because if there's a directive\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\n        // comment node which can throw off the move when it's being repeated for all items.\n        return {\n            templateRef: this._template,\n            context: {\n                $implicit: record.item,\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                cdkVirtualForOf: this._cdkVirtualForOf,\n                index: -1,\n                count: -1,\n                first: false,\n                last: false,\n                odd: false,\n                even: false\n            },\n            index,\n        };\n    }\n}\nCdkVirtualForOf.fac = function CdkVirtualForOf_Factory(t) { return new (t || CdkVirtualForOf)(ngcc0.directiveInject(ngcc0.ViewContainerRef), ngcc0.directiveInject(ngcc0.TemplateRef), ngcc0.directiveInject(ngcc0.IterableDiffers), ngcc0.directiveInject(_VIEW_REPEATER_STRATEGY), ngcc0.directiveInject(CdkVirtualScrollViewport, 4), ngcc0.directiveInject(ngcc0.NgZone)); };\nCdkVirtualForOf.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: CdkVirtualForOf, selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]], inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, features: [ngcc0.ProvidersFeature([\n            { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\n        ])] });\nCdkVirtualForOf.ctorParameters = () => [\n    { type: ViewContainerRef },\n    { type: TemplateRef },\n    { type: IterableDiffers },\n    { type: _RecycleViewRepeaterStrategy, decorators: [{ type: Inject, args: [_VIEW_REPEATER_STRATEGY,] }] },\n    { type: CdkVirtualScrollViewport, decorators: [{ type: SkipSelf }] },\n    { type: NgZone }\n];\nCdkVirtualForOf.propDecorators = {\n    cdkVirtualForOf: [{ type: Input }],\n    cdkVirtualForTrackBy: [{ type: Input }],\n    cdkVirtualForTemplate: [{ type: Input }],\n    cdkVirtualForTemplateCacheSize: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkVirtualForOf, [{\n        type: Directive,\n        args: [{\n                selector: '[cdkVirtualFor][cdkVirtualForOf]',\n                providers: [\n                    { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\n                ]\n            }]\n    }], function () { return [{ type: ngcc0.ViewContainerRef }, { type: ngcc0.TemplateRef }, { type: ngcc0.IterableDiffers }, { type: ngcc3._RecycleViewRepeaterStrategy, decorators: [{\n                type: Inject,\n                args: [_VIEW_REPEATER_STRATEGY]\n            }] }, { type: CdkVirtualScrollViewport, decorators: [{\n                type: SkipSelf\n            }] }, { type: ngcc0.NgZone }]; }, { cdkVirtualForOf: [{\n            type: Input\n        }], cdkVirtualForTrackBy: [{\n            type: Input\n        }], cdkVirtualForTemplate: [{\n            type: Input\n        }], cdkVirtualForTemplateCacheSize: [{\n            type: Input\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass CdkScrollableModule {\n}\nCdkScrollableModule.fac = function CdkScrollableModule_Factory(t) { return new (t || CdkScrollableModule)(); };\nCdkScrollableModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: CdkScrollableModule });\nCdkScrollableModule.inj = /*@__PURE__*/ ngcc0.defineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(CdkScrollableModule, [{\n        type: NgModule,\n        args: [{\n                exports: [CdkScrollable],\n                declarations: [CdkScrollable]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(CdkScrollableModule, { declarations: [CdkScrollable], exports: [CdkScrollable] }); })();\n/**\n * @docs-primary-export\n */\nclass ScrollingModule {\n}\nScrollingModule.fac = function ScrollingModule_Factory(t) { return new (t || ScrollingModule)(); };\nScrollingModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: ScrollingModule });\nScrollingModule.inj = /*@__PURE__*/ ngcc0.defineInjector({ imports: [[\n            BidiModule,\n            PlatformModule,\n            CdkScrollableModule\n        ], BidiModule, CdkScrollableModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ScrollingModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    BidiModule,\n                    PlatformModule,\n                    CdkScrollableModule\n                ],\n                exports: [\n                    BidiModule,\n                    CdkScrollableModule,\n                    CdkFixedSizeVirtualScroll,\n                    CdkVirtualForOf,\n                    CdkVirtualScrollViewport,\n                ],\n                declarations: [\n                    CdkFixedSizeVirtualScroll,\n                    CdkVirtualForOf,\n                    CdkVirtualScrollViewport,\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(ScrollingModule, { declarations: function () { return [CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]; }, imports: function () { return [BidiModule,\n        PlatformModule, CdkScrollableModule]; }, exports: function () { return [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]; } }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };\n\n","import { Overlay, ScrollStrategyOptions, OverlayContainer, FullscreenOverlayContainer, OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { EventEmitter, Directive, TemplateRef, ElementRef, Input, Output, InjectionToken, QueryList, Component, ChangeDetectorRef, Optional, Inject, ViewChild, ViewChildren, HostListener, Injectable, ViewEncapsulation, ContentChildren, NgModule } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\n\nimport * as ngcc0 from '@angular/core';\nimport * as ngcc1 from '@angular/common';\nimport * as ngcc2 from '@angular/cdk/overlay';\n\nconst _c0 = [\"menu\"];\nconst _c1 = [\"li\"];\nfunction ContextMenuContentComponent_li_6_a_3_ng_template_2_Template(rf, ctx) { }\nconst _c2 = function (a0) { return { $implicit: a0 }; };\nfunction ContextMenuContentComponent_li_6_a_3_Template(rf, ctx) { if (rf & 1) {\n    const _r10 = ngcc0.getCurrentView();\n    ngcc0.elementStart(0, \"a\", 7);\n    ngcc0.listener(\"click\", function ContextMenuContentComponent_li_6_a_3_Template_a_click_0_listener($event) { ngcc0.restoreView(_r10); const menuItem_r2 = ngcc0.nextContext().$implicit; const ctx_r8 = ngcc0.nextContext(); return ctx_r8.onMenuItemSelect(menuItem_r2, $event); })(\"mouseenter\", function ContextMenuContentComponent_li_6_a_3_Template_a_mouseenter_0_listener($event) { ngcc0.restoreView(_r10); const menuItem_r2 = ngcc0.nextContext().$implicit; const ctx_r11 = ngcc0.nextContext(); return ctx_r11.onOpenSubMenu(menuItem_r2, $event); });\n    ngcc0.text(1, \"\\n            \");\n    ngcc0.template(2, ContextMenuContentComponent_li_6_a_3_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    ngcc0.text(3, \"\\n          \");\n    ngcc0.elementEnd();\n} if (rf & 2) {\n    const menuItem_r2 = ngcc0.nextContext().$implicit;\n    const ctx_r5 = ngcc0.nextContext();\n    ngcc0.classProp(\"dropdown-item\", ctx_r5.useBootstrap4)(\"active\", menuItem_r2.isActive && ctx_r5.isMenuItemEnabled(menuItem_r2))(\"disabled\", ctx_r5.useBootstrap4 && !ctx_r5.isMenuItemEnabled(menuItem_r2))(\"hasSubMenu\", !!menuItem_r2.subMenu);\n    ngcc0.advance(2);\n    ngcc0.property(\"ngTemplateOutlet\", menuItem_r2.template)(\"ngTemplateOutletContext\", ngcc0.pureFunction1(10, _c2, ctx_r5.item));\n} }\nfunction ContextMenuContentComponent_li_6_span_5_ng_template_2_Template(rf, ctx) { }\nfunction ContextMenuContentComponent_li_6_span_5_Template(rf, ctx) { if (rf & 1) {\n    const _r16 = ngcc0.getCurrentView();\n    ngcc0.elementStart(0, \"span\", 9);\n    ngcc0.listener(\"click\", function ContextMenuContentComponent_li_6_span_5_Template_span_click_0_listener($event) { ngcc0.restoreView(_r16); const ctx_r15 = ngcc0.nextContext(2); return ctx_r15.stopEvent($event); })(\"contextmenu\", function ContextMenuContentComponent_li_6_span_5_Template_span_contextmenu_0_listener($event) { ngcc0.restoreView(_r16); const ctx_r17 = ngcc0.nextContext(2); return ctx_r17.stopEvent($event); });\n    ngcc0.text(1, \"\\n            \");\n    ngcc0.template(2, ContextMenuContentComponent_li_6_span_5_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    ngcc0.text(3, \"\\n          \");\n    ngcc0.elementEnd();\n} if (rf & 2) {\n    const menuItem_r2 = ngcc0.nextContext().$implicit;\n    const ctx_r6 = ngcc0.nextContext();\n    ngcc0.classProp(\"dropdown-item\", ctx_r6.useBootstrap4)(\"disabled\", ctx_r6.useBootstrap4 && !ctx_r6.isMenuItemEnabled(menuItem_r2));\n    ngcc0.advance(2);\n    ngcc0.property(\"ngTemplateOutlet\", menuItem_r2.template)(\"ngTemplateOutletContext\", ngcc0.pureFunction1(6, _c2, ctx_r6.item));\n} }\nfunction ContextMenuContentComponent_li_6_Template(rf, ctx) { if (rf & 1) {\n    ngcc0.elementStart(0, \"li\", null, 4);\n    ngcc0.text(2, \"\\n          \");\n    ngcc0.template(3, ContextMenuContentComponent_li_6_a_3_Template, 4, 12, \"a\", 5);\n    ngcc0.text(4, \"\\n\\n          \");\n    ngcc0.template(5, ContextMenuContentComponent_li_6_span_5_Template, 4, 8, \"span\", 6);\n    ngcc0.text(6, \"\\n        \");\n    ngcc0.elementEnd();\n} if (rf & 2) {\n    const menuItem_r2 = ctx.$implicit;\n    const ctx_r1 = ngcc0.nextContext();\n    ngcc0.classProp(\"disabled\", !ctx_r1.isMenuItemEnabled(menuItem_r2))(\"divider\", menuItem_r2.divider)(\"dropdown-divider\", ctx_r1.useBootstrap4 && menuItem_r2.divider)(\"active\", menuItem_r2.isActive && ctx_r1.isMenuItemEnabled(menuItem_r2));\n    ngcc0.attribute(\"role\", menuItem_r2.divider ? \"separator\" : undefined);\n    ngcc0.advance(3);\n    ngcc0.property(\"ngIf\", !menuItem_r2.divider && !menuItem_r2.passive);\n    ngcc0.advance(2);\n    ngcc0.property(\"ngIf\", !menuItem_r2.divider && menuItem_r2.passive);\n} }\nclass ContextMenuItemDirective {\n    constructor(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    get disabled() {\n        return this.passive ||\n            this.divider ||\n            !this.evaluateIfFunction(this.enabled, this.currentItem);\n    }\n    evaluateIfFunction(value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    }\n    setActiveStyles() {\n        this.isActive = true;\n    }\n    setInactiveStyles() {\n        this.isActive = false;\n    }\n    triggerExecute(item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item });\n    }\n}\nContextMenuItemDirective.fac = function ContextMenuItemDirective_Factory(t) { return new (t || ContextMenuItemDirective)(ngcc0.directiveInject(ngcc0.TemplateRef), ngcc0.directiveInject(ngcc0.ElementRef)); };\nContextMenuItemDirective.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: ContextMenuItemDirective, selectors: [[\"\", \"contextMenuItem\", \"\"]], inputs: { divider: \"divider\", enabled: \"enabled\", passive: \"passive\", visible: \"visible\", subMenu: \"subMenu\" }, outputs: { execute: \"execute\" } });\n/** @nocollapse */\nContextMenuItemDirective.ctorParameters = () => [\n    { type: TemplateRef },\n    { type: ElementRef }\n];\nContextMenuItemDirective.propDecorators = {\n    subMenu: [{ type: Input }],\n    divider: [{ type: Input }],\n    enabled: [{ type: Input }],\n    passive: [{ type: Input }],\n    visible: [{ type: Input }],\n    execute: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContextMenuItemDirective, [{\n        type: Directive,\n        args: [{\n                /* tslint:disable:directive-selector-type */\n                selector: '[contextMenuItem]'\n            }]\n    }], function () { return [{ type: ngcc0.TemplateRef }, { type: ngcc0.ElementRef }]; }, { divider: [{\n            type: Input\n        }], enabled: [{\n            type: Input\n        }], passive: [{\n            type: Input\n        }], visible: [{\n            type: Input\n        }], execute: [{\n            type: Output\n        }], subMenu: [{\n            type: Input\n        }] }); })();\n\nconst CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n\nconst ARROW_LEFT_KEYCODE = 37;\nclass ContextMenuContentComponent {\n    constructor(changeDetector, elementRef, options) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ngOnInit() {\n        this.menuItems.forEach(menuItem => {\n            menuItem.currentItem = this.item;\n            this.subscription.add(menuItem.execute.subscribe(event => this.execute.emit(Object.assign(Object.assign({}, event), { menuItem }))));\n        });\n        const queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    }\n    ngAfterViewInit() {\n        if (this.autoFocus) {\n            setTimeout(() => this.focus());\n        }\n        this.overlay.updatePosition();\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n    focus() {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    }\n    stopEvent($event) {\n        $event.stopPropagation();\n    }\n    isMenuItemEnabled(menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    }\n    isMenuItemVisible(menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    }\n    evaluateIfFunction(value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    }\n    isDisabled(link) {\n        return link.enabled && !link.enabled(this.item);\n    }\n    onKeyEvent(event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    }\n    keyboardOpenSubMenu(event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        const menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    }\n    keyboardMenuItemSelect(event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        const menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    }\n    onCloseLeafMenu(event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({\n            exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE,\n            event\n        });\n    }\n    closeMenu(event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit({ event });\n    }\n    onOpenSubMenu(menuItem, event) {\n        const anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        const anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement,\n            contextMenu: menuItem.subMenu,\n            event,\n            item: this.item,\n            parentContextMenu: this\n        });\n    }\n    onMenuItemSelect(menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    }\n    cancelEvent(event) {\n        if (!event) {\n            return;\n        }\n        const target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 ||\n            target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    }\n}\nContextMenuContentComponent.fac = function ContextMenuContentComponent_Factory(t) { return new (t || ContextMenuContentComponent)(ngcc0.directiveInject(ngcc0.ChangeDetectorRef), ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(CONTEXT_MENU_OPTIONS, 8)); };\nContextMenuContentComponent.cmp = /*@__PURE__*/ ngcc0.defineComponent({ type: ContextMenuContentComponent, selectors: [[\"context-menu-content\"]], viewQuery: function ContextMenuContentComponent_Query(rf, ctx) { if (rf & 1) {\n        ngcc0.viewQuery(_c0, 7);\n        ngcc0.viewQuery(_c1, 5);\n    } if (rf & 2) {\n        let _t;\n        ngcc0.queryRefresh(_t = ngcc0.loadQuery()) && (ctx.menuElement = _t.first);\n        ngcc0.queryRefresh(_t = ngcc0.loadQuery()) && (ctx.menuItemElements = _t);\n    } }, hostBindings: function ContextMenuContentComponent_HostBindings(rf, ctx) { if (rf & 1) {\n        ngcc0.listener(\"keydown.ArrowDown\", function ContextMenuContentComponent_keydown_ArrowDown_HostBindingHandler($event) { return ctx.onKeyEvent($event); }, false, ngcc0.resolveWindow)(\"keydown.ArrowUp\", function ContextMenuContentComponent_keydown_ArrowUp_HostBindingHandler($event) { return ctx.onKeyEvent($event); }, false, ngcc0.resolveWindow)(\"keydown.ArrowRight\", function ContextMenuContentComponent_keydown_ArrowRight_HostBindingHandler($event) { return ctx.keyboardOpenSubMenu($event); }, false, ngcc0.resolveWindow)(\"keydown.Enter\", function ContextMenuContentComponent_keydown_Enter_HostBindingHandler($event) { return ctx.keyboardMenuItemSelect($event); }, false, ngcc0.resolveWindow)(\"keydown.Space\", function ContextMenuContentComponent_keydown_Space_HostBindingHandler($event) { return ctx.keyboardMenuItemSelect($event); }, false, ngcc0.resolveWindow)(\"keydown.Escape\", function ContextMenuContentComponent_keydown_Escape_HostBindingHandler($event) { return ctx.onCloseLeafMenu($event); }, false, ngcc0.resolveWindow)(\"keydown.ArrowLeft\", function ContextMenuContentComponent_keydown_ArrowLeft_HostBindingHandler($event) { return ctx.onCloseLeafMenu($event); }, false, ngcc0.resolveWindow)(\"click\", function ContextMenuContentComponent_click_HostBindingHandler($event) { return ctx.closeMenu($event); }, false, ngcc0.resolveDocument)(\"contextmenu\", function ContextMenuContentComponent_contextmenu_HostBindingHandler($event) { return ctx.closeMenu($event); }, false, ngcc0.resolveDocument);\n    } }, inputs: { menuItems: \"menuItems\", isLeaf: \"isLeaf\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", menuClass: \"menuClass\", overlay: \"overlay\" }, outputs: { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, decls: 10, vars: 2, consts: [[\"tabindex\", \"0\", 1, \"dropdown\", \"open\", \"show\", \"ngx-contextmenu\", 3, \"ngClass\"], [\"tabindex\", \"0\", 1, \"dropdown-menu\", \"show\", 2, \"position\", \"static\", \"float\", \"none\"], [\"menu\", \"\"], [3, \"disabled\", \"divider\", \"dropdown-divider\", \"active\", 4, \"ngFor\", \"ngForOf\"], [\"li\", \"\"], [\"href\", \"\", 3, \"dropdown-item\", \"active\", \"disabled\", \"hasSubMenu\", \"click\", \"mouseenter\", 4, \"ngIf\"], [\"class\", \"passive\", 3, \"dropdown-item\", \"disabled\", \"click\", \"contextmenu\", 4, \"ngIf\"], [\"href\", \"\", 3, \"click\", \"mouseenter\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"passive\", 3, \"click\", \"contextmenu\"]], template: function ContextMenuContentComponent_Template(rf, ctx) { if (rf & 1) {\n        ngcc0.text(0, \"\\n    \");\n        ngcc0.elementStart(1, \"div\", 0);\n        ngcc0.text(2, \"\\n      \");\n        ngcc0.elementStart(3, \"ul\", 1, 2);\n        ngcc0.text(5, \"\\n        \");\n        ngcc0.template(6, ContextMenuContentComponent_li_6_Template, 7, 11, \"li\", 3);\n        ngcc0.text(7, \"\\n      \");\n        ngcc0.elementEnd();\n        ngcc0.text(8, \"\\n    \");\n        ngcc0.elementEnd();\n        ngcc0.text(9, \"\\n  \");\n    } if (rf & 2) {\n        ngcc0.advance(1);\n        ngcc0.property(\"ngClass\", ctx.menuClass);\n        ngcc0.advance(5);\n        ngcc0.property(\"ngForOf\", ctx.menuItems);\n    } }, directives: [ngcc1.NgClass, ngcc1.NgForOf, ngcc1.NgIf, ngcc1.NgTemplateOutlet], styles: [\".passive[_ngcontent-%COMP%] {\\n        display: block;\\n        padding: 3px 20px;\\n        clear: both;\\n        font-weight: normal;\\n        line-height: @line-height-base;\\n        white-space: nowrap;\\n      }\\n      .hasSubMenu[_ngcontent-%COMP%]:before {\\n        content: '\\u25B6';\\n        float: right;\\n      }\"] });\n/** @nocollapse */\nContextMenuContentComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] }] }\n];\nContextMenuContentComponent.propDecorators = {\n    menuItems: [{ type: Input }],\n    item: [{ type: Input }],\n    event: [{ type: Input }],\n    parentContextMenu: [{ type: Input }],\n    menuClass: [{ type: Input }],\n    overlay: [{ type: Input }],\n    isLeaf: [{ type: Input }],\n    execute: [{ type: Output }],\n    openSubMenu: [{ type: Output }],\n    closeLeafMenu: [{ type: Output }],\n    closeAllMenus: [{ type: Output }],\n    menuElement: [{ type: ViewChild, args: ['menu', { static: true },] }],\n    menuItemElements: [{ type: ViewChildren, args: ['li',] }],\n    onKeyEvent: [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] }],\n    keyboardOpenSubMenu: [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] }],\n    keyboardMenuItemSelect: [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] }],\n    onCloseLeafMenu: [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] }],\n    closeMenu: [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContextMenuContentComponent, [{\n        type: Component,\n        args: [{\n                selector: 'context-menu-content',\n                template: `\n    <div\n      class=\"dropdown open show ngx-contextmenu\"\n      [ngClass]=\"menuClass\"\n      tabindex=\"0\"\n    >\n      <ul\n        #menu\n        class=\"dropdown-menu show\"\n        style=\"position: static; float: none;\"\n        tabindex=\"0\"\n      >\n        <li\n          #li\n          *ngFor=\"let menuItem of menuItems; let i = index\"\n          [class.disabled]=\"!isMenuItemEnabled(menuItem)\"\n          [class.divider]=\"menuItem.divider\"\n          [class.dropdown-divider]=\"useBootstrap4 && menuItem.divider\"\n          [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n          [attr.role]=\"menuItem.divider ? 'separator' : undefined\"\n        >\n          <a\n            *ngIf=\"!menuItem.divider && !menuItem.passive\"\n            href\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n            [class.hasSubMenu]=\"!!menuItem.subMenu\"\n            (click)=\"onMenuItemSelect(menuItem, $event)\"\n            (mouseenter)=\"onOpenSubMenu(menuItem, $event)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </a>\n\n          <span\n            (click)=\"stopEvent($event)\"\n            (contextmenu)=\"stopEvent($event)\"\n            class=\"passive\"\n            *ngIf=\"!menuItem.divider && menuItem.passive\"\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </span>\n        </li>\n      </ul>\n    </div>\n  `,\n                styles: [`\n      .passive {\n        display: block;\n        padding: 3px 20px;\n        clear: both;\n        font-weight: normal;\n        line-height: @line-height-base;\n        white-space: nowrap;\n      }\n      .hasSubMenu:before {\n        content: '\\u25B6';\n        float: right;\n      }\n    `]\n            }]\n    }], function () { return [{ type: ngcc0.ChangeDetectorRef }, { type: ngcc0.ElementRef }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [CONTEXT_MENU_OPTIONS]\n            }] }]; }, { menuItems: [{\n            type: Input\n        }], isLeaf: [{\n            type: Input\n        }], execute: [{\n            type: Output\n        }], openSubMenu: [{\n            type: Output\n        }], closeLeafMenu: [{\n            type: Output\n        }], closeAllMenus: [{\n            type: Output\n        }], onKeyEvent: [{\n            type: HostListener,\n            args: ['window:keydown.ArrowDown', ['$event']]\n        }, {\n            type: HostListener,\n            args: ['window:keydown.ArrowUp', ['$event']]\n        }], keyboardOpenSubMenu: [{\n            type: HostListener,\n            args: ['window:keydown.ArrowRight', ['$event']]\n        }], keyboardMenuItemSelect: [{\n            type: HostListener,\n            args: ['window:keydown.Enter', ['$event']]\n        }, {\n            type: HostListener,\n            args: ['window:keydown.Space', ['$event']]\n        }], onCloseLeafMenu: [{\n            type: HostListener,\n            args: ['window:keydown.Escape', ['$event']]\n        }, {\n            type: HostListener,\n            args: ['window:keydown.ArrowLeft', ['$event']]\n        }], closeMenu: [{\n            type: HostListener,\n            args: ['document:click', ['$event']]\n        }, {\n            type: HostListener,\n            args: ['document:contextmenu', ['$event']]\n        }], item: [{\n            type: Input\n        }], event: [{\n            type: Input\n        }], parentContextMenu: [{\n            type: Input\n        }], menuClass: [{\n            type: Input\n        }], overlay: [{\n            type: Input\n        }], menuElement: [{\n            type: ViewChild,\n            args: ['menu', { static: true }]\n        }], menuItemElements: [{\n            type: ViewChildren,\n            args: ['li']\n        }] }); })();\n\nclass ContextMenuService {\n    constructor(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: () => ({\n                bottom: 0,\n                height: 0,\n                left: 0,\n                right: 0,\n                top: 0,\n                width: 0,\n            })\n        };\n    }\n    openContextMenu(context) {\n        const { anchorElement, event, parentContextMenu } = context;\n        if (!parentContextMenu) {\n            const mouseEvent = event;\n            this.fakeElement.getBoundingClientRect = () => ({\n                bottom: mouseEvent.clientY,\n                height: 0,\n                left: mouseEvent.clientX,\n                right: mouseEvent.clientX,\n                top: mouseEvent.clientY,\n                width: 0,\n            });\n            this.closeAllContextMenus({ eventType: 'cancel', event });\n            const positionStrategy = this.overlay.position().connectedTo(new ElementRef(anchorElement || this.fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            const positionStrategy = this.overlay.position().connectedTo(new ElementRef(event ? event.target : anchorElement), { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            const newOverlay = this.overlay.create({\n                positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    }\n    attachContextMenu(overlay, context) {\n        const { event, item, menuItems, menuClass } = context;\n        const contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        contextMenuContent.instance.menuClass = menuClass;\n        overlay.contextMenu = contextMenuContent.instance;\n        const subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe((executeEvent) => this.closeAllContextMenus(Object.assign({ eventType: 'execute' }, executeEvent))));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe((closeAllEvent) => this.closeAllContextMenus(Object.assign({ eventType: 'cancel' }, closeAllEvent))));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(closeLeafMenuEvent => this.destroyLeafMenu(closeLeafMenuEvent)));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe((subMenuEvent) => {\n            this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(() => {\n            menuItems.forEach(menuItem => menuItem.isActive = false);\n            subscriptions.unsubscribe();\n        });\n        contextMenuContent.changeDetectorRef.detectChanges();\n    }\n    closeAllContextMenus(closeEvent) {\n        if (this.overlays) {\n            this.close.next(closeEvent);\n            this.overlays.forEach((overlay, index) => {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    }\n    getLastAttachedOverlay() {\n        let overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    }\n    destroyLeafMenu({ exceptRootMenu, event } = {}) {\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(() => {\n            const overlay = this.getLastAttachedOverlay();\n            if (this.overlays.length > 1 && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            if (!exceptRootMenu && this.overlays.length > 0 && overlay) {\n                this.close.next({ eventType: 'cancel', event });\n                overlay.detach();\n                overlay.dispose();\n            }\n            const newLeaf = this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            this.isDestroyingLeafMenu = false;\n        });\n    }\n    destroySubMenus(contextMenu) {\n        const overlay = contextMenu.overlay;\n        const index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(subMenuOverlay => {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    }\n    isLeafMenu(contextMenuContent) {\n        const overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    }\n}\nContextMenuService.fac = function ContextMenuService_Factory(t) { return new (t || ContextMenuService)(ngcc0.inject(ngcc2.Overlay), ngcc0.inject(ngcc2.ScrollStrategyOptions)); };\nContextMenuService.prov = /*@__PURE__*/ ngcc0.defineInjectable({ token: ContextMenuService, factory: ContextMenuService.fac });\n/** @nocollapse */\nContextMenuService.ctorParameters = () => [\n    { type: Overlay },\n    { type: ScrollStrategyOptions }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContextMenuService, [{\n        type: Injectable\n    }], function () { return [{ type: ngcc2.Overlay }, { type: ngcc2.ScrollStrategyOptions }]; }, null); })();\n\nclass ContextMenuComponent {\n    constructor(_contextMenuService, changeDetector, elementRef, options) {\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.menuClass = \"\";\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(menuEvent => {\n            this.onMenuEvent(menuEvent);\n        }));\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n    }\n    onMenuEvent(menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        const { contextMenu, event, item } = menuEvent;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(Object.assign(Object.assign({}, menuEvent), { menuItems: this.visibleMenuItems, menuClass: this.menuClass }));\n        this._contextMenuService.close.asObservable().pipe(first()).subscribe(closeEvent => this.close.emit(closeEvent));\n        this.open.next(menuEvent);\n    }\n    isMenuItemVisible(menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    }\n    setVisibleMenuItems() {\n        this.visibleMenuItems = this.menuItems.filter(menuItem => this.isMenuItemVisible(menuItem));\n    }\n    evaluateIfFunction(value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    }\n}\nContextMenuComponent.fac = function ContextMenuComponent_Factory(t) { return new (t || ContextMenuComponent)(ngcc0.directiveInject(ContextMenuService), ngcc0.directiveInject(ngcc0.ChangeDetectorRef), ngcc0.directiveInject(ngcc0.ElementRef), ngcc0.directiveInject(CONTEXT_MENU_OPTIONS, 8)); };\nContextMenuComponent.cmp = /*@__PURE__*/ ngcc0.defineComponent({ type: ContextMenuComponent, selectors: [[\"context-menu\"]], contentQueries: function ContextMenuComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\n        ngcc0.contentQuery(dirIndex, ContextMenuItemDirective, 4);\n    } if (rf & 2) {\n        let _t;\n        ngcc0.queryRefresh(_t = ngcc0.loadQuery()) && (ctx.menuItems = _t);\n    } }, viewQuery: function ContextMenuComponent_Query(rf, ctx) { if (rf & 1) {\n        ngcc0.viewQuery(_c0, 5);\n    } if (rf & 2) {\n        let _t;\n        ngcc0.queryRefresh(_t = ngcc0.loadQuery()) && (ctx.menuElement = _t.first);\n    } }, inputs: { menuClass: \"menuClass\", autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, outputs: { close: \"close\", open: \"open\" }, decls: 1, vars: 0, template: function ContextMenuComponent_Template(rf, ctx) { if (rf & 1) {\n        ngcc0.text(0, \" \");\n    } }, styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"], encapsulation: 2 });\n/** @nocollapse */\nContextMenuComponent.ctorParameters = () => [\n    { type: ContextMenuService },\n    { type: ChangeDetectorRef },\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] }] }\n];\nContextMenuComponent.propDecorators = {\n    menuClass: [{ type: Input }],\n    autoFocus: [{ type: Input }],\n    useBootstrap4: [{ type: Input }],\n    disabled: [{ type: Input }],\n    close: [{ type: Output }],\n    open: [{ type: Output }],\n    menuItems: [{ type: ContentChildren, args: [ContextMenuItemDirective,] }],\n    menuElement: [{ type: ViewChild, args: ['menu', { static: false },] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContextMenuComponent, [{\n        type: Component,\n        args: [{\n                encapsulation: ViewEncapsulation.None,\n                selector: 'context-menu',\n                template: ` `,\n                styles: [`\n    .cdk-overlay-container {\n      position: fixed;\n      z-index: 1000;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n    .ngx-contextmenu.cdk-overlay-pane {\n      position: absolute;\n      pointer-events: auto;\n      box-sizing: border-box;\n    }\n  `]\n            }]\n    }], function () { return [{ type: ContextMenuService }, { type: ngcc0.ChangeDetectorRef }, { type: ngcc0.ElementRef }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [CONTEXT_MENU_OPTIONS]\n            }] }]; }, { menuClass: [{\n            type: Input\n        }], autoFocus: [{\n            type: Input\n        }], useBootstrap4: [{\n            type: Input\n        }], disabled: [{\n            type: Input\n        }], close: [{\n            type: Output\n        }], open: [{\n            type: Output\n        }], menuItems: [{\n            type: ContentChildren,\n            args: [ContextMenuItemDirective]\n        }], menuElement: [{\n            type: ViewChild,\n            args: ['menu', { static: false }]\n        }] }); })();\n\nclass ContextMenuAttachDirective {\n    constructor(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    onContextMenu(event) {\n        if (!this.contextMenu.disabled) {\n            this.contextMenuService.show.next({\n                contextMenu: this.contextMenu,\n                event,\n                item: this.contextMenuSubject,\n            });\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n}\nContextMenuAttachDirective.fac = function ContextMenuAttachDirective_Factory(t) { return new (t || ContextMenuAttachDirective)(ngcc0.directiveInject(ContextMenuService)); };\nContextMenuAttachDirective.dir = /*@__PURE__*/ ngcc0.defineDirective({ type: ContextMenuAttachDirective, selectors: [[\"\", \"contextMenu\", \"\"]], hostBindings: function ContextMenuAttachDirective_HostBindings(rf, ctx) { if (rf & 1) {\n        ngcc0.listener(\"contextmenu\", function ContextMenuAttachDirective_contextmenu_HostBindingHandler($event) { return ctx.onContextMenu($event); });\n    } }, inputs: { contextMenuSubject: \"contextMenuSubject\", contextMenu: \"contextMenu\" } });\n/** @nocollapse */\nContextMenuAttachDirective.ctorParameters = () => [\n    { type: ContextMenuService }\n];\nContextMenuAttachDirective.propDecorators = {\n    contextMenuSubject: [{ type: Input }],\n    contextMenu: [{ type: Input }],\n    onContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContextMenuAttachDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[contextMenu]'\n            }]\n    }], function () { return [{ type: ContextMenuService }]; }, { onContextMenu: [{\n            type: HostListener,\n            args: ['contextmenu', ['$event']]\n        }], contextMenuSubject: [{\n            type: Input\n        }], contextMenu: [{\n            type: Input\n        }] }); })();\n\nclass ContextMenuModule {\n    static forRoot(options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n                { provide: OverlayContainer, useClass: FullscreenOverlayContainer },\n            ],\n        };\n    }\n}\nContextMenuModule.fac = function ContextMenuModule_Factory(t) { return new (t || ContextMenuModule)(); };\nContextMenuModule.mod = /*@__PURE__*/ ngcc0.defineNgModule({ type: ContextMenuModule });\nContextMenuModule.inj = /*@__PURE__*/ ngcc0.defineInjector({ imports: [[\n            CommonModule,\n            OverlayModule,\n        ]] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ngcc0.setClassMetadata(ContextMenuModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    ContextMenuAttachDirective,\n                    ContextMenuComponent,\n                    ContextMenuContentComponent,\n                    ContextMenuItemDirective,\n                ],\n                entryComponents: [\n                    ContextMenuContentComponent,\n                ],\n                exports: [\n                    ContextMenuAttachDirective,\n                    ContextMenuComponent,\n                    ContextMenuItemDirective,\n                ],\n                imports: [\n                    CommonModule,\n                    OverlayModule,\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ngcc0.setNgModuleScope(ContextMenuModule, { declarations: function () { return [ContextMenuAttachDirective, ContextMenuComponent, ContextMenuContentComponent, ContextMenuItemDirective]; }, imports: function () { return [CommonModule,\n        OverlayModule]; }, exports: function () { return [ContextMenuAttachDirective, ContextMenuComponent, ContextMenuItemDirective]; } }); })();\n\n/*\n * Public API Surface of ngx-contextmenu\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ContextMenuAttachDirective, ContextMenuComponent, ContextMenuItemDirective, ContextMenuModule, ContextMenuService, CONTEXT_MENU_OPTIONS as a, ContextMenuContentComponent as b };\n\n","import { operate } from '../util/lift';\nimport { innerFrom } from '../observable/from';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function audit(durationSelector) {\n    return operate(function (source, subscriber) {\n        var hasValue = false;\n        var lastValue = null;\n        var durationSubscriber = null;\n        var isComplete = false;\n        var endDuration = function () {\n            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            durationSubscriber = null;\n            if (hasValue) {\n                hasValue = false;\n                var value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n            isComplete && subscriber.complete();\n        };\n        var cleanupDuration = function () {\n            durationSubscriber = null;\n            isComplete && subscriber.complete();\n        };\n        source.subscribe(new OperatorSubscriber(subscriber, function (value) {\n            hasValue = true;\n            lastValue = value;\n            if (!durationSubscriber) {\n                innerFrom(durationSelector(value)).subscribe((durationSubscriber = new OperatorSubscriber(subscriber, endDuration, cleanupDuration)));\n            }\n        }, function () {\n            isComplete = true;\n            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }));\n    });\n}\n","import { async } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nexport function auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async; }\n    return audit(function () { return timer(duration, scheduler); });\n}\n","import { ReplaySubject } from '../ReplaySubject';\nimport { share } from './share';\nexport function shareReplay(configOrBufferSize, windowTime, scheduler) {\n    var _a, _b;\n    var bufferSize;\n    var refCount = false;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        bufferSize = (_a = configOrBufferSize.bufferSize) !== null && _a !== void 0 ? _a : Infinity;\n        windowTime = (_b = configOrBufferSize.windowTime) !== null && _b !== void 0 ? _b : Infinity;\n        refCount = !!configOrBufferSize.refCount;\n        scheduler = configOrBufferSize.scheduler;\n    }\n    else {\n        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;\n    }\n    return share({\n        connector: function () { return new ReplaySubject(bufferSize, windowTime, scheduler); },\n        resetOnError: true,\n        resetOnComplete: false,\n        resetOnRefCountZero: refCount\n    });\n}\n","import { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function takeWhile(predicate, inclusive) {\n    if (inclusive === void 0) { inclusive = false; }\n    return operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(new OperatorSubscriber(subscriber, function (value) {\n            var result = predicate(value, index++);\n            (result || inclusive) && subscriber.next(value);\n            !result && subscriber.complete();\n        }));\n    });\n}\n","import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { animationFrameProvider } from './animationFrameProvider';\nvar AnimationFrameAction = (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            animationFrameProvider.cancelAnimationFrame(id);\n            scheduler._scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction));\nexport { AnimationFrameAction };\n","import { __extends } from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AnimationFrameScheduler = (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this._active = true;\n        this._scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        action = action || actions.shift();\n        var count = actions.length;\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this._active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler));\nexport { AnimationFrameScheduler };\n","import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { immediateProvider } from './immediateProvider';\nvar AsapAction = (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            immediateProvider.clearImmediate(id);\n            scheduler._scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction));\nexport { AsapAction };\n","import { __extends } from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AsapScheduler = (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this._active = true;\n        this._scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        action = action || actions.shift();\n        var count = actions.length;\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this._active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler));\nexport { AsapScheduler };\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\nexport var animationFrame = animationFrameScheduler;\n","import { __read, __spreadArray } from \"tslib\";\nimport { Subscription } from '../Subscription';\nexport var animationFrameProvider = {\n    schedule: function (callback) {\n        var request = requestAnimationFrame;\n        var cancel = cancelAnimationFrame;\n        var delegate = animationFrameProvider.delegate;\n        if (delegate) {\n            request = delegate.requestAnimationFrame;\n            cancel = delegate.cancelAnimationFrame;\n        }\n        var handle = request(function (timestamp) {\n            cancel = undefined;\n            callback(timestamp);\n        });\n        return new Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });\n    },\n    requestAnimationFrame: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = animationFrameProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));\n    },\n    cancelAnimationFrame: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = animationFrameProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));\n    },\n    delegate: undefined,\n};\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport var asapScheduler = new AsapScheduler(AsapAction);\nexport var asap = asapScheduler;\n","import { __read, __spreadArray } from \"tslib\";\nimport { Immediate } from '../util/Immediate';\nvar setImmediate = Immediate.setImmediate, clearImmediate = Immediate.clearImmediate;\nexport var immediateProvider = {\n    setImmediate: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = immediateProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));\n    },\n    clearImmediate: function (handle) {\n        var delegate = immediateProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);\n    },\n    delegate: undefined,\n};\n","var nextHandle = 1;\nvar resolved;\nvar activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexport var Immediate = {\n    setImmediate: function (cb) {\n        var handle = nextHandle++;\n        activeHandles[handle] = true;\n        if (!resolved) {\n            resolved = Promise.resolve();\n        }\n        resolved.then(function () { return findAndClearHandle(handle) && cb(); });\n        return handle;\n    },\n    clearImmediate: function (handle) {\n        findAndClearHandle(handle);\n    },\n};\nexport var TestTools = {\n    pending: function () {\n        return Object.keys(activeHandles).length;\n    }\n};\n","import { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n","<mwl-demo-utils-calendar-header [(view)]=\"view\" [(viewDate)]=\"viewDate\">\n</mwl-demo-utils-calendar-header>\n\n<context-menu #basicMenu>\n  <ng-template contextMenuItem (execute)=\"addEvent($event.item)\">\n    Add event\n  </ng-template>\n</context-menu>\n\n<ng-template\n  #monthCellTemplate\n  let-day=\"day\"\n  let-openDay=\"openDay\"\n  let-locale=\"locale\"\n  let-tooltipPlacement=\"tooltipPlacement\"\n  let-highlightDay=\"highlightDay\"\n  let-unhighlightDay=\"unhighlightDay\"\n  let-eventClicked=\"eventClicked\"\n>\n  <div\n    class=\"fill-height\"\n    [contextMenu]=\"basicMenu\"\n    [contextMenuSubject]=\"day.date\"\n  >\n    <div class=\"cal-cell-top\">\n      <span class=\"cal-day-badge\" *ngIf=\"day.badgeTotal > 0\"\n        >{{ day.badgeTotal }}</span\n      >\n      <span class=\"cal-day-number\"\n        >{{ day.date | calendarDate:'monthViewDayNumber':locale }}</span\n      >\n    </div>\n    <div class=\"cal-events\">\n      <div\n        class=\"cal-event\"\n        *ngFor=\"let event of day.events\"\n        [style.backgroundColor]=\"event.color.primary\"\n        [ngClass]=\"event?.cssClass\"\n        (mouseenter)=\"highlightDay.emit({event: event})\"\n        (mouseleave)=\"unhighlightDay.emit({event: event})\"\n        [mwlCalendarTooltip]=\"event.title | calendarEventTitle:'monthTooltip':event\"\n        [tooltipPlacement]=\"tooltipPlacement\"\n        (click)=\"$event.stopPropagation(); eventClicked.emit({event: event})\"\n      ></div>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template\n  #weekHeaderTemplate\n  let-days=\"days\"\n  let-locale=\"locale\"\n  let-dayHeaderClicked=\"dayHeaderClicked\"\n>\n  <div class=\"cal-day-headers\">\n    <div\n      class=\"cal-header\"\n      *ngFor=\"let day of days\"\n      [class.cal-past]=\"day.isPast\"\n      [class.cal-today]=\"day.isToday\"\n      [class.cal-future]=\"day.isFuture\"\n      [class.cal-weekend]=\"day.isWeekend\"\n      (click)=\"dayHeaderClicked.emit({day: day})\"\n      [contextMenu]=\"basicMenu\"\n      [contextMenuSubject]=\"day.date\"\n    >\n      <b>{{ day.date | calendarDate:'weekViewColumnHeader':locale }}</b><br />\n      <span\n        >{{ day.date | calendarDate:'weekViewColumnSubHeader':locale }}</span\n      >\n    </div>\n  </div>\n</ng-template>\n\n<ng-template\n  #dayHourSegmentTemplate\n  let-segment=\"segment\"\n  let-locale=\"locale\"\n  let-segmentHeight=\"segmentHeight\"\n>\n  <div\n    class=\"cal-hour-segment\"\n    [style.height.px]=\"segmentHeight\"\n    [class.cal-hour-start]=\"segment.isStart\"\n    [class.cal-after-hour-start]=\"!segment.isStart\"\n    [ngClass]=\"segment.cssClass\"\n    [contextMenu]=\"basicMenu\"\n    [contextMenuSubject]=\"segment.date\"\n  >\n    <div class=\"cal-time\">\n      {{ segment.date | calendarDate: 'dayViewHour':locale }}\n    </div>\n  </div>\n</ng-template>\n\n<ng-template\n  #weekViewHourSegment\n  let-segment=\"segment\"\n  let-locale=\"locale\"\n  let-segmentHeight=\"segmentHeight\"\n  let-isTimeLabel=\"isTimeLabel\"\n>\n  <div\n    class=\"cal-hour-segment\"\n    [style.height.px]=\"segmentHeight\"\n    [class.cal-hour-start]=\"segment.isStart\"\n    [class.cal-after-hour-start]=\"!segment.isStart\"\n    [ngClass]=\"segment.cssClass\"\n    [contextMenu]=\"basicMenu\"\n    [contextMenuSubject]=\"segment.date\"\n  >\n    <div class=\"cal-time\" *ngIf=\"isTimeLabel\">\n      {{ segment.date | calendarDate: 'weekViewHour':locale }}\n    </div>\n  </div>\n</ng-template>\n\n<div [ngSwitch]=\"view\">\n  <mwl-calendar-month-view\n    *ngSwitchCase=\"'month'\"\n    [viewDate]=\"viewDate\"\n    [events]=\"events\"\n    [refresh]=\"refresh\"\n    [cellTemplate]=\"monthCellTemplate\"\n  >\n  </mwl-calendar-month-view>\n  <mwl-calendar-week-view\n    *ngSwitchCase=\"'week'\"\n    [viewDate]=\"viewDate\"\n    [events]=\"events\"\n    [refresh]=\"refresh\"\n    [headerTemplate]=\"weekHeaderTemplate\"\n    [hourSegmentTemplate]=\"weekViewHourSegment\"\n  >\n  </mwl-calendar-week-view>\n  <mwl-calendar-day-view\n    *ngSwitchCase=\"'day'\"\n    [viewDate]=\"viewDate\"\n    [events]=\"events\"\n    [refresh]=\"refresh\"\n    [hourSegmentTemplate]=\"dayHourSegmentTemplate\"\n  >\n  </mwl-calendar-day-view>\n</div>\n","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent, CalendarView } from 'angular-calendar';\nimport { Subject } from 'rxjs';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n      .fill-height {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        align-items: stretch;\n      }\n    `,\n  ],\n})\nexport class DemoComponent {\n  view: CalendarView = CalendarView.Month;\n\n  viewDate = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh = new Subject<void>();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red,\n    });\n    this.refresh.next();\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule, DateAdapter } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\nimport { adapterFactory } from 'angular-calendar/date-adapters/date-fns';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot({\n      provide: DateAdapter,\n      useFactory: adapterFactory,\n    }),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true,\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }]),\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent],\n})\nexport class DemoModule {}\n","import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { CalendarView } from 'angular-calendar';\n\n@Component({\n  selector: 'mwl-demo-utils-calendar-header',\n  template: `\n    <div class=\"row text-center\">\n      <div class=\"col-md-4\">\n        <div class=\"btn-group\">\n          <div\n            class=\"btn btn-primary\"\n            mwlCalendarPreviousView\n            [view]=\"view\"\n            [(viewDate)]=\"viewDate\"\n            (viewDateChange)=\"viewDateChange.next(viewDate)\"\n          >\n            Previous\n          </div>\n          <div\n            class=\"btn btn-outline-secondary\"\n            mwlCalendarToday\n            [(viewDate)]=\"viewDate\"\n            (viewDateChange)=\"viewDateChange.next(viewDate)\"\n          >\n            Today\n          </div>\n          <div\n            class=\"btn btn-primary\"\n            mwlCalendarNextView\n            [view]=\"view\"\n            [(viewDate)]=\"viewDate\"\n            (viewDateChange)=\"viewDateChange.next(viewDate)\"\n          >\n            Next\n          </div>\n        </div>\n      </div>\n      <div class=\"col-md-4\">\n        <h3>{{ viewDate | calendarDate: view + 'ViewTitle':locale }}</h3>\n      </div>\n      <div class=\"col-md-4\">\n        <div class=\"btn-group\">\n          <div\n            class=\"btn btn-primary\"\n            (click)=\"viewChange.emit(CalendarView.Month)\"\n            [class.active]=\"view === CalendarView.Month\"\n          >\n            Month\n          </div>\n          <div\n            class=\"btn btn-primary\"\n            (click)=\"viewChange.emit(CalendarView.Week)\"\n            [class.active]=\"view === CalendarView.Week\"\n          >\n            Week\n          </div>\n          <div\n            class=\"btn btn-primary\"\n            (click)=\"viewChange.emit(CalendarView.Day)\"\n            [class.active]=\"view === CalendarView.Day\"\n          >\n            Day\n          </div>\n        </div>\n      </div>\n    </div>\n    <br />\n  `,\n})\nexport class CalendarHeaderComponent {\n  @Input() view: CalendarView;\n\n  @Input() viewDate: Date;\n\n  @Input() locale: string = 'en';\n\n  @Output() viewChange = new EventEmitter<CalendarView>();\n\n  @Output() viewDateChange = new EventEmitter<Date>();\n\n  CalendarView = CalendarView;\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { CalendarModule } from 'angular-calendar';\nimport { CalendarHeaderComponent } from './calendar-header.component';\n\n@NgModule({\n  imports: [CommonModule, FormsModule, CalendarModule],\n  declarations: [CalendarHeaderComponent],\n  exports: [CalendarHeaderComponent],\n})\nexport class DemoUtilsModule {}\n"]}