{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,8BACA;AACA;AACA;AACA;AACA;;AACA;AACAA;AACA,OAFA,CAGA;AACAA;AACA;AACA;AACA;AACA;AACA;;;UACAC,YACA;AAAA;;AACA,uCADA,CAEA;AACA;AACA;;AACA;;AACA,4CACY,oEAAiB,gBAAjB,CADZ,GAC6B,0CAD7B;AAEA;;AACA;AACA;;AACA,qFAXA,CAYA;;AACA;;AACA,kFACA,0BADA,IACA,UADA,IACA,aADA,CAdA,CAgBA;AACA;;AACA;;AACA,wCACA,wCADA,IACA,WADA,IACA,UADA,IACA,aADA;AAEA;;AACA,qFACA,uBADA,CAtBA,CAwBA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA,+FAhCA,CAiCA;AACA;AACA;;AACA;;AACA;AACA;;AAEAA;AAA+C,oCAA2BC,uDAAgBA,sDAAhB,CAA3B;AAAsD,OAArG;;AACAD,wBAAiBC,iEAAqB;AAAGC;AAAuC,+BAAoBD,uDAAYA,sDAAZ,CAApB;AAAmD,SAA7F;AAA6FE,wBAA7F;AAA6FC;AAA7F,OAArB,CAAjB;;AACAJ;AAAA,gBACA;AAAMK,sBAAN;AAAMC;AAA6BD,kBAAMJ,iDAAnC;AAAyCM,mBAASN,sDAAT;AAAzC;AAAN,SADA;AAAA;;AAGA;AAAe,2DAAmDA,gEAAwBD,SAAxB,EAAwB;AAC1FK,gBAAcJ,qDAD4E;AAE1FM;AAAiBH;AAAjB;AAF0F,UAAxB,EAG7D;AAAiB;AAAUC,wBAAV;AAAUC;AAChCD,oBAAsBJ,iDADU;AAEhCM,qBAAuBN,sDAAvB;AAFgC;AAAV;AAGF,SAN8C,EAM9C,IAN8C,CAAnD;AAMe,OAN9B;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;UACAO;;;;AAEAA;AAA2D;AAAA,OAA3D;;AACAA,0CAAoCP,+DAAuB;AAAGI;AAAH,OAAvB,CAApC;AACAG,0CAAoCP,+DAAuB,EAAvB,CAApC;;AACA;AAAe,2DAAmDA,gEAAwBO,eAAxB,EAAwB;AAC1FH,gBAAcJ,mDAD4E;AAE1FM;AAF0F,UAAxB,EAG7D,IAH6D,EAG7D,IAH6D,CAAnD;AAGO,OAHtB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;;AACA,iCACA;AACA;AACA;AACA;AACA,aALA,EAMA,QANA,EAOA,UAPA,EAQA,MARA,EASA,gBATA,EAUA,OAVA,EAWA,MAXA,EAYA,QAZA,EAaA,OAbA,EAcA,OAdA,EAeA,QAfA,EAgBA,UAhBA,EAiBA,OAjBA,EAkBA,OAlBA,EAmBA,OAnBA,EAoBA,QApBA,EAqBA,QArBA,EAsBA,KAtBA,EAuBA,MAvBA,EAwBA,MAxBA,EAyBA,KAzBA,EA0BA,MA1BA;AA4BA;;AACA;AACA;AACA;AACA;AACA,SAJA,CAKA;AACA;AACA;;;AACA;AACAE;AACA;AACA;;AACA;AACAA;AACAC;AACA;AACK,SAHL;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACAC,4EAA0E,SAA1E,EAA0E;AAC1EC;AAAA;AAAA;AAD0E,aAA1E;AAGA,WAJA,SAKA;AACAC;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AACA,WANA,CAOA;;;AACA;AACAA;AACA,WAFA,MAGA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACAA,qEAAqEC,IAArE,CAAqEC,2BAArE;AACA,aANA,MAOA;AACAF;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;AACAG;AACAC;AACAA;AACAA;AACAA;AACAA;AACA;AACA;AACAC;AACAA;AACAF;AACAG;AACAC;AAAA;AAAA,WAhBA,CAiBA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACAJ;AACAI,gCACAJ;AAAA;AAAA;AAAA;AADA;AAEA;;AACAA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACAK;AACA;;AACA;AACA;AACA;;;AACA;AACA;AACA,4EADA,CAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA,0EACAF,sBADA,GACA,IADA;;AAEA;AACA;;AACA;AACA;AACA,WAFA,MAGA;AACAG;AACA;AACA;;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA,0CAA+BC,KAA/B,MAAqC,OAArC;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA;AACA;AACA;AACA;;AACA,6DAAkDA,KAAlD;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA;AACA,uCAAmCC,qDAAnC,GAA6CC,0BAA7C,GAA6CA,YAA7C;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;;AACA;AACA,sEAA+DF,KAA/D,EAAqEG,KAArE,CAAqEC,SAArE;;AADA,qDAEAC,YAFA;AAAA;;AAAA;AAEA;AAAA;AACA,4CAAqCC,WAArC,EAAiDC,IAAjD;;AACA;AACAC;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAQA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7HO,eAASC,aAAT,CAAsBC,OAAtB,EAA+BC,SAA/B,EAA0C;AAC7C,YAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,mBAAS,GAAGC,4DAAZD;AAA6B;;AACzD,eAAOE,qDAAQ,UAAUC,MAAV,EAAkBC,UAAlB,EAA8B;AACzC,cAAIC,UAAU,GAAG,IAAjB;AACA,cAAIC,SAAS,GAAG,IAAhB;AACA,cAAIC,QAAQ,GAAG,IAAf;;AACA,cAAIC,IAAI,GAAG,SAAPA,IAAO,GAAY;AACnB,gBAAIH,UAAJ,EAAgB;AACZA,wBAAU,CAACI,WAAXJ;AACAA,wBAAU,GAAG,IAAbA;AACA,kBAAIhB,KAAK,GAAGiB,SAAZ;AACAA,uBAAS,GAAG,IAAZA;AACAF,wBAAU,CAACM,IAAXN,CAAgBf,KAAhBe;AACH;AAPL;;AASA,mBAASO,YAAT,GAAwB;AACpB,gBAAIC,UAAU,GAAGL,QAAQ,GAAGR,OAA5B;AACA,gBAAIc,GAAG,GAAGb,SAAS,CAACa,GAAVb,EAAV;;AACA,gBAAIa,GAAG,GAAGD,UAAV,EAAsB;AAClBP,wBAAU,GAAG,KAAKS,QAAL,CAAcC,SAAd,EAAyBH,UAAU,GAAGC,GAAtC,CAAbR;AACAD,wBAAU,CAACY,GAAXZ,CAAeC,UAAfD;AACA;AACH;;AACDI,gBAAI;AACP;;AACDL,gBAAM,CAACc,SAAPd,CAAiB,IAAIe,mEAAJ,CAAuBd,UAAvB,EAAmC,UAAUf,KAAV,EAAiB;AACjEiB,qBAAS,GAAGjB,KAAZiB;AACAC,oBAAQ,GAAGP,SAAS,CAACa,GAAVb,EAAXO;;AACA,gBAAI,CAACF,UAAL,EAAiB;AACbA,wBAAU,GAAGL,SAAS,CAACc,QAAVd,CAAmBW,YAAnBX,EAAiCD,OAAjCC,CAAbK;AACAD,wBAAU,CAACY,GAAXZ,CAAeC,UAAfD;AACH;AANY,aAOd,YAAY;AACXI,gBAAI;AACJJ,sBAAU,CAACe,QAAXf;AATa,aAUdW,SAVc,EAUH,YAAY;AACtBT,qBAAS,GAAGD,UAAU,GAAG,IAAzBC;AAXa,YAAjBH;AAvBU,SAAPD,CAAP;AAqCH;;;;","names":["hasV8BreakIterator","Platform","_angular_core__WEBPACK_IMPORTED_MODULE_1__","factory","token","providedIn","type","decorators","args","PlatformModule","supportedInputTypes","featureTestInput","window","get","supportsPassiveEvents","scrollBehaviorSupported","test","scrollToFunction","scrollContainer","containerStyle","contentStyle","document","rtlScrollAxisType","shadowDomIsSupported","activeElement","value","_angular_core__WEBPACK_IMPORTED_MODULE_0__","elementOrRef","split","separator","sourceValues","sourceValue","trim","result","debounceTime","dueTime","scheduler","asyncScheduler","operate","source","subscriber","activeTask","lastValue","lastTime","emit","unsubscribe","next","emitWhenIdle","targetTime","now","schedule","undefined","add","subscribe","OperatorSubscriber","complete"],"sources":["webpack:///node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js","webpack:///node_modules/@angular/cdk/fesm2015/coercion.js","webpack:///node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nimport * as ɵngcc0 from '@angular/core';\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n}\ncatch (_a) {\n    hasV8BreakIterator = false;\n}\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nclass Platform {\n    constructor(_platformId) {\n        this._platformId = _platformId;\n        // We want to use the Angular platform check because if the Document is shimmed\n        // without the navigator, the following checks will fail. This is preferred because\n        // sometimes the Document may be shimmed without the user's knowledge or intention\n        /** Whether the Angular application is being rendered in the browser. */\n        this.isBrowser = this._platformId ?\n            isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\n        /** Whether the current browser is Microsoft Edge. */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /** Whether the current rendering engine is Microsoft Trident. */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n        /** Whether the current rendering engine is Blink. */\n        this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n        // ensure that Webkit runs standalone and is not used as another engine's base.\n        /** Whether the current rendering engine is WebKit. */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /** Whether the current platform is Apple iOS. */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !('MSStream' in window);\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\n        // instead of having an unstable check for Gecko.\n        /** Whether the current browser is Firefox. */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /** Whether the current platform is Android. */\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n        // Safari browser should also use Webkit as its layout engine.\n        /** Whether the current browser is Safari. */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n}\nPlatform.ɵfac = function Platform_Factory(t) { return new (t || Platform)(ɵngcc0.ɵɵinject(PLATFORM_ID)); };\nPlatform.ɵprov = i0.ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: Platform, providedIn: \"root\" });\nPlatform.ctorParameters = () => [\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Platform, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass PlatformModule {\n}\nPlatformModule.ɵfac = function PlatformModule_Factory(t) { return new (t || PlatformModule)(); };\nPlatformModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: PlatformModule });\nPlatformModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlatformModule, [{\n        type: NgModule,\n        args: [{}]\n    }], null, null); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    let featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if ('scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return 0 /* NORMAL */;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = 0 /* NORMAL */;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? 1 /* NEGATED */ : 2 /* INVERTED */;\n        }\n        scrollContainer.parentNode.removeChild(scrollContainer);\n    }\n    return rtlScrollAxisType;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document ?\n        document.activeElement : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, PlatformModule, _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _supportsShadowDom, getRtlScrollAxisType, getSupportedInputTypes, normalizePassiveListenerOptions, supportsPassiveEventListeners, supportsScrollBehavior };\n\n","import { ElementRef } from '@angular/core';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a data-bound value (typically a string) to a boolean. */\nfunction coerceBooleanProperty(value) {\n    return value != null && `${value}` !== 'false';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nfunction coerceElement(elementOrRef) {\n    return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces a value to an array of trimmed non-empty strings.\n * Any input that is not an array, `null` or `undefined` will be turned into a string\n * via `toString()` and subsequently split with the given separator.\n * `null` and `undefined` will result in an empty array.\n * This results in the following outcomes:\n * - `null` -&gt; `[]`\n * - `[null]` -&gt; `[\"null\"]`\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\n *\n * Useful for defining CSS classes or table columns.\n * @param value the value to coerce into an array of strings\n * @param separator split-separator if value isn't an array\n */\nfunction coerceStringArray(value, separator = /\\s+/) {\n    const result = [];\n    if (value != null) {\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\n        for (const sourceValue of sourceValues) {\n            const trimmedString = `${sourceValue}`.trim();\n            if (trimmedString) {\n                result.push(trimmedString);\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { _isNumberValue, coerceArray, coerceBooleanProperty, coerceCssPixelValue, coerceElement, coerceNumberProperty, coerceStringArray };\n","import { asyncScheduler } from '../scheduler/async';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nexport function debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = asyncScheduler; }\n    return operate(function (source, subscriber) {\n        var activeTask = null;\n        var lastValue = null;\n        var lastTime = null;\n        var emit = function () {\n            if (activeTask) {\n                activeTask.unsubscribe();\n                activeTask = null;\n                var value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n        };\n        function emitWhenIdle() {\n            var targetTime = lastTime + dueTime;\n            var now = scheduler.now();\n            if (now < targetTime) {\n                activeTask = this.schedule(undefined, targetTime - now);\n                subscriber.add(activeTask);\n                return;\n            }\n            emit();\n        }\n        source.subscribe(new OperatorSubscriber(subscriber, function (value) {\n            lastValue = value;\n            lastTime = scheduler.now();\n            if (!activeTask) {\n                activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n                subscriber.add(activeTask);\n            }\n        }, function () {\n            emit();\n            subscriber.complete();\n        }, undefined, function () {\n            lastValue = activeTask = null;\n        }));\n    });\n}\n"]}